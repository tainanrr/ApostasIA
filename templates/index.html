<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ApostasIA — Engine de Análise Preditiva</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-card: #1a2235;
            --bg-card-hover: #1e2a42;
            --border: #2a3550;
            --border-light: #374163;
            --text-primary: #e8ecf4;
            --text-secondary: #8b95ab;
            --text-muted: #5a6580;
            --accent-green: #00e68a;
            --accent-green-dim: rgba(0,230,138,0.15);
            --accent-blue: #3b82f6;
            --accent-blue-dim: rgba(59,130,246,0.15);
            --accent-yellow: #f59e0b;
            --accent-yellow-dim: rgba(245,158,11,0.15);
            --accent-red: #ef4444;
            --accent-red-dim: rgba(239,68,68,0.15);
            --accent-purple: #8b5cf6;
            --accent-cyan: #06b6d4;
            --gradient-green: linear-gradient(135deg, #00e68a, #00b36b);
            --gradient-blue: linear-gradient(135deg, #3b82f6, #2563eb);
            --gradient-main: linear-gradient(135deg, #0a0e17 0%, #111827 50%, #0f1729 100%);
            --shadow-card: 0 4px 24px rgba(0,0,0,0.3);
            --shadow-glow: 0 0 20px rgba(0,230,138,0.1);
            --radius: 12px;
            --radius-sm: 8px;
            --radius-lg: 16px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* ── SCROLLBAR ── */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-light); }

        /* ── HEADER ── */
        header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 14px 32px;
            display: flex; align-items: center; justify-content: space-between;
            position: sticky; top: 0; z-index: 100;
            backdrop-filter: blur(12px);
        }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { font-size: 28px; }
        .logo h1 { font-size: 18px; font-weight: 800; letter-spacing: -0.5px; }
        .logo span { color: var(--accent-green); }
        .header-right { display: flex; align-items: center; gap: 14px; }
        .header-badge {
            background: var(--bg-card); border: 1px solid var(--border);
            padding: 6px 14px; border-radius: 20px; font-size: 12px;
            font-weight: 500; color: var(--text-secondary);
        }
        .header-badge.live { border-color: var(--accent-green); color: var(--accent-green); }
        .header-badge.warn { border-color: var(--accent-yellow); color: var(--accent-yellow); }

        /* ── API QUOTA BAR ── */
        .api-quota {
            display: flex; align-items: center; gap: 10px;
            background: var(--bg-card); border: 1px solid var(--border);
            padding: 6px 14px; border-radius: 20px; font-size: 11px;
            font-weight: 600;
        }
        .api-quota-bar {
            width: 80px; height: 6px; background: var(--border);
            border-radius: 3px; overflow: hidden;
        }
        .api-quota-fill {
            height: 100%; border-radius: 3px;
            transition: width 0.5s ease;
        }

        .btn-run {
            background: var(--gradient-green); border: none; color: #000;
            padding: 8px 20px; border-radius: 8px; font-size: 13px;
            font-weight: 700; cursor: pointer; transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }
        .btn-run:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(0,230,138,0.3); }
        .btn-run:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-run.running { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .btn-recalc, .btn-recalc-big {
            background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; color: #fff;
            padding: 8px 16px; border-radius: 8px; font-size: 12px;
            font-weight: 700; cursor: pointer; transition: all 0.2s;
            font-family: 'Inter', sans-serif; margin-left: 6px;
        }
        .btn-recalc:hover, .btn-recalc-big:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(59,130,246,0.4); }
        .btn-recalc:disabled, .btn-recalc-big:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-recalc-big { padding: 14px 28px; font-size: 15px; margin-top: 10px; display: block; }

        /* ── MAIN ── */
        main { max-width: 2000px; margin: 0 auto; padding: 24px 24px 60px; }

        /* ── WELCOME / EMPTY STATE ── */
        .welcome-state {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; min-height: 60vh; text-align: center;
        }
        .welcome-icon { font-size: 80px; margin-bottom: 24px; animation: pulse 2s infinite; }
        .welcome-title { font-size: 28px; font-weight: 800; margin-bottom: 12px; }
        .welcome-sub { color: var(--text-secondary); font-size: 15px; max-width: 500px; line-height: 1.7; margin-bottom: 32px; }
        .welcome-info {
            display: flex; gap: 24px; margin-bottom: 32px; flex-wrap: wrap; justify-content: center;
        }
        .welcome-info-item {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 16px 24px; text-align: center;
        }
        .welcome-info-item .num { font-size: 20px; font-weight: 800; color: var(--accent-green); }
        .welcome-info-item .lbl { font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-top: 4px; }
        .btn-run-big {
            background: var(--gradient-green); border: none; color: #000;
            padding: 16px 48px; border-radius: 12px; font-size: 16px;
            font-weight: 800; cursor: pointer; transition: all 0.2s;
            font-family: 'Inter', sans-serif; letter-spacing: -0.3px;
        }
        .btn-run-big:hover { transform: translateY(-2px); box-shadow: 0 8px 30px rgba(0,230,138,0.3); }
        .btn-run-big:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        .welcome-cost {
            margin-top: 16px; font-size: 12px; color: var(--text-muted);
        }
        @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.08); } }

        /* ── PROGRESS OVERLAY ── */
        .progress-overlay {
            position: fixed; inset: 0; z-index: 9999;
            background: rgba(10,14,23,0.92); backdrop-filter: blur(8px);
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .progress-overlay.show { display: flex; }
        .progress-icon { font-size: 64px; margin-bottom: 20px; animation: pulse 1.5s infinite; }
        .progress-title { font-size: 20px; font-weight: 700; margin-bottom: 8px; }
        .progress-sub { color: var(--text-secondary); font-size: 14px; margin-bottom: 24px; }
        .progress-bar-bg {
            width: 320px; height: 4px; background: var(--border);
            border-radius: 2px; overflow: hidden; margin-bottom: 16px;
        }
        .progress-bar {
            width: 0%; height: 100%; background: var(--gradient-green);
            border-radius: 2px; animation: indeterminate 2s infinite;
        }
        @keyframes indeterminate {
            0% { margin-left: 0; width: 20%; }
            50% { margin-left: 40%; width: 40%; }
            100% { margin-left: 100%; width: 20%; }
        }
        .progress-phase {
            font-size: 13px; color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        .progress-timer {
            margin-top: 8px; font-size: 24px; font-weight: 800;
            font-family: 'JetBrains Mono', monospace; color: var(--accent-green);
        }

        /* ── LAST RUN INFO BAR ── */
        .run-info-bar {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 14px 20px;
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .run-info-left { display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
        .run-info-item { font-size: 13px; color: var(--text-secondary); }
        .run-info-item strong { color: var(--text-primary); font-weight: 700; }
        .run-info-item .accent { color: var(--accent-green); font-weight: 700; }
        .run-info-separator { width: 1px; height: 20px; background: var(--border); }

        /* ── STATS ROW ── */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px; margin-bottom: 28px;
        }
        .stat-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px;
            transition: all 0.2s;
        }
        .stat-card:hover { border-color: var(--border-light); transform: translateY(-2px); box-shadow: var(--shadow-card); }
        .stat-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); font-weight: 600; margin-bottom: 8px; }
        .stat-value { font-size: 32px; font-weight: 800; letter-spacing: -1px; }
        .stat-value.green { color: var(--accent-green); }
        .stat-value.blue { color: var(--accent-blue); }
        .stat-value.yellow { color: var(--accent-yellow); }
        .stat-value.purple { color: var(--accent-purple); }
        .stat-sub { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }

        /* ── TABS ── */
        .tabs {
            display: flex; gap: 4px; margin-bottom: 24px;
            background: var(--bg-secondary); border-radius: var(--radius);
            padding: 4px; border: 1px solid var(--border); width: fit-content;
        }
        .tab {
            padding: 10px 20px; border-radius: var(--radius-sm);
            font-size: 13px; font-weight: 600; cursor: pointer;
            transition: all 0.2s; color: var(--text-secondary); border: none;
            background: transparent; font-family: 'Inter', sans-serif;
        }
        .tab:hover { color: var(--text-primary); }
        .tab.active { background: var(--accent-green); color: #000; }

        /* ── SECTION ── */
        .section { display: none; }
        .section.active { display: block; }
        .section-title {
            font-size: 20px; font-weight: 700; margin-bottom: 16px;
            display: flex; align-items: center; gap: 10px;
        }
        .section-title .icon { font-size: 24px; }
        .section-count {
            background: var(--accent-green-dim); color: var(--accent-green);
            padding: 2px 10px; border-radius: 12px; font-size: 12px; font-weight: 700;
        }

        /* ── TABLE ── */
        .table-wrap {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); overflow-x: auto;
        }
        table { width: 100%; border-collapse: collapse; min-width: 1650px; }
        #match-table { min-width: 1100px; }
        thead th {
            background: var(--bg-secondary); padding: 8px 8px;
            font-size: 10px; text-transform: uppercase; letter-spacing: 0.6px;
            color: var(--text-muted); font-weight: 700; text-align: left;
            border-bottom: 1px solid var(--border); white-space: nowrap;
            position: sticky; top: 0; z-index: 10;
        }
        tbody td {
            padding: 8px 8px; font-size: 12px; border-bottom: 1px solid var(--border);
            vertical-align: middle;
        }
        tbody tr { transition: background 0.15s; }
        tbody tr:hover { background: var(--bg-card-hover); }
        tbody tr:last-child td { border-bottom: none; }

        .team-cell { font-weight: 600; white-space: nowrap; }
        .vs { color: var(--text-muted); font-weight: 400; margin: 0 4px; font-size: 11px; }

        .badge {
            display: inline-block; padding: 3px 10px; border-radius: 6px;
            font-size: 11px; font-weight: 700; white-space: nowrap;
        }
        .badge-high { background: var(--accent-green-dim); color: var(--accent-green); }
        .badge-med { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .badge-low { background: var(--accent-red-dim); color: var(--accent-red); }

        .edge-cell { font-weight: 800; font-family: 'JetBrains Mono', monospace; font-size: 13px; }
        .edge-high { color: var(--accent-green); }
        .edge-med { color: var(--accent-yellow); }

        .odd-cell { font-family: 'JetBrains Mono', monospace; font-size: 13px; }
        .prob-bar-bg {
            width: 60px; height: 6px; background: var(--border);
            border-radius: 3px; overflow: hidden; display: inline-block;
            vertical-align: middle; margin-left: 6px;
        }
        .prob-bar { height: 100%; border-radius: 3px; }

        .market-tag {
            display: inline-block; padding: 3px 8px; border-radius: 5px;
            font-size: 10px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .market-1x2 { background: var(--accent-blue-dim); color: var(--accent-blue); }
        .market-dc { background: rgba(46, 134, 222, 0.2); color: #2e86de; }
        .market-ou { background: var(--accent-purple); color: #fff; opacity: 0.85; }
        .market-btts { background: var(--accent-cyan); color: #000; opacity: 0.85; }
        .market-corners { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .market-cards { background: var(--accent-red-dim); color: var(--accent-red); }
        .market-cs { background: rgba(0,206,209,0.18); color: #00ced1; }
        .market-wtn { background: rgba(255,165,0,0.18); color: #ffa500; }
        .market-ht { background: rgba(147,112,219,0.18); color: #9370db; }
        .market-oe { background: rgba(255,105,180,0.18); color: #ff69b4; }
        .market-exact { background: rgba(34,139,34,0.18); color: #228b22; }
        .market-shots { background: rgba(255,69,0,0.18); color: #ff4500; }
        .market-shots-real { background: rgba(255,69,0,0.30); color: #ff4500; border: 1px solid #ff4500; font-weight: 600; }
        .market-player-shots { background: rgba(186,85,211,0.18); color: #ba55d3; }
        .market-team-ou { background: rgba(255,215,0,0.18); color: #daa520; }

        /* ── RESULT STATUS BADGES ── */
        .result-green { background: var(--accent-green-dim); color: var(--accent-green); padding: 3px 8px; border-radius: 5px; font-size: 10px; font-weight: 800; display:inline-block; }
        .result-red { background: var(--accent-red-dim); color: var(--accent-red); padding: 3px 8px; border-radius: 5px; font-size: 10px; font-weight: 800; display:inline-block; }
        .result-void { background: rgba(107,114,128,0.2); color: #9ca3af; padding: 3px 8px; border-radius: 5px; font-size: 10px; font-weight: 800; display:inline-block; }
        .result-pending { background: rgba(245,158,11,0.12); color: var(--accent-yellow); padding: 3px 8px; border-radius: 5px; font-size: 10px; font-weight: 700; display:inline-block; }
        .game-detail-mini { margin-top:3px; font-size:9px; color:var(--text-muted); line-height:1.5; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; }
        .score-inline { font-family:'JetBrains Mono',monospace; font-weight:900; font-size:14px; color:var(--accent-yellow); background:rgba(245,158,11,0.12); padding:1px 6px; border-radius:4px; margin:0 2px; }

        /* ── GAME STATUS BADGES ── */
        .game-live {
            background: linear-gradient(135deg, rgba(239,68,68,0.25), rgba(239,68,68,0.10));
            color: #ff6b6b; padding: 2px 7px; border-radius: 4px; font-size: 9px;
            font-weight: 800; display: inline-block; letter-spacing: 0.5px;
            animation: livePulse 2s infinite; border: 1px solid rgba(239,68,68,0.35);
        }
        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.65; }
        }
        .game-finished {
            background: rgba(107,114,128,0.15); color: #9ca3af; padding: 2px 7px;
            border-radius: 4px; font-size: 9px; font-weight: 700; display: inline-block;
        }
        .game-upcoming {
            background: rgba(59,130,246,0.12); color: var(--accent-blue); padding: 2px 7px;
            border-radius: 4px; font-size: 9px; font-weight: 700; display: inline-block;
        }

        /* ── ROW HIGHLIGHTS BY GAME STATUS ── */
        tr.row-live { background: rgba(239,68,68,0.04) !important; }
        tr.row-live:hover { background: rgba(239,68,68,0.08) !important; }
        tr.row-finished { opacity: 0.85; }
        tr.row-green { background: rgba(0,230,138,0.03) !important; }
        tr.row-green:hover { background: rgba(0,230,138,0.07) !important; }
        tr.row-red { background: rgba(239,68,68,0.03) !important; }
        tr.row-red:hover { background: rgba(239,68,68,0.07) !important; }

        /* ── DATE PICKER ── */
        .date-picker-group {
            display: flex; align-items: center; gap: 8px;
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: 8px; padding: 4px 12px;
        }
        .date-picker-group label { font-size: 11px; color: var(--text-muted); font-weight: 600; }
        .date-picker-group input[type="date"],
        .date-picker-group input[type="datetime-local"] {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 5px; color: var(--text-primary); font-size: 12px;
            padding: 4px 8px; font-family: 'JetBrains Mono', monospace;
        }
        .date-picker-group input[type="date"]:focus,
        .date-picker-group input[type="datetime-local"]:focus { border-color: var(--accent-green); outline: none; }
        .date-picker-group.loading { border-color: var(--accent-yellow); animation: pulse-border 1s infinite; }
        @keyframes pulse-border { 0%,100% { border-color: var(--accent-yellow); } 50% { border-color: var(--border); } }

        /* Column datetime range filter */
        .col-filter-datetime {
            display: flex; flex-direction: column; gap: 2px; min-width: 135px;
        }
        .col-filter-datetime input[type="datetime-local"] {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 4px; color: var(--text-primary); font-size: 10px;
            padding: 2px 4px; font-family: 'JetBrains Mono', monospace;
            width: 100%;
        }
        .col-filter-datetime input[type="datetime-local"]:focus {
            border-color: var(--accent-green); outline: none;
        }
        .col-filter-datetime label {
            font-size: 8px; color: var(--text-muted); font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase;
        }

        .btn-check-results {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; color: #fff;
            padding: 8px 16px; border-radius: 8px; font-size: 12px;
            font-weight: 700; cursor: pointer; transition: all 0.2s;
            font-family: 'Inter', sans-serif; min-width: 120px; text-align: center;
            line-height: 1.3;
        }
        .btn-check-results:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(139,92,246,0.4); }
        .btn-check-results:disabled { opacity: 0.7; cursor: wait; transform: none;
            animation: btnPulse 1.5s infinite; }
        @keyframes btnPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139,92,246,0.4); }
            50% { box-shadow: 0 0 0 8px rgba(139,92,246,0); }
        }

        /* ═══════════════════════════════════════════════════
           DASHBOARD — COMPLETE REDESIGN
           ═══════════════════════════════════════════════════ */

        /* Filter bar */
        .dash-filter-bar {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px 20px;
            margin-bottom: 24px;
        }
        .dash-filter-row {
            display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-end;
        }
        .dash-filter-group {
            display: flex; flex-direction: column; gap: 3px;
        }
        .dash-filter-group label {
            font-size: 10px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .dash-filter-group input,
        .dash-filter-group select {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 6px; color: var(--text-primary); font-size: 12px;
            padding: 6px 8px; min-width: 100px; outline: none;
            font-family: 'Inter', sans-serif;
        }
        .dash-filter-group input:focus,
        .dash-filter-group select:focus { border-color: var(--accent-green); }
        .dash-filter-group input[type="number"] { width: 70px; min-width: 70px; }
        .dash-filter-group input[type="date"] { width: 130px; }
        .btn-clear-dash {
            background: rgba(255,255,255,0.06); border: 1px solid var(--border);
            color: var(--text-secondary); font-size: 11px; font-weight: 600;
            padding: 6px 14px; border-radius: 6px; cursor: pointer;
            transition: all 0.15s;
        }
        .btn-clear-dash:hover { background: rgba(239,68,68,0.15); border-color: var(--accent-red); color: var(--accent-red); }
        .dash-filter-summary {
            margin-top: 8px; font-size: 11px; color: var(--text-muted);
            display: none;
        }
        .dash-filter-summary.active { display: block; }

        /* Hero KPI cards */
        .dash-kpi-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px;
            margin-bottom: 20px;
        }
        @media (max-width: 1200px) { .dash-kpi-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 700px) { .dash-kpi-grid { grid-template-columns: repeat(2, 1fr); } }
        .dash-kpi {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 18px 16px;
            position: relative; overflow: hidden;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .dash-kpi:hover { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(0,0,0,0.25); }
        .dash-kpi-label {
            font-size: 10px; text-transform: uppercase; letter-spacing: 0.8px;
            color: var(--text-muted); font-weight: 700; margin-bottom: 6px;
        }
        .dash-kpi-val {
            font-size: 28px; font-weight: 900; font-family: 'JetBrains Mono', monospace;
            line-height: 1.1;
        }
        .dash-kpi-sub { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
        .dash-kpi-icon {
            position: absolute; top: 14px; right: 14px; font-size: 28px; opacity: 0.12;
        }
        .dash-kpi.kpi-green { border-top: 3px solid var(--accent-green); }
        .dash-kpi.kpi-red { border-top: 3px solid var(--accent-red); }
        .dash-kpi.kpi-blue { border-top: 3px solid var(--accent-blue); }
        .dash-kpi.kpi-yellow { border-top: 3px solid var(--accent-yellow); }
        .dash-kpi.kpi-purple { border-top: 3px solid var(--accent-purple); }

        /* Main two-column layout */
        .dash-main-row {
            display: grid; grid-template-columns: 340px 1fr; gap: 16px;
            margin-bottom: 20px;
        }
        @media (max-width: 1000px) { .dash-main-row { grid-template-columns: 1fr; } }

        /* Donut section */
        .dash-donut-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 24px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .dash-donut-svg { width: 180px; height: 180px; }
        .dash-donut-center {
            font-size: 26px; font-weight: 900; font-family: 'JetBrains Mono', monospace;
        }
        .dash-donut-legend-row {
            display: flex; gap: 20px; margin-top: 16px; font-size: 13px;
        }
        .dash-donut-legend-item {
            display: flex; align-items: center; gap: 6px;
        }
        .dash-legend-dot {
            width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
        }

        /* Chart area */
        .dash-chart {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px;
        }
        .dash-chart-title {
            font-size: 12px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;
        }
        .dash-chart-svg { width: 100%; height: 200px; display: block; }
        .dash-chart-footer {
            display: flex; justify-content: space-between; padding-top: 6px;
            font-size: 11px; color: var(--text-muted);
        }

        /* Breakdown grid */
        .dash-grid-2 {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;
            margin-bottom: 16px;
        }
        .dash-grid-3 {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;
            margin-bottom: 16px;
        }
        @media (max-width: 1200px) { .dash-grid-3 { grid-template-columns: 1fr; } }
        @media (max-width: 1000px) { .dash-grid-2 { grid-template-columns: 1fr; } }

        /* Breakdown card */
        .dash-bd-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); overflow: hidden;
        }
        .dash-bd-header {
            padding: 14px 18px 10px; border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
        }
        .dash-bd-title {
            font-size: 13px; font-weight: 700; color: var(--text-primary);
        }
        .dash-bd-count {
            font-size: 10px; background: rgba(255,255,255,0.06); padding: 2px 8px;
            border-radius: 10px; color: var(--text-muted); font-weight: 600;
        }
        .dash-bd-scroll {
            max-height: 350px; overflow-y: auto;
        }
        .dash-bd-scroll::-webkit-scrollbar { width: 3px; }
        .dash-bd-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        /* Breakdown row item */
        .dash-bd-row {
            display: grid; grid-template-columns: 1fr 50px 50px 80px 70px 60px;
            align-items: center; padding: 8px 18px; gap: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.025);
            font-size: 12px; transition: background 0.1s;
        }
        .dash-bd-row:hover { background: rgba(255,255,255,0.03); }
        .dash-bd-row:last-child { border-bottom: none; }
        .dash-bd-row-name {
            font-weight: 600; white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; color: var(--text-primary);
        }
        .dash-bd-row-g { text-align: center; color: var(--accent-green); font-weight: 700; }
        .dash-bd-row-r { text-align: center; color: var(--accent-red); font-weight: 700; }
        .dash-bd-row-hr { display: flex; align-items: center; gap: 4px; }
        .dash-bd-minibar {
            flex: 1; height: 6px; background: rgba(255,255,255,0.05);
            border-radius: 3px; overflow: hidden;
        }
        .dash-bd-minibar-fill { height: 100%; border-radius: 3px; }
        .dash-bd-row-hr-pct {
            font-size: 11px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
            min-width: 36px; text-align: right;
        }
        .dash-bd-row-pnl {
            text-align: right; font-weight: 800; font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
        .dash-bd-row-roi {
            text-align: right; font-weight: 700; font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
        .dash-bd-head {
            display: grid; grid-template-columns: 1fr 50px 50px 80px 70px 60px;
            padding: 8px 18px; gap: 4px; font-size: 9px; text-transform: uppercase;
            letter-spacing: 0.5px; color: var(--text-muted); font-weight: 700;
            border-bottom: 2px solid var(--border); background: var(--bg-card);
            position: sticky; top: 0; z-index: 1;
        }
        .dash-bd-head > div:nth-child(n+2) { text-align: center; }
        .dash-bd-head > div:nth-child(5) { text-align: right; }
        .dash-bd-head > div:nth-child(6) { text-align: right; }

        /* ── COMBO ANALYZER ── */
        .combo-analyzer {
            margin-top: 32px;
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            background: linear-gradient(135deg, rgba(139,92,246,0.04), rgba(6,182,212,0.04));
            overflow: hidden;
        }
        .combo-analyzer-header {
            padding: 20px 24px 16px;
            border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px;
        }
        .combo-analyzer-title {
            font-size: 16px; font-weight: 800; color: var(--text-primary);
            display: flex; align-items: center; gap: 8px;
        }
        .combo-analyzer-title .ca-icon {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-size: 22px;
        }
        .combo-analyzer-controls {
            display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
        }
        .ca-ctrl {
            display: flex; align-items: center; gap: 5px; font-size: 11px; color: var(--text-secondary);
        }
        .ca-ctrl label { font-weight: 600; white-space: nowrap; }
        .ca-ctrl select, .ca-ctrl input[type="number"] {
            background: var(--bg-card); border: 1px solid var(--border); border-radius: 6px;
            color: var(--text-primary); font-size: 11px; padding: 5px 8px; outline: none;
            font-family: 'JetBrains Mono', monospace;
        }
        .ca-ctrl select:focus, .ca-ctrl input:focus { border-color: var(--accent-purple); }
        .ca-ctrl select { min-width: 100px; cursor: pointer; }
        .ca-ctrl input[type="number"] { width: 55px; }
        .ca-depth-btns {
            display: flex; gap: 2px;
        }
        .ca-depth-btn {
            padding: 4px 10px; font-size: 10px; font-weight: 700; border: 1px solid var(--border);
            background: var(--bg-card); color: var(--text-muted); border-radius: 4px;
            cursor: pointer; transition: all 0.15s;
        }
        .ca-depth-btn:hover { border-color: var(--accent-purple); color: var(--text-primary); }
        .ca-depth-btn.active {
            background: linear-gradient(135deg, rgba(139,92,246,0.3), rgba(6,182,212,0.2));
            border-color: var(--accent-purple); color: #fff; font-weight: 800;
        }
        .combo-analyzer-body {
            padding: 16px 20px 20px;
        }
        .ca-summary-bar {
            display: flex; gap: 16px; margin-bottom: 16px; flex-wrap: wrap;
        }
        .ca-summary-chip {
            font-size: 11px; padding: 5px 12px; border-radius: 20px;
            background: rgba(255,255,255,0.04); border: 1px solid var(--border);
            color: var(--text-secondary); display: flex; align-items: center; gap: 5px;
        }
        .ca-summary-chip strong { color: var(--text-primary); font-family: 'JetBrains Mono', monospace; }
        .ca-cards-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); gap: 12px;
        }
        .ca-card {
            background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius);
            padding: 16px 18px; transition: all 0.2s; position: relative; overflow: hidden;
        }
        .ca-card:hover { border-color: var(--accent-purple); box-shadow: 0 0 20px rgba(139,92,246,0.08); }
        .ca-card-rank {
            position: absolute; top: 0; right: 0;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
            color: #fff; font-size: 11px; font-weight: 800; padding: 4px 12px 4px 14px;
            border-radius: 0 0 0 12px; font-family: 'JetBrains Mono', monospace;
        }
        .ca-card-rank.gold { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .ca-card-rank.silver { background: linear-gradient(135deg, #94a3b8, #64748b); }
        .ca-card-rank.bronze { background: linear-gradient(135deg, #d97706, #92400e); }
        .ca-card-name {
            font-size: 13px; font-weight: 700; color: var(--text-primary);
            margin-bottom: 4px; padding-right: 45px;
            display: flex; flex-wrap: wrap; gap: 5px; align-items: center;
        }
        .ca-dim-tag {
            display: inline-flex; align-items: center; gap: 3px;
            padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 700;
        }
        .ca-dim-tag.dim-market { background: rgba(59,130,246,0.15); color: #60a5fa; }
        .ca-dim-tag.dim-selection { background: rgba(139,92,246,0.15); color: #a78bfa; }
        .ca-dim-tag.dim-confidence { background: rgba(245,158,11,0.15); color: #fbbf24; }
        .ca-dim-tag.dim-edge { background: rgba(0,230,138,0.15); color: var(--accent-green); }
        .ca-dim-tag.dim-odds { background: rgba(6,182,212,0.15); color: #22d3ee; }
        .ca-dim-tag.dim-country { background: rgba(239,68,68,0.12); color: #f87171; }
        .ca-dim-tag.dim-league { background: rgba(167,139,250,0.12); color: #c4b5fd; }
        .ca-dim-tag.dim-analysis { background: rgba(34,211,238,0.12); color: #67e8f9; }
        .ca-dim-tag.dim-time { background: rgba(251,191,36,0.12); color: #fcd34d; }
        .ca-card-score {
            display: flex; align-items: center; gap: 6px; margin: 8px 0 10px;
        }
        .ca-score-bar {
            flex: 1; height: 8px; background: rgba(255,255,255,0.06); border-radius: 4px; overflow: hidden;
        }
        .ca-score-fill {
            height: 100%; border-radius: 4px;
            background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan));
            transition: width 0.4s ease;
        }
        .ca-score-val {
            font-size: 13px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
            color: var(--accent-purple); min-width: 32px; text-align: right;
        }
        .ca-card-metrics {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 10px;
        }
        .ca-metric {
            text-align: center; padding: 6px 4px;
            background: rgba(255,255,255,0.02); border-radius: 6px;
        }
        .ca-metric-label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; font-weight: 600; letter-spacing: 0.3px; }
        .ca-metric-val {
            font-size: 14px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
            margin-top: 2px;
        }
        .ca-card-actions {
            display: flex; gap: 6px; margin-top: 8px;
        }
        .ca-btn {
            flex: 1; padding: 6px 10px; border-radius: 6px; font-size: 10px; font-weight: 700;
            border: 1px solid var(--border); cursor: pointer; text-align: center; transition: all 0.15s;
        }
        .ca-btn-apply {
            background: linear-gradient(135deg, rgba(139,92,246,0.2), rgba(6,182,212,0.15));
            color: var(--accent-purple); border-color: rgba(139,92,246,0.4);
        }
        .ca-btn-apply:hover { background: linear-gradient(135deg, rgba(139,92,246,0.4), rgba(6,182,212,0.3)); color: #fff; }
        .ca-btn-save {
            background: rgba(0,230,138,0.08); color: var(--accent-green); border-color: rgba(0,230,138,0.3);
        }
        .ca-btn-save:hover { background: rgba(0,230,138,0.2); color: #fff; }
        .ca-empty {
            text-align: center; padding: 40px 20px; color: var(--text-muted);
        }
        .ca-empty-icon { font-size: 36px; margin-bottom: 12px; }

        /* Variable mode toggles */
        .ca-vars-panel {
            margin-bottom: 16px; padding: 12px 14px;
            background: rgba(255,255,255,0.02); border: 1px solid var(--border);
            border-radius: var(--radius);
        }
        .ca-vars-title {
            font-size: 11px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px;
            display: flex; align-items: center; gap: 6px;
        }
        .ca-vars-title .ca-vars-legend {
            font-weight: 400; text-transform: none; letter-spacing: 0; font-size: 10px;
            margin-left: auto; display: flex; gap: 10px;
        }
        .ca-vars-legend span { display: inline-flex; align-items: center; gap: 3px; }
        .ca-vars-grid {
            display: flex; flex-wrap: wrap; gap: 6px;
        }
        .ca-var-chip {
            display: flex; align-items: center; gap: 0; border-radius: 6px; overflow: hidden;
            border: 1px solid var(--border); transition: all 0.15s; font-size: 10px;
        }
        .ca-var-chip-label {
            padding: 5px 10px; font-weight: 600; color: var(--text-primary);
            background: var(--bg-card); white-space: nowrap;
        }
        .ca-var-chip-btns { display: flex; }
        .ca-var-btn {
            padding: 5px 7px; border: none; cursor: pointer; font-size: 9px;
            font-weight: 700; transition: all 0.15s; line-height: 1;
            background: var(--bg-secondary); color: var(--text-muted);
            border-left: 1px solid var(--border);
        }
        .ca-var-btn:hover { color: var(--text-primary); }
        .ca-var-btn.vmode-auto.active {
            background: rgba(59,130,246,0.2); color: var(--accent-blue); font-weight: 800;
        }
        .ca-var-btn.vmode-force.active {
            background: rgba(0,230,138,0.2); color: var(--accent-green); font-weight: 800;
        }
        .ca-var-btn.vmode-exclude.active {
            background: rgba(239,68,68,0.2); color: var(--accent-red); font-weight: 800;
        }
        .ca-var-chip.state-exclude {
            opacity: 0.45; border-color: rgba(239,68,68,0.3);
        }
        .ca-var-chip.state-exclude .ca-var-chip-label {
            text-decoration: line-through; color: var(--text-muted);
        }
        .ca-var-chip.state-force {
            border-color: rgba(0,230,138,0.4);
            box-shadow: 0 0 8px rgba(0,230,138,0.08);
        }
        .ca-var-chip.state-force .ca-var-chip-label {
            color: var(--accent-green);
        }
        .ca-heatmap {
            margin-top: 20px;
        }
        .ca-heatmap-title {
            font-size: 12px; font-weight: 700; color: var(--text-muted); text-transform: uppercase;
            letter-spacing: 0.5px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
        }
        .ca-heatmap-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 6px;
        }
        .ca-heat-cell {
            padding: 10px 8px; border-radius: 8px; text-align: center; cursor: pointer;
            border: 1px solid transparent; transition: all 0.2s; position: relative;
        }
        .ca-heat-cell:hover { transform: scale(1.03); box-shadow: 0 4px 12px rgba(0,0,0,0.3); border-color: rgba(255,255,255,0.1); }
        .ca-heat-cell-name { font-size: 10px; font-weight: 600; color: rgba(255,255,255,0.85); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .ca-heat-cell-val { font-size: 15px; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-top: 3px; }
        .ca-heat-cell-sub { font-size: 9px; color: rgba(255,255,255,0.5); margin-top: 2px; }

        /* Utility */
        .txt-green { color: var(--accent-green); }
        .txt-red { color: var(--accent-red); }
        .txt-yellow { color: var(--accent-yellow); }
        .txt-muted { color: var(--text-muted); }
        
        /* Profit / Loss styling */
        .profit-positive { color: var(--accent-green); font-weight: 800; }
        .profit-negative { color: var(--accent-red); font-weight: 800; }
        .roi-positive { color: var(--accent-green); }
        .roi-negative { color: var(--accent-red); }
        
        /* Old compat hit-rate-bar */
        .hit-rate-bar {
            display: inline-block; width: 50px; height: 6px; background: var(--border);
            border-radius: 3px; overflow: hidden; vertical-align: middle; margin-left: 6px;
        }
        .hit-rate-bar-fill { height: 100%; border-radius: 3px; }
        
        /* PnL badge */
        .pnl-badge {
            display: inline-block; padding: 2px 8px; border-radius: 6px;
            font-size: 12px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
        }
        .pnl-badge.positive { background: rgba(0,230,118,0.12); color: var(--accent-green); }
        .pnl-badge.negative { background: rgba(255,82,82,0.12); color: var(--accent-red); }
        .pnl-badge.neutral { background: rgba(255,255,255,0.06); color: var(--text-muted); }

        /* ── SORTABLE TABLE HEADERS ── */
        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            white-space: nowrap;
            transition: background 0.15s;
        }
        th.sortable:hover {
            background: rgba(0, 230, 118, 0.08);
        }
        th.sortable::after {
            content: '⇅';
            margin-left: 4px;
            font-size: 10px;
            opacity: 0.3;
        }
        th.sortable.sort-asc::after {
            content: '▲';
            opacity: 0.9;
            color: var(--accent-green);
        }
        th.sortable.sort-desc::after {
            content: '▼';
            opacity: 0.9;
            color: var(--accent-green);
        }

        /* ── COLUMN FILTERS ── */
        .col-filter-row th {
            padding: 4px 3px;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border);
        }
        .col-filter {
            width: 100%;
            box-sizing: border-box;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 10px;
            padding: 3px 4px;
            outline: none;
        }
        .col-filter:focus {
            border-color: var(--accent-green);
        }
        .col-filter::placeholder {
            color: var(--text-muted);
            font-size: 9px;
        }
        select.col-filter {
            font-size: 10px;
            padding: 3px 2px;
        }
        .col-filter-num {
            width: 100%;
            display: flex;
            gap: 2px;
        }
        .col-filter-num input {
            width: 50%;
            box-sizing: border-box;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 9px;
            padding: 3px 3px;
            outline: none;
        }
        .col-filter-num input:focus {
            border-color: var(--accent-green);
        }
        .col-filter-num input::placeholder {
            color: var(--text-muted);
            font-size: 8px;
        }

        /* ── MULTI-SELECT DROPDOWN ── */
        .ms-wrap { position:relative; width:100%; }
        .ms-trigger {
            width:100%; box-sizing:border-box; background:var(--bg-card); border:1px solid var(--border);
            border-radius:4px; color:var(--text-primary); font-size:10px; padding:3px 18px 3px 4px;
            cursor:pointer; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-height:22px;
            display:flex; align-items:center; user-select:none; position:relative;
        }
        .ms-trigger::after { content:'▾'; position:absolute; right:4px; top:50%; transform:translateY(-50%); font-size:8px; color:var(--text-muted); pointer-events:none; }
        .ms-trigger.ms-active { border-color:var(--accent-green); }
        .ms-trigger .ms-placeholder { color:var(--text-muted); }
        .ms-trigger .ms-count { background:var(--accent-green); color:#000; font-size:8px; font-weight:800; padding:1px 5px; border-radius:8px; margin-right:4px; flex-shrink:0; }
        .ms-dropdown {
            display:none; position:absolute; top:100%; left:0; right:0; z-index:999;
            background:var(--bg-card); border:1px solid var(--accent-green); border-radius:6px;
            box-shadow:0 8px 24px rgba(0,0,0,0.5); max-height:260px; overflow:hidden;
            flex-direction:column; min-width:180px;
        }
        .ms-dropdown.ms-open { display:flex; }
        .ms-search-wrap { padding:4px; border-bottom:1px solid var(--border); }
        .ms-search {
            width:100%; box-sizing:border-box; background:var(--bg-secondary); border:1px solid var(--border);
            border-radius:4px; color:var(--text-primary); font-size:10px; padding:4px 6px; outline:none;
        }
        .ms-search:focus { border-color:var(--accent-green); }
        .ms-search::placeholder { color:var(--text-muted); font-size:9px; }
        .ms-actions { display:flex; gap:2px; padding:3px 4px; border-bottom:1px solid var(--border); }
        .ms-actions button {
            flex:1; background:var(--bg-secondary); border:1px solid var(--border); border-radius:3px;
            color:var(--text-secondary); font-size:8px; padding:2px 0; cursor:pointer; transition:all .15s;
        }
        .ms-actions button:hover { background:var(--accent-green); color:#000; border-color:var(--accent-green); }
        .ms-list { overflow-y:auto; max-height:200px; padding:2px 0; }
        .ms-item {
            display:flex; align-items:center; gap:6px; padding:3px 8px; cursor:pointer;
            font-size:10px; color:var(--text-secondary); transition:background .1s;
        }
        .ms-item:hover { background:rgba(16,185,129,0.08); }
        .ms-item.ms-selected { color:var(--text-primary); font-weight:600; }
        .ms-item .ms-check {
            width:13px; height:13px; border:1.5px solid var(--border); border-radius:3px;
            display:flex; align-items:center; justify-content:center; flex-shrink:0;
            font-size:9px; transition:all .15s;
        }
        .ms-item.ms-selected .ms-check { background:var(--accent-green); border-color:var(--accent-green); color:#000; }
        .ms-item .ms-label { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .ms-empty { padding:8px; text-align:center; font-size:10px; color:var(--text-muted); }
        /* Dashboard multi-select wider */
        .dash-filter-group .ms-wrap { min-width:120px; }
        .dash-filter-group .ms-trigger { font-size:11px; padding:6px 20px 6px 8px; min-height:32px; }
        .dash-filter-group .ms-dropdown { min-width:200px; }
        .dash-filter-group .ms-search { font-size:11px; padding:5px 8px; }
        .dash-filter-group .ms-item { font-size:11px; padding:4px 10px; }

        /* ── DETAIL MODAL ── */
        .modal-overlay {
            position: fixed; inset: 0; z-index: 1000;
            background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
            display: none; align-items: flex-start; justify-content: center;
            padding: 20px 10px;
            overflow-y: auto;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); width: 98%; max-width: 1400px;
            max-height: none; box-shadow: 0 25px 60px rgba(0,0,0,0.6);
            margin: auto;
        }
        .modal-header {
            padding: 20px 24px; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-card) 100%);
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }
        .modal-header h2 { font-size: 18px; font-weight: 700; }
        .modal-header .subtitle { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
        .modal-header .close {
            background: none; border: none; color: var(--text-muted);
            font-size: 24px; cursor: pointer; padding: 4px 8px; line-height: 1;
        }
        .modal-header .close:hover { color: var(--text-primary); }
        .modal-body { padding: 24px; }
        .detail-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;
        }
        .detail-item { }
        .detail-label { font-size: 11px; text-transform: uppercase; color: var(--text-muted); font-weight: 600; margin-bottom: 4px; letter-spacing: 0.5px; }
        .detail-value { font-size: 15px; font-weight: 600; }
        .detail-reasoning {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: var(--radius-sm); padding: 16px; margin-top: 16px;
            font-size: 13px; line-height: 1.7; color: var(--text-secondary);
        }
        .detail-reasoning strong { color: var(--text-primary); }

        /* ── MODAL TABS ── */
        .modal-tabs {
            display: flex; gap: 0; border-bottom: 2px solid var(--border);
            margin-bottom: 20px; overflow-x: auto;
        }
        .modal-tab {
            padding: 10px 18px; font-size: 12px; font-weight: 600;
            color: var(--text-muted); cursor: pointer; border: none;
            background: transparent; border-bottom: 2px solid transparent;
            margin-bottom: -2px; white-space: nowrap; transition: all 0.2s;
            font-family: 'Inter', sans-serif; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .modal-tab:hover { color: var(--text-primary); background: rgba(255,255,255,0.02); }
        .modal-tab.active { color: var(--accent-green); border-bottom-color: var(--accent-green); }
        .modal-tab-content { display: none; }
        .modal-tab-content.active { display: block; }

        /* ── TEAM COMPARISON ── */
        .team-compare {
            display: grid; grid-template-columns: 1fr auto 1fr; gap: 0;
            margin-bottom: 20px;
        }
        .team-col { padding: 16px; }
        .team-col-home { text-align: right; }
        .team-col-away { text-align: left; }
        .team-col-vs {
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: 700; color: var(--text-muted);
            padding: 0 12px; min-width: 40px;
        }
        .team-name-lg {
            font-size: 18px; font-weight: 800; margin-bottom: 4px;
        }
        .team-badge-info {
            font-size: 11px; color: var(--text-muted); margin-bottom: 12px;
        }

        /* ── STAT ROW (H2H bar) ── */
        .stat-row {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0;
            padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
            align-items: center;
        }
        .stat-row:last-child { border-bottom: none; }
        .stat-row-val { font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; }
        .stat-row-val.home { text-align: right; padding-right: 12px; }
        .stat-row-val.away { text-align: left; padding-left: 12px; }
        .stat-row-label {
            text-align: center; font-size: 10px; text-transform: uppercase;
            color: var(--text-muted); letter-spacing: 0.8px; font-weight: 600;
        }
        .stat-bar-wrap {
            display: flex; height: 6px; border-radius: 3px; overflow: hidden;
            background: var(--border); margin-top: 4px;
        }
        .stat-bar-home {
            background: var(--accent-green); border-radius: 3px 0 0 3px; transition: width 0.6s ease;
        }
        .stat-bar-away {
            background: var(--accent-blue); border-radius: 0 3px 3px 0; transition: width 0.6s ease;
        }

        /* ── ODDS GRID ── */
        .odds-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px; margin-bottom: 16px;
        }
        .odds-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 12px; text-align: center;
        }
        .odds-card-label {
            font-size: 10px; text-transform: uppercase; color: var(--text-muted);
            font-weight: 600; letter-spacing: 0.5px; margin-bottom: 6px;
        }
        .odds-card-value {
            font-family: 'JetBrains Mono', monospace; font-size: 18px;
            font-weight: 800; color: var(--accent-yellow);
        }
        .odds-card-prob {
            font-size: 11px; color: var(--text-secondary); margin-top: 2px;
        }

        /* ── CONTEXT CARDS ── */
        .ctx-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;
        }
        .ctx-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 14px;
        }
        .ctx-card-title {
            font-size: 11px; font-weight: 700; text-transform: uppercase;
            color: var(--text-muted); letter-spacing: 0.5px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 6px;
        }
        .ctx-card-body { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }

        /* ── SECTION TITLE inside modal ── */
        .m-section {
            font-size: 13px; font-weight: 700; color: var(--text-primary);
            text-transform: uppercase; letter-spacing: 0.8px;
            margin: 20px 0 12px; padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
            display: flex; align-items: center; gap: 8px;
        }
        .m-section:first-child { margin-top: 0; }

        .form-dots { display: flex; gap: 3px; }
        .form-dot {
            width: 18px; height: 18px; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 9px; font-weight: 800;
        }
        .form-W { background: var(--accent-green-dim); color: var(--accent-green); }
        .form-D { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .form-L { background: var(--accent-red-dim); color: var(--accent-red); }

        /* ── LEAGUE CARDS ── */
        .league-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }
        .league-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px; cursor: default;
            transition: all 0.2s;
        }
        .league-card:hover { border-color: var(--border-light); transform: translateY(-2px); box-shadow: var(--shadow-card); }
        .league-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .league-card-name { font-weight: 700; font-size: 15px; }
        .league-card-country { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        .league-card-stats { display: flex; gap: 16px; }
        .league-card-stat { text-align: center; }
        .league-card-stat .num { font-size: 22px; font-weight: 800; }
        .league-card-stat .lbl { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }

        /* ── FILTER BAR ── */
        .filter-bar {
            display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;
        }
        .filter-select {
            background: var(--bg-card); border: 1px solid var(--border);
            color: var(--text-primary); padding: 8px 14px; border-radius: var(--radius-sm);
            font-size: 13px; font-family: 'Inter', sans-serif; cursor: pointer;
        }
        .filter-select:focus { outline: none; border-color: var(--accent-green); }
        .filter-input {
            background: var(--bg-card); border: 1px solid var(--border);
            color: var(--text-primary); padding: 8px 14px; border-radius: var(--radius-sm);
            font-size: 13px; font-family: 'Inter', sans-serif; width: 200px;
        }
        .filter-input::placeholder { color: var(--text-muted); }
        .filter-input:focus { outline: none; border-color: var(--accent-green); }

        /* ── RESPONSIVE ── */
        @media (max-width: 768px) {
            header { padding: 12px 16px; flex-wrap: wrap; gap: 12px; }
            main { padding: 16px; }
            .stats-row { grid-template-columns: repeat(2, 1fr); }
            .detail-grid { grid-template-columns: 1fr; }
            .tabs { overflow-x: auto; width: 100%; }
            .filter-bar { flex-direction: column; }
            .welcome-info { flex-direction: column; align-items: center; }
            .header-right { flex-wrap: wrap; }
        }
        .btn-export {
            background: linear-gradient(135deg, #059669, #10b981);
            color: #fff;
            border: none;
            padding: 5px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-export:hover { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(16,185,129,0.3); }
        .btn-export:disabled { opacity: 0.6; cursor: wait; }

        /* ── FILTER VIEWS ── */
        .filter-views-bar {
            display: flex; gap: 6px; align-items: center; flex-wrap: wrap;
            padding: 8px 0;
        }
        .filter-views-bar .fv-label {
            font-size: 11px; color: var(--text-muted); font-weight: 600;
            white-space: nowrap; margin-right: 4px;
        }
        .fv-chip {
            display: inline-flex; align-items: center; gap: 5px;
            background: var(--bg-card); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 4px 10px; border-radius: 16px;
            font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            white-space: nowrap;
        }
        .fv-chip:hover { border-color: var(--accent-green); color: var(--text-primary); }
        .fv-chip.fv-active { background: var(--accent-green-dim); border-color: var(--accent-green); color: var(--accent-green); }
        .fv-chip .fv-delete {
            width: 14px; height: 14px; border-radius: 50%; display: inline-flex;
            align-items: center; justify-content: center; font-size: 9px;
            background: rgba(239,68,68,0.15); color: var(--accent-red);
            opacity: 0; transition: opacity 0.15s; cursor: pointer;
        }
        .fv-chip:hover .fv-delete { opacity: 1; }
        .fv-chip .fv-delete:hover { background: var(--accent-red); color: #fff; }
        .fv-btn-save {
            display: inline-flex; align-items: center; gap: 4px;
            background: var(--accent-blue-dim); border: 1px solid rgba(59,130,246,0.3);
            color: var(--accent-blue); padding: 4px 10px; border-radius: 16px;
            font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            white-space: nowrap;
        }
        .fv-btn-save:hover { border-color: var(--accent-blue); background: rgba(59,130,246,0.25); }
        .fv-save-modal {
            position: fixed; inset: 0; z-index: 10000; background: rgba(10,14,23,0.85);
            backdrop-filter: blur(6px); display: none; align-items: center; justify-content: center;
        }
        .fv-save-modal.show { display: flex; }
        .fv-save-modal-box {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 24px; width: 380px; max-width: 90vw;
        }
        .fv-save-modal-box h3 { font-size: 16px; font-weight: 700; margin-bottom: 16px; }
        .fv-save-modal-box input {
            width: 100%; background: var(--bg-secondary); border: 1px solid var(--border);
            color: var(--text-primary); padding: 10px 14px; border-radius: var(--radius-sm);
            font-size: 14px; font-family: 'Inter', sans-serif; margin-bottom: 16px;
        }
        .fv-save-modal-box input:focus { border-color: var(--accent-green); outline: none; }
        .fv-save-modal-box .fv-btns { display: flex; gap: 8px; justify-content: flex-end; }
        .fv-save-modal-box .fv-btns button {
            padding: 8px 18px; border-radius: 8px; font-size: 13px; font-weight: 600;
            cursor: pointer; border: none; font-family: 'Inter', sans-serif; transition: all 0.15s;
        }
        .fv-save-modal-box .fv-btn-cancel { background: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border); }
        .fv-save-modal-box .fv-btn-cancel:hover { background: var(--border); color: var(--text-primary); }
        .fv-save-modal-box .fv-btn-confirm { background: var(--gradient-green); color: #000; font-weight: 700; }
        .fv-save-modal-box .fv-btn-confirm:hover { transform: translateY(-1px); }
    </style>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
</head>
<body>

<!-- PROGRESS OVERLAY (só aparece durante execução) -->
<div class="progress-overlay" id="progress-overlay">
    <div class="progress-icon">⚽</div>
    <div class="progress-title">Executando Pipeline de Análise</div>
    <div class="progress-sub">Buscando dados, modelando probabilidades, identificando valor...</div>
    <div class="progress-bar-bg"><div class="progress-bar"></div></div>
    <div class="progress-phase" id="progress-phase">Conectando à API-Football...</div>
    <div class="progress-timer" id="progress-timer">00:00</div>
</div>

<!-- HEADER -->
<header>
    <div class="logo">
        <div class="logo-icon">⚽</div>
        <div>
            <h1>Apostas<span>IA</span></h1>
        </div>
    </div>
    <div class="header-right">
        <div class="date-picker-group">
            <label>De:</label>
            <input type="date" id="date-start" title="Data início da análise">
            <label>Até:</label>
            <input type="date" id="date-end" title="Data fim da análise">
            <button id="btn-load-dates" onclick="_triggerDateLoad(true)" title="Buscar dados" style="background:var(--accent-green);color:#fff;border:none;border-radius:6px;padding:4px 10px;cursor:pointer;font-size:13px;font-weight:600">🔍</button>
        </div>
        <div class="api-quota" id="api-quota">
            <span>API:</span>
            <div class="api-quota-bar"><div class="api-quota-fill" id="api-quota-fill" style="width:0%;background:var(--accent-green)"></div></div>
            <span id="api-quota-text">--/--</span>
        </div>
        <div class="header-badge" id="badge-status">● Aguardando</div>
        <button class="btn-run" id="btn-run" onclick="executeEngine()">▶ Executar</button>
        <button class="btn-recalc" id="btn-recalc" onclick="recalculateEngine()" title="Recalcular modelos usando dados já em cache (0 API calls)">🔄 Recalc</button>
        <button class="btn-check-results" id="btn-check-results" onclick="checkResults()" title="Verificar resultados de jogos finalizados">✅ Resultados</button>
    </div>
</header>

<!-- MAIN -->
<main>
    <!-- WELCOME STATE (quando não há dados) -->
    <div id="welcome-state" class="welcome-state">
        <div class="welcome-icon">⚽</div>
        <div class="welcome-title">ApostasIA Engine</div>
        <div class="welcome-sub">
            Sistema Autônomo de Análise Quantitativa Esportiva.<br>
            Clique abaixo para executar o pipeline de análise e identificar oportunidades de valor (+EV) em jogos de futebol.
        </div>
        <div class="welcome-info">
            <div class="welcome-info-item">
                <div class="num" id="w-dates">--</div>
                <div class="lbl">Datas de Análise</div>
            </div>
            <div class="welcome-info-item">
                <div class="num" id="w-api-avail">--</div>
                <div class="lbl">Requests Disponíveis</div>
            </div>
            <div class="welcome-info-item">
                <div class="num" id="w-api-used">--</div>
                <div class="lbl">Requests Usadas Hoje</div>
            </div>
            <div class="welcome-info-item">
                <div class="num" id="w-plan">--</div>
                <div class="lbl">Plano</div>
            </div>
        </div>
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:20px;flex-wrap:wrap;justify-content:center">
            <div class="date-picker-group" style="padding:8px 16px">
                <label style="font-size:12px">📅 De:</label>
                <input type="date" id="w-date-start" style="font-size:13px;padding:6px 10px">
                <label style="font-size:12px">Até:</label>
                <input type="date" id="w-date-end" style="font-size:13px;padding:6px 10px">
                <button onclick="_triggerDateLoad(true)" title="Buscar dados" style="background:var(--accent-green);color:#fff;border:none;border-radius:6px;padding:6px 12px;cursor:pointer;font-size:13px;font-weight:600">🔍 Buscar</button>
            </div>
        </div>
        <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
            <button class="btn-run-big" id="btn-run-big" onclick="executeEngine()">▶ Executar Análise</button>
            <button class="btn-run-big" id="btn-run-retro" onclick="executeEngine(true)" style="background:linear-gradient(135deg,#7c3aed,#5b21b6)" title="Roda análise + verifica resultados automaticamente">📊 Análise Retroativa + Resultados</button>
        </div>
        <button class="btn-recalc-big" id="btn-recalc-big" onclick="recalculateEngine()">🔄 Recalcular (0 API calls)</button>
        <div class="welcome-cost">
            💡 <strong>Análise Retroativa:</strong> Selecione datas passadas nos campos acima para mapear oportunidades históricas e verificar resultados.<br>
            Custo estimado: ~310 requests/dia | Recalcular: 0 requests
        </div>
        <div id="w-last-run" style="margin-top:16px;font-size:13px;color:var(--text-muted)"></div>
        <div id="w-run-history" style="margin-top:12px;font-size:11px;color:var(--text-muted)"></div>
    </div>

    <!-- DASHBOARD (aparece após execução) -->
    <div id="dashboard" style="display:none">

        <!-- RUN INFO BAR -->
        <div class="run-info-bar" id="run-info-bar">
            <div class="run-info-left">
                <div class="run-info-item">🕐 Última execução: <strong id="ri-last-run">--</strong></div>
                <div class="run-info-separator"></div>
                <div class="run-info-item">📅 Dados: <strong id="ri-dates">--</strong></div>
                <div class="run-info-separator"></div>
                <div class="run-info-item">⏱ Pipeline: <strong id="ri-runtime">--</strong></div>
                <div class="run-info-separator"></div>
                <div class="run-info-item">📡 API calls: <span class="accent" id="ri-api-calls">--</span></div>
            </div>
        </div>

        <!-- STATS -->
        <div class="stats-row" id="stats-row"></div>

        <!-- TABS -->
        <div class="tabs">
            <button class="tab active" data-tab="opportunities" onclick="switchTab('opportunities')">🎯 Oportunidades +EV</button>
            <button class="tab" data-tab="matches" onclick="switchTab('matches')">⚽ Todos os Jogos</button>
            <button class="tab" data-tab="performance" onclick="switchTab('performance')">📊 Dashboard</button>
        </div>

        <!-- OPPORTUNITIES -->
        <div class="section active" id="sec-opportunities">
            <div class="section-title">
                <span class="icon">🎯</span> Oportunidades de Valor (+EV)
                <span class="section-count" id="opp-count">0</span>
                <span style="font-size:12px;color:var(--text-muted);font-weight:400;margin-left:8px">Clique nas colunas para ordenar | Use os filtros abaixo dos cabeçalhos</span>
            </div>
            <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;flex-wrap:wrap">
                <button onclick="clearAllFiltersGlobal()" style="background:var(--bg-card);border:1px solid var(--border);color:var(--text-muted);padding:5px 12px;border-radius:6px;cursor:pointer;font-size:11px">🔄 Limpar Filtros</button>
                <button class="btn-export" id="btn-export" onclick="exportToExcel()">📥 Exportar Excel</button>
                <span id="filter-status" style="font-size:11px;color:var(--text-muted)"></span>
            </div>
            <div class="filter-views-bar" id="fv-bar-main">
                <span class="fv-label">📌 Visões:</span>
                <div id="fv-chips-main"></div>
                <button class="fv-btn-save" onclick="openSaveFilterView('main')">💾 Salvar Visão</button>
            </div>
            <div class="table-wrap">
                <table id="opp-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="index" data-type="num" onclick="sortTable(this)">#</th>
                            <th class="sortable" data-sort="team" data-type="str" onclick="sortTable(this)">Jogo</th>
                            <th class="sortable" data-sort="league" data-type="str" onclick="sortTable(this)">Liga</th>
                            <th class="sortable sort-asc" data-sort="date" data-type="str" onclick="sortTable(this)">Data</th>
                            <th class="sortable" data-sort="game_status" data-type="num" onclick="sortTable(this)">Status</th>
                            <th class="sortable" data-sort="result" data-type="str" onclick="sortTable(this)">Resultado</th>
                            <th class="sortable" data-sort="market" data-type="str" onclick="sortTable(this)">Mercado</th>
                            <th class="sortable" data-sort="selection" data-type="str" onclick="sortTable(this)">Seleção</th>
                            <th class="sortable" data-sort="odd" data-type="num" onclick="sortTable(this)">Odd Casa</th>
                            <th class="sortable" data-sort="fair_odd" data-type="num" onclick="sortTable(this)">Odd Justa</th>
                            <th class="sortable" data-sort="edge" data-type="num" onclick="sortTable(this)">Edge</th>
                            <th class="sortable" data-sort="prob" data-type="num" onclick="sortTable(this)">Prob.</th>
                            <th class="sortable" data-sort="confidence" data-type="str" onclick="sortTable(this)">Nível</th>
                            <th class="sortable" data-sort="conf_score" data-type="num" onclick="sortTable(this)">Score</th>
                            <th class="sortable" data-sort="analysis_type" data-type="str" onclick="sortTable(this)">Tipo</th>
                            <th class="sortable" data-sort="pnl" data-type="num" onclick="sortTable(this)">P&L</th>
                        </tr>
                        <tr class="col-filter-row">
                            <th></th>
                            <th><input class="col-filter" type="text" id="cf-team" placeholder="Time..." oninput="applyColumnFilters()"></th>
                            <th><div id="cf-league"></div></th>
                            <th><div class="col-filter-datetime">
                                <input type="datetime-local" id="cf-dt-start" title="De (data/hora)" oninput="applyColumnFilters()">
                                <input type="datetime-local" id="cf-dt-end" title="Até (data/hora)" oninput="applyColumnFilters()">
                            </div></th>
                            <th><div id="cf-game-status"></div></th>
                            <th><div id="cf-result"></div></th>
                            <th><div id="cf-market"></div></th>
                            <th><div id="cf-selection"></div></th>
                            <th><div class="col-filter-num"><input type="number" id="cf-odd-min" placeholder="Min" step="0.1" oninput="applyColumnFilters()"><input type="number" id="cf-odd-max" placeholder="Max" step="0.1" oninput="applyColumnFilters()"></div></th>
                            <th><div class="col-filter-num"><input type="number" id="cf-fair-odd-min" placeholder="Min" step="0.1" oninput="applyColumnFilters()"><input type="number" id="cf-fair-odd-max" placeholder="Max" step="0.1" oninput="applyColumnFilters()"></div></th>
                            <th><div class="col-filter-num"><input type="number" id="cf-edge-min" placeholder="Min" step="1" oninput="applyColumnFilters()"><input type="number" id="cf-edge-max" placeholder="Max" step="1" oninput="applyColumnFilters()"></div></th>
                            <th><div class="col-filter-num"><input type="number" id="cf-prob-min" placeholder="Min" step="1" oninput="applyColumnFilters()"><input type="number" id="cf-prob-max" placeholder="Max" step="1" oninput="applyColumnFilters()"></div></th>
                            <th><div id="cf-confidence"></div></th>
                            <th><div class="col-filter-num"><input type="number" id="cf-score-min" placeholder="Min" step="1" oninput="applyColumnFilters()"><input type="number" id="cf-score-max" placeholder="Max" step="1" oninput="applyColumnFilters()"></div></th>
                            <th><div id="cf-analysis-type"></div></th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="opp-tbody"></tbody>
                </table>
            </div>
        </div>

        <!-- MATCHES -->
        <div class="section" id="sec-matches">
            <div class="section-title">
                <span class="icon">⚽</span> Todas as Partidas
                <span class="section-count" id="match-count">0</span>
            </div>
            <div class="filter-bar">
                <div id="filter-match-league" style="min-width:160px"></div>
                <div class="col-filter-datetime" style="flex-direction:row;gap:6px;align-items:center;min-width:auto">
                    <label style="font-size:10px;white-space:nowrap">De:</label>
                    <input type="datetime-local" id="filter-match-dt-start" oninput="filterMatches()" style="font-size:11px;padding:4px 6px">
                    <label style="font-size:10px;white-space:nowrap">Até:</label>
                    <input type="datetime-local" id="filter-match-dt-end" oninput="filterMatches()" style="font-size:11px;padding:4px 6px">
                </div>
                <input class="filter-input" type="text" id="filter-match-search" placeholder="Buscar time..." oninput="filterMatches()">
            </div>
            <div class="table-wrap">
                <table id="match-table">
                    <thead>
                        <tr>
                            <th>Jogo</th>
                            <th>Liga</th>
                            <th>Data/Hora</th>
                            <th>Status</th>
                            <th>Resultado</th>
                            <th>xG</th>
                            <th>1x2</th>
                            <th>O/U 2.5</th>
                            <th>BTTS</th>
                            <th>Clima</th>
                            <th>Oportunidades</th>
                        </tr>
                    </thead>
                    <tbody id="match-tbody"></tbody>
                </table>
            </div>
        </div>

        <!-- PERFORMANCE DASHBOARD -->
        <div class="section" id="sec-performance">
            <!-- DASHBOARD FILTER BAR -->
            <div class="dash-filter-bar" id="dash-filter-bar">
                <div class="dash-filter-row">
                    <div class="dash-filter-group">
                        <label>📅 De</label>
                        <input type="date" id="df-date-start" onchange="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>📅 Até</label>
                        <input type="date" id="df-date-end" onchange="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>🎯 Mercado</label>
                        <div id="df-market"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>📈 Confiança</label>
                        <div id="df-confidence"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>🌍 País</label>
                        <div id="df-country"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>🏆 Liga</label>
                        <div id="df-league"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>▶ Seleção</label>
                        <div id="df-selection"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>🔬 Tipo Análise</label>
                        <div id="df-analysis-type"></div>
                    </div>
                    <div class="dash-filter-group">
                        <label>💰 Odd Casa Min</label>
                        <input type="number" id="df-odd-min" step="0.1" placeholder="1.0" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>💰 Odd Casa Max</label>
                        <input type="number" id="df-odd-max" step="0.1" placeholder="99" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>🎯 Odd Justa Min</label>
                        <input type="number" id="df-fair-odd-min" step="0.1" placeholder="1.0" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>🎯 Odd Justa Max</label>
                        <input type="number" id="df-fair-odd-max" step="0.1" placeholder="99" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>📐 Edge Min</label>
                        <input type="number" id="df-edge-min" step="1" placeholder="0%" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group">
                        <label>📐 Edge Max</label>
                        <input type="number" id="df-edge-max" step="1" placeholder="100%" oninput="applyDashboardFilters()">
                    </div>
                    <div class="dash-filter-group" style="align-self:flex-end">
                        <button class="btn-clear-dash" onclick="clearAllFiltersGlobal()">🔄 Limpar Filtros</button>
                    </div>
                </div>
                <div class="filter-views-bar" style="padding:8px 0 4px">
                    <span class="fv-label">📌 Visões:</span>
                    <div id="fv-chips-dash"></div>
                    <button class="fv-btn-save" onclick="openSaveFilterView('dash')">💾 Salvar Visão</button>
                </div>
                <div class="dash-filter-summary" id="dash-filter-summary"></div>
            </div>

            <div id="dashboard-content">
                <div style="text-align:center;padding:60px;color:var(--text-muted)">
                    <div style="font-size:48px;margin-bottom:16px">📊</div>
                    <div style="font-size:15px">Clique em <strong>✅ Resultados</strong> para verificar jogos finalizados e popular o dashboard.</div>
                </div>
            </div>
        </div>
    </div>
</main>

<!-- SAVE FILTER VIEW MODAL -->
<div class="fv-save-modal" id="fv-save-modal" onclick="closeSaveFilterView(event)">
    <div class="fv-save-modal-box" onclick="event.stopPropagation()">
        <h3>💾 Salvar Visão de Filtro</h3>
        <input type="text" id="fv-name-input" placeholder="Nome da visão (ex: Alta Confiança, Pré-Jogo...)" maxlength="40" onkeydown="if(event.key==='Enter')confirmSaveFilterView()">
        <div class="fv-btns">
            <button class="fv-btn-cancel" onclick="closeSaveFilterView()">Cancelar</button>
            <button class="fv-btn-confirm" onclick="confirmSaveFilterView()">✅ Salvar</button>
        </div>
    </div>
</div>

<!-- DETAIL MODAL -->
<div class="modal-overlay" id="modal-overlay" onclick="closeModal(event)">
    <div class="modal" onclick="event.stopPropagation()">
        <div class="modal-header">
            <div>
                <h2 id="modal-title"></h2>
                <div style="color:var(--text-secondary);font-size:13px;margin-top:4px" id="modal-subtitle"></div>
            </div>
            <button class="close" onclick="closeModal()">&times;</button>
        </div>
        <div class="modal-body" id="modal-body"></div>
    </div>
</div>

<script>
// ═══════════════════════════════════════════
// DATA STORES
// ═══════════════════════════════════════════
let allOpps = [];
let allMatches = [];
let allLeagues = [];
let stats = {};
let apiStatus = {};
let engineRunning = false;
let timerInterval = null;

// ═══════════════════════════════════════════
// FILTER VIEWS SYSTEM (saved filter presets)
// ═══════════════════════════════════════════
const FV_STORAGE_KEY = 'apostasIA_filterViews';
let _fvSaveTarget = 'main'; // 'main' or 'dash'
let _fvActiveId = null; // single active view id (shared)

// Mapping between main ↔ dashboard filter IDs
const _fvFieldMap = {
    // multi-selects main→dash
    'ms:cf-league': 'ms:df-league', 'ms:cf-market': 'ms:df-market',
    'ms:cf-selection': 'ms:df-selection', 'ms:cf-confidence': 'ms:df-confidence',
    'ms:cf-analysis-type': 'ms:df-analysis-type',
    // numeric main→dash
    'cf-odd-min': 'df-odd-min', 'cf-odd-max': 'df-odd-max',
    'cf-fair-odd-min': 'df-fair-odd-min', 'cf-fair-odd-max': 'df-fair-odd-max',
    'cf-edge-min': 'df-edge-min', 'cf-edge-max': 'df-edge-max',
};
// Build reverse map dash→main
const _fvFieldMapReverse = {};
for (const [k, v] of Object.entries(_fvFieldMap)) _fvFieldMapReverse[v] = k;

function _fvLoad() {
    try { return JSON.parse(localStorage.getItem(FV_STORAGE_KEY) || '[]'); } catch { return []; }
}
function _fvSave(views) {
    localStorage.setItem(FV_STORAGE_KEY, JSON.stringify(views));
}

// Convert a saved state to be used in the OTHER tab
function _fvConvertState(state, fromTarget) {
    const map = fromTarget === 'main' ? _fvFieldMap : _fvFieldMapReverse;
    const converted = {};
    for (const [key, val] of Object.entries(state)) {
        if (key === '_sort' || key === '_source') continue;
        const mappedKey = map[key];
        if (mappedKey) converted[mappedKey] = val;
    }
    return converted;
}

// Capture current filter state for main table
function _captureMainFilters() {
    const state = { _source: 'main' };
    ['cf-team'].forEach(id => { const el = document.getElementById(id); if (el && el.value) state[id] = el.value; });
    ['cf-dt-start','cf-dt-end'].forEach(id => { const el = document.getElementById(id); if (el && el.value) state[id] = el.value; });
    ['cf-odd-min','cf-odd-max','cf-fair-odd-min','cf-fair-odd-max','cf-edge-min','cf-edge-max','cf-prob-min','cf-prob-max','cf-score-min','cf-score-max'].forEach(id => {
        const el = document.getElementById(id); if (el && el.value !== '') state[id] = el.value;
    });
    ['cf-league','cf-game-status','cf-result','cf-market','cf-selection','cf-confidence','cf-analysis-type'].forEach(id => {
        if (msRegistry[id] && msRegistry[id].hasActiveFilter()) state['ms:'+id] = msRegistry[id].getRawSelected();
    });
    state._sort = { ...currentSort };
    return state;
}

// Capture current filter state for dashboard
function _captureDashFilters() {
    const state = { _source: 'dash' };
    ['df-date-start','df-date-end'].forEach(id => { const el = document.getElementById(id); if (el && el.value) state[id] = el.value; });
    ['df-odd-min','df-odd-max','df-fair-odd-min','df-fair-odd-max','df-edge-min','df-edge-max'].forEach(id => {
        const el = document.getElementById(id); if (el && el.value !== '') state[id] = el.value;
    });
    ['df-market','df-selection','df-confidence','df-country','df-league','df-analysis-type'].forEach(id => {
        if (msRegistry[id] && msRegistry[id].hasActiveFilter()) state['ms:'+id] = msRegistry[id].getRawSelected();
    });
    return state;
}

// Apply a saved filter state to main
function _applyMainFilters(state) {
    ['cf-team','cf-dt-start','cf-dt-end','cf-odd-min','cf-odd-max','cf-fair-odd-min','cf-fair-odd-max','cf-edge-min','cf-edge-max','cf-prob-min','cf-prob-max','cf-score-min','cf-score-max'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = state[id] || '';
    });
    ['cf-league','cf-game-status','cf-result','cf-market','cf-selection','cf-confidence','cf-analysis-type'].forEach(id => {
        if (msRegistry[id]) {
            const key = 'ms:'+id;
            if (state[key] && state[key].length) { msRegistry[id].setSelected(state[key]); } else { msRegistry[id].reset(); }
        }
    });
    if (state._sort) {
        currentSort = { ...state._sort };
        document.querySelectorAll('#opp-table th.sortable').forEach(h => h.classList.remove('sort-asc','sort-desc'));
        const th = document.querySelector(`#opp-table th[data-sort="${currentSort.key}"]`);
        if (th) th.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    applyColumnFilters();
}

// Apply a saved filter state to dashboard
function _applyDashFilters(state) {
    ['df-date-start','df-date-end','df-odd-min','df-odd-max','df-fair-odd-min','df-fair-odd-max','df-edge-min','df-edge-max'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = state[id] || '';
    });
    ['df-market','df-selection','df-confidence','df-country','df-league','df-analysis-type'].forEach(id => {
        if (msRegistry[id]) {
            const key = 'ms:'+id;
            if (state[key] && state[key].length) { msRegistry[id].setSelected(state[key]); } else { msRegistry[id].reset(); }
        }
    });
    applyDashboardFilters();
}

function openSaveFilterView(target) {
    _fvSaveTarget = target;
    const modal = document.getElementById('fv-save-modal');
    const input = document.getElementById('fv-name-input');
    input.value = '';
    modal.classList.add('show');
    setTimeout(() => input.focus(), 80);
}

function closeSaveFilterView(e) {
    if (e && e.target !== document.getElementById('fv-save-modal')) return;
    document.getElementById('fv-save-modal').classList.remove('show');
}

function confirmSaveFilterView() {
    const name = document.getElementById('fv-name-input').value.trim();
    if (!name) { document.getElementById('fv-name-input').style.borderColor = 'var(--accent-red)'; return; }

    const state = _fvSaveTarget === 'main' ? _captureMainFilters() : _captureDashFilters();
    const views = _fvLoad();
    const id = 'fv_' + Date.now();
    views.push({ id, name, target: _fvSaveTarget, state, createdAt: new Date().toISOString() });
    _fvSave(views);
    closeSaveFilterView();
    renderFilterViews();
}

function deleteFilterView(id, e) {
    if (e) { e.stopPropagation(); e.preventDefault(); }
    const views = _fvLoad().filter(v => v.id !== id);
    _fvSave(views);
    if (_fvActiveId === id) _fvActiveId = null;
    renderFilterViews();
}

function loadFilterView(id, applyTo) {
    const views = _fvLoad();
    const view = views.find(v => v.id === id);
    if (!view) return;

    // Toggle: se já ativo, desativa
    if (_fvActiveId === id) {
        _fvActiveId = null;
        clearAllFiltersGlobal();
        renderFilterViews();
        return;
    }

    _fvActiveId = id;

    // Determinar onde aplicar: se applyTo é dado, usar; senão, aplicar na aba atual
    const currentTab = document.querySelector('.tab.active')?.dataset?.tab;
    const targetTab = applyTo || (currentTab === 'performance' ? 'dash' : 'main');

    if (targetTab === 'main') {
        // Se a view veio do main, aplica direto; se veio do dash, converte
        const mainState = view.target === 'main' ? view.state : _fvConvertState(view.state, 'dash');
        _applyMainFilters(mainState);
    } else {
        // Se a view veio do dash, aplica direto; se veio do main, converte
        const dashState = view.target === 'dash' ? view.state : _fvConvertState(view.state, 'main');
        _applyDashFilters(dashState);
    }

    renderFilterViews();
}

function renderFilterViews() {
    const views = _fvLoad();

    // Main chips - ALL views
    const mainContainer = document.getElementById('fv-chips-main');
    if (mainContainer) {
        mainContainer.innerHTML = views.map(v => {
            const active = _fvActiveId === v.id ? 'fv-active' : '';
            const sourceIcon = v.target === 'main' ? '🎯' : '📊';
            return `<span class="fv-chip ${active}" onclick="loadFilterView('${v.id}','main')" title="${v.target === 'main' ? 'Salvo na tela principal' : 'Salvo no dashboard'} — Clique para aplicar">
                ${sourceIcon} ${v.name}
                <span class="fv-delete" onclick="deleteFilterView('${v.id}', event)" title="Excluir">✕</span>
            </span>`;
        }).join('');
    }

    // Dashboard chips - ALL views
    const dashContainer = document.getElementById('fv-chips-dash');
    if (dashContainer) {
        dashContainer.innerHTML = views.map(v => {
            const active = _fvActiveId === v.id ? 'fv-active' : '';
            const sourceIcon = v.target === 'main' ? '🎯' : '📊';
            return `<span class="fv-chip ${active}" onclick="loadFilterView('${v.id}','dash')" title="${v.target === 'main' ? 'Salvo na tela principal' : 'Salvo no dashboard'} — Clique para aplicar">
                ${sourceIcon} ${v.name}
                <span class="fv-delete" onclick="deleteFilterView('${v.id}', event)" title="Excluir">✕</span>
            </span>`;
        }).join('');
    }
}

// Esc closes filter view save modal
document.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeSaveFilterView();
});

// ═══════════════════════════════════════════
// GAME STATUS HELPER (LIVE / FINISHED / UPCOMING)
// Considera 120 min para jogo em andamento e concluído
// ═══════════════════════════════════════════
function getGameStatus(matchDate, matchTime) {
    const now = new Date();
    // Construir datetime do jogo
    const timeParts = (matchTime || '00:00').split(':');
    const hh = parseInt(timeParts[0]) || 0;
    const mm = parseInt(timeParts[1]) || 0;
    
    const dateParts = (matchDate || '').split('-');
    if (dateParts.length < 3) return { status: 'UPCOMING', timeLabel: '?', minutesUntil: 0 };
    
    const matchDt = new Date(
        parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
        hh, mm, 0
    );
    
    const diffMs = now - matchDt;
    const diffMin = diffMs / 60000;
    
    if (diffMin < 0) {
        // Jogo ainda não começou
        const minUntil = Math.abs(diffMin);
        let timeLabel;
        if (minUntil < 60) timeLabel = Math.round(minUntil) + 'min';
        else if (minUntil < 1440) timeLabel = Math.round(minUntil / 60) + 'h';
        else timeLabel = Math.round(minUntil / 1440) + 'd';
        return { status: 'UPCOMING', timeLabel: timeLabel, minutesUntil: minUntil };
    } else if (diffMin <= 120) {
        // Jogo em andamento (< 120 min desde o início)
        return { status: 'LIVE', timeLabel: Math.round(diffMin) + "'", minutesUntil: 0 };
    } else {
        // Jogo encerrado (> 120 min desde o início)
        return { status: 'FINISHED', timeLabel: 'FT', minutesUntil: 0 };
    }
}

// ═══════════════════════════════════════════
// MARKET CLASS HELPER
// ═══════════════════════════════════════════
function getMarketClass(market) {
    if (!market) return 'market-ou';
    const m = market.toLowerCase();
    if (m === '1x2') return 'market-1x2';
    if (m.includes('dupla chance')) return 'market-dc';
    if (m.includes('btts')) return 'market-btts';
    if (m.includes('clean sheet')) return 'market-cs';
    if (m.includes('sofrer')) return 'market-wtn';
    if (m.includes('1o tempo') || m.includes('1° tempo')) return 'market-ht';
    if (m.includes('par/impar') || m.includes('par') || m.includes('impar')) return 'market-oe';
    if (m.includes('placar exato')) return 'market-exact';
    if (m.includes('fin. jogador') || m.includes('sot jogador')) return 'market-player-shots';
    if (m.includes('finaliz') && m.includes('1x2')) return 'market-shots-real';
    if (m.includes('finaliz') || m.includes('sot')) return 'market-shots';
    if (m.includes('escanteio') || m.includes('corners')) return 'market-corners';
    if (m.includes('cart')) return 'market-cards';
    if (m.includes('gols casa') || m.includes('gols fora')) return 'market-team-ou';
    if (m.includes('gols') || m.includes('o/u')) return 'market-ou';
    return 'market-ou';
}

// ═══════════════════════════════════════════
// ALL MARKETS ODDS BUILDER
// ═══════════════════════════════════════════
function buildAllMarketsOdds(m) {
    const _MARKET_LABELS = {
        "1x2": "⚽ 1x2 (Match Winner)",
        "double_chance": "🎯 Dupla Chance",
        "goals_ou": "⚽ Gols Over/Under",
        "btts": "🤝 Ambas Marcam (BTTS)",
        "home_goals_ou": "🏠 Gols Casa O/U",
        "away_goals_ou": "✈️ Gols Fora O/U",
        "cs_home": "🧤 Clean Sheet Casa",
        "cs_away": "🧤 Clean Sheet Fora",
        "wtn_home": "💪 Vitória s/ Sofrer Casa",
        "wtn_away": "💪 Vitória s/ Sofrer Fora",
        "odd_even": "🎲 Par/Impar Gols",
        "ht_result": "⏱️ 1° Tempo (Resultado)",
        "ht_goals_ou": "⏱️ 1° Tempo Gols O/U",
        "h2_goals_ou": "⏱️ 2° Tempo Gols O/U",
        "corners_ou": "🏁 Escanteios O/U",
        "cards_ou": "🟨 Cartoes O/U",
        "exact_score": "🎯 Placar Exato (Top)",
        "asian_handicap": "📐 Asian Handicap",
        "ht_ft": "⏱️ HT/FT",
        "win_both_halves": "💪 Vencer Ambos Tempos",
        "both_halves_score": "⚽ Gol em Ambos Tempos",
        "result_total": "📊 Resultado & Total",
        "sot_1x2": "🎯 Finaliz. Gol 1x2",
        "shots_1x2": "🎯 Finalizações 1x2",
        "sot_ou": "🎯 Finaliz. Gol O/U",
        "shots_ou": "🎯 Finalizações O/U",
        "home_shots_ou": "🏠 Finaliz. Casa O/U",
        "away_shots_ou": "✈️ Finaliz. Fora O/U",
    };
    const _SEL_LABELS = {
        "home": "Casa", "draw": "Empate", "away": "Fora",
        "home/draw": "1X (Casa ou Empate)", "draw/away": "X2 (Fora ou Empate)", "home/away": "12 (Casa ou Fora)",
        "yes": "Sim", "no": "Nao", "odd": "Impar", "even": "Par",
    };
    const probs = m.model_probs || {};
    const markets = m.all_markets || {};
    // Also include legacy odds
    if (!markets["1x2"]) markets["1x2"] = {home: m.odds_home, draw: m.odds_draw, away: m.odds_away};
    if (!markets["goals_ou"]) markets["goals_ou"] = {over_2_5: m.odds_over25, under_2_5: m.odds_under25};
    if (!markets["btts"]) markets["btts"] = {yes: m.odds_btts_yes, no: m.odds_btts_no};

    // Helper: BOOKMAKER_COLORS
    const _BK_COLORS = {
        "bet365": "#007b5e", "pinnacle": "#e74c3c", "1xbet": "#1a5276",
        "betway": "#00a0e3", "bwin": "#ffcc00", "william hill": "#003b2f",
        "marathonbet": "#1e4d8c", "unibet": "#147b45", "betfair": "#ffb80c",
        "888sport": "#1a1a1a", "sportingbet": "#006e33", "betano": "#ff6600",
    };
    const bkColor = (name) => {
        const k = (name || '').toLowerCase();
        for (const [bk, c] of Object.entries(_BK_COLORS)) { if (k.includes(bk)) return c; }
        return '#3b82f6';
    };

    let html = '';
    const orderedKeys = ["1x2","double_chance","goals_ou","btts","home_goals_ou","away_goals_ou",
        "ht_result","ht_goals_ou","h2_goals_ou","cs_home","cs_away","wtn_home","wtn_away","odd_even",
        "corners_ou","cards_ou","sot_1x2","shots_1x2","sot_ou","shots_ou","home_shots_ou","away_shots_ou",
        "exact_score","asian_handicap","ht_ft","win_both_halves","both_halves_score","result_total"];
    const allKeys = new Set([...orderedKeys, ...Object.keys(markets)]);
    for (const mk of allKeys) {
        const mkt = markets[mk];
        if (!mkt || typeof mkt !== 'object') continue;
        const bkData = mkt._bookmakers || {};
        const bkNames = Object.keys(bkData);
        const hasMultiBk = bkNames.length > 1;
        const entries = Object.entries(mkt).filter(([k,v]) => typeof v === 'number' && v > 1.0);
        if (!entries.length) continue;
        const label = _MARKET_LABELS[mk] || mk.replace(/_/g,' ').toUpperCase();
        const sourceNote = mkt._source ? ` <span style="font-size:10px;color:var(--text-muted)">(${mkt._source})</span>` : '';
        const multiBkBadge = hasMultiBk ? ` <span style="font-size:9px;padding:2px 6px;background:rgba(59,130,246,0.15);color:var(--accent-cyan);border-radius:4px;font-weight:700">${bkNames.length} casas</span>` : '';

        html += `<div style="margin-top:14px">
            <div style="font-size:12px;font-weight:700;color:var(--accent-cyan);margin-bottom:6px">${label}${sourceNote}${multiBkBadge}</div>
            <div class="odds-grid">`;

        // ── Odds do bookmaker principal ──
        for (const [sk, odd] of entries) {
            const selLabel = _SEL_LABELS[sk] || sk.replace(/_/g,' ').replace(/over_/i,'O ').replace(/under_/i,'U ');
            const probKey = `${mk}__${sk}`;
            const modelP = probs[probKey];
            const probStr = modelP ? `<div class="odds-card-prob">Modelo: ${(modelP*100).toFixed(1)}%</div>` : '';
            const fairStr = modelP ? `<div class="odds-card-prob" style="color:var(--accent-yellow)">Fair: ${(1/modelP).toFixed(2)}</div>` : '';
            const isEV = modelP && (modelP * odd - 1) > 0.03;
            const evStyle = isEV ? 'border:1px solid var(--accent-green);background:rgba(46,213,115,0.08)' : '';
            html += `<div class="odds-card" style="${evStyle}">
                <div class="odds-card-label">${selLabel}</div>
                <div class="odds-card-value">${odd}</div>
                ${probStr}${fairStr}
                ${isEV ? '<div style="font-size:9px;color:var(--accent-green);font-weight:700;margin-top:2px">✓ EV+</div>' : ''}
            </div>`;
        }
        html += '</div>';

        // ── Comparativo multi-bookmaker ──
        if (hasMultiBk) {
            // Coletar todas as seleções disponíveis (chaves numéricas/string)
            const allSels = new Set();
            for (const bkn of bkNames) {
                for (const [k, v] of Object.entries(bkData[bkn])) {
                    if (typeof v === 'number' && v > 1.0) allSels.add(k);
                }
            }
            const selsArr = [...allSels].sort();
            if (selsArr.length > 0 && selsArr.length <= 30) {
                html += `<details style="margin-top:6px"><summary style="cursor:pointer;font-size:10px;color:var(--accent-cyan);font-weight:700;padding:2px 0">▶ Comparar ${bkNames.length} casas de apostas</summary>`;
                html += `<div style="overflow-x:auto;margin-top:6px"><table style="width:100%;font-size:11px;border-collapse:collapse">
                    <thead><tr style="border-bottom:1px solid var(--border)">
                        <th style="text-align:left;padding:4px 8px;color:var(--text-secondary);font-weight:600;min-width:110px">Casa</th>`;
                for (const sel of selsArr) {
                    const selLbl = _SEL_LABELS[sel] || sel.replace(/_/g,' ').replace(/over_/i,'O ').replace(/under_/i,'U ');
                    html += `<th style="text-align:center;padding:4px 6px;color:var(--text-secondary);font-weight:600;white-space:nowrap">${selLbl}</th>`;
                }
                html += `</tr></thead><tbody>`;

                // Para cada seleção, encontrar a melhor odd
                const bestOdds = {};
                for (const sel of selsArr) {
                    let best = 0;
                    for (const bkn of bkNames) {
                        const val = bkData[bkn][sel];
                        if (typeof val === 'number' && val > best) best = val;
                    }
                    bestOdds[sel] = best;
                }

                for (const bkn of bkNames) {
                    const c = bkColor(bkn);
                    const info = getBookmakerInfo(bkn);
                    const link = info.footballUrl;
                    const nameHtml = link
                        ? `<a href="${link}" target="_blank" rel="noopener" style="color:${c};text-decoration:none;font-weight:700" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${info.name}</a>`
                        : `<span style="color:${c};font-weight:700">${bkn}</span>`;
                    html += `<tr style="border-bottom:1px solid rgba(255,255,255,0.04)">
                        <td style="padding:5px 8px">${nameHtml}</td>`;
                    for (const sel of selsArr) {
                        const val = bkData[bkn][sel];
                        const isNum = typeof val === 'number' && val > 1.0;
                        const isBest = isNum && val === bestOdds[sel] && bkNames.length > 1;
                        const probKey2 = `${mk}__${sel}`;
                        const mp = probs[probKey2];
                        const isEV2 = mp && isNum && (mp * val - 1) > 0.03;
                        const cellStyle = isBest
                            ? 'font-weight:800;color:var(--accent-green);background:rgba(46,213,115,0.06)'
                            : isEV2 ? 'font-weight:700;color:var(--accent-green)' : 'color:var(--text-primary)';
                        html += `<td style="text-align:center;padding:5px 6px;${cellStyle};font-family:'JetBrains Mono',monospace">${isNum ? val.toFixed(2) : '-'}${isBest ? ' ★' : ''}${isEV2 && !isBest ? ' ✓' : ''}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody></table></div></details>';
            }
        }
        html += '</div>';
    }
    return html || '<div style="color:var(--text-muted);padding:16px">Nenhuma odd disponível para este jogo</div>';
}

// ═══════════════════════════════════════════
// BOOKMAKER URLs + DEEP LINK BUILDER
// ═══════════════════════════════════════════
const BOOKMAKER_URLS = {
    "bet365":        { name: "Bet365",       color: "#007b5e", football: "https://www.bet365.com/#/AC/B1/C1/D1002/E76/G40/" },
    "1xbet":         { name: "1xBet",        color: "#1a5276", football: "https://1xbet.com/en/line/football/" },
    "pinnacle":      { name: "Pinnacle",     color: "#e74c3c", football: "https://www.pinnacle.com/pt/football/" },
    "betway":        { name: "Betway",       color: "#00a0e3", football: "https://betway.com/pt/sports/soccer" },
    "bwin":          { name: "Bwin",         color: "#ffcc00", football: "https://sports.bwin.com/pt/sports/futebol-4" },
    "william hill":  { name: "William Hill", color: "#003b2f", football: "https://sports.williamhill.com/betting/pt-pt/football" },
    "marathonbet":   { name: "Marathonbet",  color: "#1e4d8c", football: "https://www.marathonbet.com/en/betting/Football/" },
    "unibet":        { name: "Unibet",       color: "#147b45", football: "https://www.unibet.com/betting/sports/football" },
    "betfair":       { name: "Betfair",      color: "#ffb80c", football: "https://www.betfair.com/sport/football" },
    "888sport":      { name: "888sport",     color: "#1a1a1a", football: "https://www.888sport.com/football/" },
    "sportingbet":   { name: "Sportingbet",  color: "#006e33", football: "https://sports.sportingbet.com/pt-br/sports/futebol-4" },
    "betano":        { name: "Betano",       color: "#ff6600", football: "https://www.betano.com/sport/futebol" },
    "rivalo":        { name: "Rivalo",       color: "#1a237e", football: "https://www.rivalo.com/pt-br/sports/football" },
    "novibet":       { name: "Novibet",      color: "#1b1464", football: "https://www.novibet.com/sports/football" },
    "superbet":      { name: "Superbet",     color: "#e60000", football: "https://superbet.com/sports/football" },
};

function getBookmakerInfo(bkName) {
    if (!bkName || bkName === "N/D") {
        return { name: bkName || "N/D", url: null, footballUrl: null, color: "#555" };
    }
    const key = bkName.toLowerCase().trim();
    for (const [k, v] of Object.entries(BOOKMAKER_URLS)) {
        if (key.includes(k) || k.includes(key)) {
            return { name: v.name, url: v.football, footballUrl: v.football, color: v.color };
        }
    }
    return {
        name: bkName,
        url: null,
        footballUrl: null,
        color: "#3b82f6"
    };
}

function buildBetLink(bkName, homeTeam, awayTeam) {
    const info = getBookmakerInfo(bkName);
    // Link direto para a seção de futebol da casa
    return info.footballUrl || null;
}

function buildNavPath(leagueCountry, leagueName) {
    // Monta o caminho de navegação dentro da casa de apostas
    if (!leagueCountry && !leagueName) return "";
    return `Futebol → ${leagueCountry || "?"} → ${leagueName || "?"}`;
}

function bookmakerBadgeHtml(bkName, homeTeam, awayTeam, market, selection, small, leagueCountry, leagueName) {
    const info = getBookmakerInfo(bkName);
    const betLink = buildBetLink(bkName, homeTeam, awayTeam);
    const sz = small ? 'font-size:10px;padding:3px 8px;' : 'font-size:12px;padding:5px 12px;';
    
    if (!betLink) {
        return `<span style="${sz}background:rgba(85,85,85,0.2);color:#888;border-radius:5px;white-space:nowrap">${info.name}</span>`;
    }
    const navTip = buildNavPath(leagueCountry, leagueName);
    const titleTxt = navTip ? `Ir para ${info.name} — Navegue: ${navTip}` : `Ir para ${info.name} Futebol`;
    return `<a href="${betLink}" target="_blank" rel="noopener" onclick="event.stopPropagation()" 
        style="${sz}background:rgba(59,130,246,0.15);color:var(--accent-blue);border-radius:5px;
        text-decoration:none;white-space:nowrap;display:inline-flex;align-items:center;gap:4px;
        border:1px solid rgba(59,130,246,0.25);transition:all 0.2s;cursor:pointer"
        onmouseover="this.style.background='rgba(59,130,246,0.3)';this.style.borderColor='var(--accent-blue)'"
        onmouseout="this.style.background='rgba(59,130,246,0.15)';this.style.borderColor='rgba(59,130,246,0.25)'"
        title="${titleTxt}">
        🔗 ${info.name}
    </a>`;
}

// ═══════════════════════════════════════════
// INIT — NÃO roda pipeline, só carrega status
// ═══════════════════════════════════════════
async function init() {
    // 0. Inicializar date pickers com hoje e amanhã
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const todayStr = today.toISOString().split('T')[0];
    const tomorrowStr = tomorrow.toISOString().split('T')[0];
    
    document.getElementById("date-start").value = todayStr;
    document.getElementById("date-end").value = tomorrowStr;
    document.getElementById("w-date-start").value = todayStr;
    document.getElementById("w-date-end").value = tomorrowStr;
    
    // Sincronizar date pickers header <-> welcome (sem disparar busca)
    function _syncDatePickers(source) {
        if (source === 'header-start') document.getElementById("w-date-start").value = document.getElementById("date-start").value;
        if (source === 'header-end') document.getElementById("w-date-end").value = document.getElementById("date-end").value;
        if (source === 'welcome-start') document.getElementById("date-start").value = document.getElementById("w-date-start").value;
        if (source === 'welcome-end') document.getElementById("date-end").value = document.getElementById("w-date-end").value;
    }

    // Apenas sincronizar ao mudar (NÃO disparar busca durante digitação)
    ['date-start', 'date-end'].forEach(id => {
        const el = document.getElementById(id);
        const src = id === 'date-start' ? 'header-start' : 'header-end';
        el.addEventListener("change", () => _syncDatePickers(src));
    });
    ['w-date-start', 'w-date-end'].forEach(id => {
        const el = document.getElementById(id);
        const src = id === 'w-date-start' ? 'welcome-start' : 'welcome-end';
        el.addEventListener("change", () => _syncDatePickers(src));
    });

    // Tecla Enter nos date pickers: disparar busca
    document.querySelectorAll('#date-start, #date-end, #w-date-start, #w-date-end').forEach(el => {
        el.addEventListener("keydown", (e) => { if (e.key === 'Enter') { e.target.blur(); _triggerDateLoad(true); } });
    });

    // 1. Buscar status da API (1 request apenas)
    try {
        const res = await fetch("/api/status");
        apiStatus = await res.json();
        updateApiQuotaDisplay();
    } catch(e) {
        console.error("Erro ao buscar status:", e);
    }

    // 2. Buscar histórico de runs para mostrar datas já analisadas
    try {
        const runsRes = await fetch("/api/run-dates");
        const runs = await runsRes.json();
        if (runs && runs.length > 0) {
            const histHtml = runs.slice(0, 5).map(r => {
                const dates = (r.analysis_dates || []).join(', ');
                const dt = r.executed_at ? new Date(r.executed_at).toLocaleString('pt-BR') : '?';
                return `<span style="background:var(--bg-card);padding:3px 10px;border-radius:5px;border:1px solid var(--border)">${dates} <span style="color:var(--text-muted)">(${dt})</span></span>`;
            }).join(' ');
            const histEl = document.getElementById("w-run-history");
            if (histEl) histEl.innerHTML = `📋 Últimas análises: ${histHtml}`;
        }
    } catch(e) {}

    // 3. Definir datas iniciais: usar as da última análise se disponíveis
    let initDateFrom = todayStr;
    let initDateTo = tomorrowStr;
    
    if (apiStatus.analysis_dates && apiStatus.analysis_dates.length > 0) {
        initDateFrom = apiStatus.analysis_dates[0];
        initDateTo = apiStatus.analysis_dates[apiStatus.analysis_dates.length - 1];
        document.getElementById("date-start").value = initDateFrom;
        document.getElementById("date-end").value = initDateTo;
        document.getElementById("w-date-start").value = initDateFrom;
        document.getElementById("w-date-end").value = initDateTo;
    }

    // 4. SEMPRE buscar dados do Supabase com as datas definidas
    console.log(`[INIT] Carregando dados do Supabase: ${initDateFrom} → ${initDateTo}`);
    await loadDataByDates(initDateFrom, initDateTo);
    
    // Se não carregou dados, mostrar welcome
    if (!allOpps || allOpps.length === 0) {
        showWelcomeState();
    }
}

function updateApiQuotaDisplay() {
    const used = apiStatus.used || 0;
    const limit = apiStatus.limit || 7500;
    const available = apiStatus.available || (limit - used);
    const pct = (used / limit) * 100;
    
    const fill = document.getElementById("api-quota-fill");
    fill.style.width = pct + "%";
    fill.style.background = pct > 80 ? "var(--accent-red)" : pct > 50 ? "var(--accent-yellow)" : "var(--accent-green)";
    
    document.getElementById("api-quota-text").textContent = `${used}/${limit}`;
    
    // Welcome info items
    document.getElementById("w-api-avail").textContent = available.toLocaleString();
    document.getElementById("w-api-used").textContent = used.toLocaleString();
    document.getElementById("w-plan").textContent = apiStatus.plan || "--";
    
    if (apiStatus.last_run_at) {
        document.getElementById("w-last-run").innerHTML = 
            `🕐 Última execução: <strong>${apiStatus.last_run_at}</strong> (${apiStatus.api_calls_last_run || 0} requests)`;
    }
}

function showWelcomeState() {
    document.getElementById("welcome-state").style.display = "flex";
    document.getElementById("dashboard").style.display = "none";
    document.getElementById("badge-status").textContent = "● Aguardando";
    document.getElementById("badge-status").style.color = "var(--text-muted)";
    document.getElementById("badge-status").style.borderColor = "var(--border)";
}

function showDashboard() {
    document.getElementById("welcome-state").style.display = "none";
    document.getElementById("dashboard").style.display = "block";
}

// ═══════════════════════════════════════════
// LOAD CACHED DATA (sem rodar pipeline)
// ═══════════════════════════════════════════
async function loadCachedData() {
    try {
        const [statsRes, oppsRes, matchesRes, leaguesRes] = await Promise.all([
            fetch("/api/stats").then(r => r.json()),
            fetch("/api/opportunities").then(r => r.json()),
            fetch("/api/matches").then(r => r.json()),
            fetch("/api/leagues").then(r => r.json()),
        ]);

        if (statsRes.ok === false) {
            showWelcomeState();
            return;
        }

        stats = statsRes;
        allOpps = oppsRes;
        allMatches = matchesRes;
        allLeagues = leaguesRes;

        renderAll();
        showDashboard();
        
        document.getElementById("badge-status").textContent = "● PRONTO";
        document.getElementById("badge-status").style.color = "var(--accent-green)";
        document.getElementById("badge-status").style.borderColor = "var(--accent-green)";
        document.getElementById("btn-run").textContent = "⟳ Re-Executar";
    } catch(e) {
        console.error(e);
        showWelcomeState();
    }
}

// ═══════════════════════════════════════════
// LOAD DATA BY DATES (busca do Supabase)
// ═══════════════════════════════════════════
let _loadingByDates = false;
let _lastLoadedDates = '';  // Para evitar recarregar quando nada mudou

// Disparar busca de dados — chamada pelo botão 🔍 e pelo Enter nos date pickers
function _triggerDateLoad(force) {
    // Sincronizar header ↔ welcome
    document.getElementById("w-date-start").value = document.getElementById("date-start").value;
    document.getElementById("w-date-end").value = document.getElementById("date-end").value;

    const df = document.getElementById("date-start").value;
    const dt = document.getElementById("date-end").value;

    // Auto-ajustar: se date_from > date_to, ajustar date_to = date_from
    if (df && dt && df > dt) {
        document.getElementById("date-end").value = df;
        document.getElementById("w-date-end").value = df;
    }

    const finalDf = document.getElementById("date-start").value;
    const finalDt = document.getElementById("date-end").value;
    const key = `${finalDf}|${finalDt}`;

    // Só recarregar se as datas são válidas e (mudaram ou forçado)
    if (finalDf && finalDt && finalDf <= finalDt && (force || key !== _lastLoadedDates)) {
        _lastLoadedDates = key;
        loadDataByDates(finalDf, finalDt);
    }
}
async function loadDataByDates(dateFrom, dateTo) {
    if (_loadingByDates) return;
    _loadingByDates = true;
    _lastLoadedDates = `${dateFrom}|${dateTo}`;  // Marcar como carregado
    
    const badge = document.getElementById("badge-status");
    badge.textContent = "● CARREGANDO...";
    badge.style.color = "var(--accent-yellow)";
    badge.style.borderColor = "var(--accent-yellow)";
    
    // Visual feedback nos date pickers
    document.querySelectorAll('.date-picker-group').forEach(el => el.classList.add('loading'));
    
    try {
        const res = await fetch(`/api/load-by-dates?date_from=${dateFrom}&date_to=${dateTo}`);
        const data = await res.json();
        
        if (!data.ok) {
            console.error("Erro ao carregar por datas:", data.error);
            badge.textContent = "● ERRO";
            badge.style.color = "var(--accent-red)";
            badge.style.borderColor = "var(--accent-red)";
            return;
        }
        
        // Atualizar dados globais
        stats = data.stats;
        allOpps = data.opportunities;
        allMatches = data.matches;
        allLeagues = data.leagues;
        
        if (allOpps.length === 0 && allMatches.length === 0) {
            // Sem dados para essas datas — mostrar mensagem
            showDashboard();
            const tableBody = document.querySelector("#opp-table tbody");
            if (tableBody) tableBody.innerHTML = `<tr><td colspan="20" style="text-align:center;padding:40px;color:var(--text-muted)">
                <div style="font-size:32px;margin-bottom:12px">📅</div>
                <div style="font-size:14px;font-weight:600">Nenhum dado encontrado para ${dateFrom} → ${dateTo}</div>
                <div style="font-size:12px;margin-top:8px">Clique em <strong>▶ Executar</strong> ou <strong>📊 Análise Retroativa</strong> para buscar dados dessas datas.</div>
            </td></tr>`;
            
            // Atualizar stats
            const riDates = document.getElementById("ri-dates");
            if (riDates) riDates.textContent = `${dateFrom} → ${dateTo} (sem dados)`;
            
            // Limpar dashboard também
            dashboardLoaded = false;
            loadDashboard(true);
            
            badge.textContent = `● Sem dados (${dateFrom} → ${dateTo})`;
            badge.style.color = "var(--accent-yellow)";
            badge.style.borderColor = "var(--accent-yellow)";
        } else {
            // Renderizar normalmente
            renderAll();
            showDashboard();
            
            // Atualizar dashboard com os novos dados
            dashboardLoaded = false;  // Forçar repopulação dos filtros
            loadDashboard(true);
            
            badge.textContent = `● ${allOpps.length} opps (${dateFrom} → ${dateTo})`;
            badge.style.color = "var(--accent-green)";
            badge.style.borderColor = "var(--accent-green)";
        }
        
        console.log(`[LOAD-BY-DATES] ${allOpps.length} oportunidades, ${allMatches.length} jogos (${dateFrom} → ${dateTo})`);
    } catch(e) {
        console.error("Erro loadDataByDates:", e);
        badge.textContent = "● ERRO";
        badge.style.color = "var(--accent-red)";
        badge.style.borderColor = "var(--accent-red)";
    } finally {
        _loadingByDates = false;
        document.querySelectorAll('.date-picker-group').forEach(el => el.classList.remove('loading'));
    }
}

// ═══════════════════════════════════════════
// EXECUTE ENGINE (manual only)
// ═══════════════════════════════════════════
async function executeEngine(autoCheckResults) {
    if (engineRunning) return;
    
    const startDate = document.getElementById("date-start").value;
    const endDate = document.getElementById("date-end").value;
    const today = new Date().toISOString().slice(0,10);
    const isPastAnalysis = endDate < today;
    const nDays = Math.max(1, Math.round((new Date(endDate) - new Date(startDate)) / 86400000) + 1);
    const estRequests = nDays * 310;
    
    // Confirmar com o usuário
    const avail = apiStatus.available || "?";
    const modeMsg = isPastAnalysis 
        ? `📊 ANÁLISE RETROATIVA (${nDays} dia${nDays>1?'s':''})\n\nPeríodo: ${startDate} → ${endDate}\nOs jogos já finalizados serão incluídos.\n${autoCheckResults ? '✅ Resultados serão verificados automaticamente ao final.\n' : ''}`
        : `Executar pipeline de análise? (${nDays} dia${nDays>1?'s':''})\n\nPeríodo: ${startDate} → ${endDate}`;
    
    if (!confirm(`${modeMsg}\nCusto estimado: ~${estRequests} requests\nDisponíveis hoje: ${avail}\n\nIsso pode levar ${Math.max(3, nDays * 4)}-${Math.max(8, nDays * 8)} minutos.`)) {
        return;
    }
    
    engineRunning = true;
    
    // Mostrar progresso
    document.getElementById("progress-overlay").classList.add("show");
    document.getElementById("btn-run").disabled = true;
    document.getElementById("btn-run").classList.add("running");
    document.getElementById("btn-run").textContent = "⟳ Executando...";
    document.getElementById("badge-status").textContent = "● PROCESSANDO";
    document.getElementById("badge-status").style.color = "var(--accent-yellow)";
    document.getElementById("badge-status").style.borderColor = "var(--accent-yellow)";
    
    // Timer
    let seconds = 0;
    timerInterval = setInterval(() => {
        seconds++;
        const m = String(Math.floor(seconds / 60)).padStart(2, '0');
        const s = String(seconds % 60).padStart(2, '0');
        document.getElementById("progress-timer").textContent = `${m}:${s}`;
        
        // Update phase messages based on time
        const dateLabel = isPastAnalysis ? `[Retroativa ${startDate}→${endDate}] ` : '';
        if (seconds < 5) document.getElementById("progress-phase").textContent = dateLabel + "Verificando status da conta...";
        else if (seconds < 15) document.getElementById("progress-phase").textContent = dateLabel + `Buscando fixtures (${nDays} dia${nDays>1?'s':''})...`;
        else if (seconds < 60) document.getElementById("progress-phase").textContent = dateLabel + "Buscando standings de ligas...";
        else if (seconds < 180) document.getElementById("progress-phase").textContent = dateLabel + "Buscando odds reais de mercado...";
        else if (seconds < 300) document.getElementById("progress-phase").textContent = dateLabel + "Buscando dados de lesões...";
        else if (seconds < 360) document.getElementById("progress-phase").textContent = dateLabel + "Buscando clima (OpenWeatherMap)...";
        else if (seconds < 420) document.getElementById("progress-phase").textContent = dateLabel + "Executando modelos (Dixon-Coles + Monte Carlo)...";
        else document.getElementById("progress-phase").textContent = dateLabel + "Finalizando análise de valor...";
    }, 1000);

    try {
        const startDate = document.getElementById("date-start").value;
        const endDate = document.getElementById("date-end").value;
        const runRes = await fetch("/api/run", { 
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ start_date: startDate, end_date: endDate })
        });
        const runData = await runRes.json();
        
        clearInterval(timerInterval);
        
        if (!runData.ok) {
            alert("Erro ao executar: " + (runData.error || "desconhecido"));
            return;
        }

        // Carregar dados do Supabase com as mesmas datas
        await loadDataByDates(startDate, endDate);
        
        // Atualizar status da API
        try {
            const statusRes = await fetch("/api/status");
            apiStatus = await statusRes.json();
            updateApiQuotaDisplay();
        } catch(e) {}

        // Se é análise retroativa ou autoCheckResults, verificar resultados automaticamente
        if (isPastAnalysis || autoCheckResults) {
            document.getElementById("progress-phase").textContent = "⏳ Verificando resultados dos jogos finalizados...";
            document.getElementById("progress-overlay").classList.add("show");
            try {
                await checkResults(true);  // silencioso (não mostra alert)
            } catch(e2) {
                console.error("Erro ao verificar resultados:", e2);
            }
        }

    } catch (e) {
        clearInterval(timerInterval);
        console.error(e);
        alert("Erro: " + e.message);
    } finally {
        engineRunning = false;
        document.getElementById("progress-overlay").classList.remove("show");
        document.getElementById("btn-run").disabled = false;
        document.getElementById("btn-run").classList.remove("running");
        document.getElementById("btn-run").textContent = "⟳ Re-Executar";
        document.getElementById("badge-status").textContent = "● PRONTO";
        document.getElementById("badge-status").style.color = "var(--accent-green)";
        document.getElementById("badge-status").style.borderColor = "var(--accent-green)";
    }
}

async function recalculateEngine() {
    if (engineRunning) return;

    if (!confirm('Recalcular modelos e oportunidades usando dados já em cache?\n\n✅ ZERO requisições à API (0 créditos)\n✅ Aplica novos mercados (finalizações, etc.)\n✅ Recalcula todas as probabilidades\n\n⏱️ Estimativa: 15-60 segundos')) {
        return;
    }

    engineRunning = true;

    // Mostrar progresso
    document.getElementById("progress-overlay").classList.add("show");
    document.getElementById("btn-run").disabled = true;
    document.getElementById("btn-recalc").disabled = true;
    document.getElementById("badge-status").textContent = "● RECALCULANDO";
    document.getElementById("badge-status").style.color = "var(--accent-blue)";
    document.getElementById("badge-status").style.borderColor = "var(--accent-blue)";

    let seconds = 0;
    timerInterval = setInterval(() => {
        seconds++;
        const m = String(Math.floor(seconds / 60)).padStart(2, '0');
        const s = String(seconds % 60).padStart(2, '0');
        document.getElementById("progress-timer").textContent = `${m}:${s}`;

        if (seconds < 3) document.getElementById("progress-phase").textContent = "Carregando dados do cache...";
        else if (seconds < 10) document.getElementById("progress-phase").textContent = "Reconstruindo partidas...";
        else if (seconds < 30) document.getElementById("progress-phase").textContent = "Executando modelos (Dixon-Coles + Finalizações)...";
        else if (seconds < 50) document.getElementById("progress-phase").textContent = "Escaneando oportunidades +EV...";
        else document.getElementById("progress-phase").textContent = "Salvando resultados...";
    }, 1000);

    try {
        const res = await fetch("/api/recalculate", { method: "POST" });
        const data = await res.json();

        clearInterval(timerInterval);

        if (!data.ok) {
            alert("Erro ao recalcular: " + (data.error || "desconhecido"));
            return;
        }

        // Recarregar dados do Supabase
        const curDf = document.getElementById("date-start").value;
        const curDt = document.getElementById("date-end").value;
        if (curDf && curDt) {
            await loadDataByDates(curDf, curDt);
        }

        alert(`✅ Recalculo concluido!\n\n${data.total_opportunities} oportunidades encontradas\n0 requisicoes a API`);

    } catch (e) {
        clearInterval(timerInterval);
        console.error(e);
        alert("Erro: " + e.message);
    } finally {
        engineRunning = false;
        document.getElementById("progress-overlay").classList.remove("show");
        document.getElementById("btn-run").disabled = false;
        document.getElementById("btn-recalc").disabled = false;
        document.getElementById("badge-status").textContent = "● PRONTO";
        document.getElementById("badge-status").style.color = "var(--accent-green)";
        document.getElementById("badge-status").style.borderColor = "var(--accent-green)";
    }
}

// ═══════════════════════════════════════════
// EXPORTAR EXCEL — Exporta dados visíveis em tela
// ═══════════════════════════════════════════
function exportToExcel() {
    const btn = document.getElementById("btn-export");
    if (!btn) return;
    btn.disabled = true;
    btn.textContent = "⏳ Gerando...";

    try {
        // Pegar as oportunidades atualmente filtradas/visíveis na tabela
        const rows = document.querySelectorAll("#opp-table tbody tr");
        if (!rows.length) {
            alert("Nenhuma oportunidade visível para exportar.");
            btn.disabled = false;
            btn.textContent = "📥 Exportar Excel";
            return;
        }

        // Construir dados para exportação a partir de allOpps (respeitando filtros atuais)
        // Pegar IDs visíveis pela tabela (cada tr tem onclick com índice)
        const exportData = [];
        
        // Filtrar as mesmas oportunidades que estão visíveis
        const team = (document.getElementById('cf-team')?.value || '').toLowerCase();
        const leagueFilter = msRegistry['cf-league'] ? msRegistry['cf-league'].getSelected() : [];
        const dtStartRaw = document.getElementById('cf-dt-start')?.value || '';
        const dtEndRaw = document.getElementById('cf-dt-end')?.value || '';
        const dtStart = dtStartRaw ? new Date(dtStartRaw) : null;
        const dtEnd = dtEndRaw ? new Date(dtEndRaw) : null;
        const gameStatusFilter = msRegistry['cf-game-status'] ? msRegistry['cf-game-status'].getSelected() : [];
        const resultFilter = msRegistry['cf-result'] ? msRegistry['cf-result'].getSelected() : [];
        const marketFilter = msRegistry['cf-market'] ? msRegistry['cf-market'].getSelected() : [];
        const selectionFilter = msRegistry['cf-selection'] ? msRegistry['cf-selection'].getSelected() : [];
        const oddMin = parseFloat(document.getElementById('cf-odd-min')?.value) || null;
        const oddMax = parseFloat(document.getElementById('cf-odd-max')?.value) || null;
        const fairOddMin = parseFloat(document.getElementById('cf-fair-odd-min')?.value) || null;
        const fairOddMax = parseFloat(document.getElementById('cf-fair-odd-max')?.value) || null;
        const edgeMin = parseFloat(document.getElementById('cf-edge-min')?.value) || null;
        const edgeMax = parseFloat(document.getElementById('cf-edge-max')?.value) || null;
        const probMin = parseFloat(document.getElementById('cf-prob-min')?.value) || null;
        const probMax = parseFloat(document.getElementById('cf-prob-max')?.value) || null;
        const confidenceFilter = msRegistry['cf-confidence'] ? msRegistry['cf-confidence'].getSelected() : [];
        const scoreMin = parseFloat(document.getElementById('cf-score-min')?.value) || null;
        const scoreMax = parseFloat(document.getElementById('cf-score-max')?.value) || null;
        const analysisTypeFilter = msRegistry['cf-analysis-type'] ? msRegistry['cf-analysis-type'].getSelected() : [];

        let filtered = allOpps.filter(o => {
            if (team && !(o.home_team.toLowerCase().includes(team) || o.away_team.toLowerCase().includes(team))) return false;
            if (leagueFilter.length && !leagueFilter.includes(o.league_name)) return false;
            if (dtStart || dtEnd) {
                const timeParts = (o.match_time || '00:00').split(':');
                const dateParts = (o.match_date || '').split('-');
                if (dateParts.length >= 3) {
                    const matchDt = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]), parseInt(timeParts[0]) || 0, parseInt(timeParts[1]) || 0, 0);
                    if (dtStart && matchDt < dtStart) return false;
                    if (dtEnd && matchDt > dtEnd) return false;
                }
            }
            if (gameStatusFilter.length) {
                const gs = getGameStatus(o.match_date, o.match_time);
                if (!gameStatusFilter.includes(gs.status)) return false;
            }
            if (resultFilter.length && !resultFilter.includes(o.result_status || 'PENDENTE')) return false;
            if (marketFilter.length && !marketFilter.some(m => o.market.includes(m))) return false;
            if (selectionFilter.length && !selectionFilter.includes(o.selection)) return false;
            if (oddMin !== null && o.market_odd < oddMin) return false;
            if (oddMax !== null && o.market_odd > oddMax) return false;
            if (fairOddMin !== null && (o.fair_odd || 0) < fairOddMin) return false;
            if (fairOddMax !== null && (o.fair_odd || 0) > fairOddMax) return false;
            if (edgeMin !== null && o.edge < edgeMin) return false;
            if (edgeMax !== null && o.edge > edgeMax) return false;
            if (probMin !== null && o.model_prob < probMin) return false;
            if (probMax !== null && o.model_prob > probMax) return false;
            if (confidenceFilter.length && !confidenceFilter.includes(o.confidence)) return false;
            if (scoreMin !== null && (o.confidence_score || 0) < scoreMin) return false;
            if (scoreMax !== null && (o.confidence_score || 0) > scoreMax) return false;
            if (analysisTypeFilter.length && !analysisTypeFilter.includes(o.analysis_type || 'PRE_JOGO')) return false;
            return true;
        });

        // Aplicar mesma ordenação
        filtered.sort((a, b) => {
            const va = getSortValue(a, currentSort.key);
            const vb = getSortValue(b, currentSort.key);
            let cmp = 0;
            if (typeof va === 'number' && typeof vb === 'number') cmp = va - vb;
            else cmp = String(va).localeCompare(String(vb));
            return currentSort.dir === 'asc' ? cmp : -cmp;
        });

        // Calcular P&L para cada
        function calcPnl(status, odd) {
            if (status === 'GREEN') return parseFloat((odd - 1).toFixed(2));
            if (status === 'RED') return -1;
            if (status === 'VOID') return 0;
            return null;
        }

        // Montar linhas do Excel
        filtered.forEach((o, i) => {
            const gs = getGameStatus(o.match_date, o.match_time);
            const pnl = calcPnl(o.result_status, o.market_odd);
            const m = allMatches.find(x => x.match_id === o.match_id);

            exportData.push({
                "#": i + 1,
                "Data": o.match_date,
                "Hora": o.match_time,
                "Status Jogo": gs.label,
                "Time Casa": o.home_team,
                "Time Fora": o.away_team,
                "Liga": o.league_name,
                "País": o.league_country,
                "Mercado": o.market,
                "Seleção": o.selection,
                "Odd Casa": o.market_odd,
                "Odd Justa": o.fair_odd,
                "Prob. Modelo (%)": o.model_prob,
                "Prob. Implícita (%)": o.implied_prob,
                "Edge (%)": o.edge,
                "Edge Detalhado": o.edge_pct,
                "Confiança": o.confidence,
                "Score Confiança": o.confidence_score || 0,
                "Tipo Análise": o.analysis_type || "PRE_JOGO",
                "Kelly": o.kelly_bet_pct,
                "xG Casa": o.home_xg,
                "xG Fora": o.away_xg,
                "Resultado": o.result_status || "PENDENTE",
                "Placar FT": o.result_score || "",
                "Placar HT": o.result_ht_score || "",
                "Escanteios": o.result_corners || "",
                "Cartões": o.result_cards || "",
                "Finalizações": o.result_shots || "",
                "P&L (u)": pnl !== null ? pnl : "",
                "Bookmaker": o.bookmaker || "",
                "Reasoning": o.reasoning || "",
                "Clima": o.weather_note || "",
                "Fadiga": o.fatigue_note || "",
                "Urgência Casa": o.urgency_home,
                "Urgência Fora": o.urgency_away,
                "Match ID": o.match_id,
            });
        });

        // Gerar Excel usando SheetJS
        const ws = XLSX.utils.json_to_sheet(exportData);

        // Ajustar larguras das colunas
        const colWidths = [
            { wch: 5 },  // #
            { wch: 12 }, // Data
            { wch: 6 },  // Hora
            { wch: 12 }, // Status Jogo
            { wch: 22 }, // Time Casa
            { wch: 22 }, // Time Fora
            { wch: 25 }, // Liga
            { wch: 12 }, // País
            { wch: 25 }, // Mercado
            { wch: 20 }, // Seleção
            { wch: 10 }, // Odd Casa
            { wch: 10 }, // Odd Justa
            { wch: 12 }, // Prob Modelo
            { wch: 13 }, // Prob Implícita
            { wch: 10 }, // Edge
            { wch: 10 }, // Edge Det
            { wch: 10 }, // Confiança
            { wch: 10 }, // Kelly
            { wch: 8 },  // xG Casa
            { wch: 8 },  // xG Fora
            { wch: 11 }, // Resultado
            { wch: 10 }, // Placar FT
            { wch: 10 }, // Placar HT
            { wch: 10 }, // Escanteios
            { wch: 10 }, // Cartões
            { wch: 12 }, // Finalizações
            { wch: 10 }, // P&L
            { wch: 12 }, // Bookmaker
            { wch: 50 }, // Reasoning
            { wch: 20 }, // Clima
            { wch: 20 }, // Fadiga
            { wch: 11 }, // Urgência Casa
            { wch: 11 }, // Urgência Fora
            { wch: 12 }, // Match ID
        ];
        ws['!cols'] = colWidths;

        const wb = XLSX.utils.book_new();
        
        // Aba 1: Oportunidades
        XLSX.utils.book_append_sheet(wb, ws, "Oportunidades");

        // Aba 2: Resumo por Data
        const dateGroups = {};
        filtered.forEach(o => {
            const d = o.match_date;
            if (!dateGroups[d]) dateGroups[d] = { total: 0, green: 0, red: 0, void_: 0, pending: 0, profit: 0 };
            dateGroups[d].total++;
            const pnl = calcPnl(o.result_status, o.market_odd);
            if (o.result_status === 'GREEN') { dateGroups[d].green++; dateGroups[d].profit += pnl; }
            else if (o.result_status === 'RED') { dateGroups[d].red++; dateGroups[d].profit += pnl; }
            else if (o.result_status === 'VOID') { dateGroups[d].void_++; }
            else { dateGroups[d].pending++; }
        });
        const dateRows = Object.entries(dateGroups).sort(([a],[b]) => a.localeCompare(b)).map(([date, g]) => ({
            "Data": date,
            "Total": g.total,
            "Green": g.green,
            "Red": g.red,
            "Void": g.void_,
            "Pendente": g.pending,
            "Resolvidas": g.green + g.red + g.void_,
            "Taxa Acerto (%)": g.green + g.red > 0 ? parseFloat(((g.green / (g.green + g.red)) * 100).toFixed(1)) : "",
            "P&L (u)": parseFloat(g.profit.toFixed(2)),
            "ROI (%)": g.green + g.red > 0 ? parseFloat(((g.profit / (g.green + g.red)) * 100).toFixed(1)) : "",
        }));
        
        // Totais
        const totalG = filtered.filter(o => o.result_status === 'GREEN').length;
        const totalR = filtered.filter(o => o.result_status === 'RED').length;
        const totalV = filtered.filter(o => o.result_status === 'VOID').length;
        const totalPend = filtered.filter(o => !o.result_status || o.result_status === 'PENDENTE').length;
        const totalProfit = filtered.reduce((s, o) => s + (calcPnl(o.result_status, o.market_odd) || 0), 0);
        dateRows.push({
            "Data": "TOTAL",
            "Total": filtered.length,
            "Green": totalG,
            "Red": totalR,
            "Void": totalV,
            "Pendente": totalPend,
            "Resolvidas": totalG + totalR + totalV,
            "Taxa Acerto (%)": totalG + totalR > 0 ? parseFloat(((totalG / (totalG + totalR)) * 100).toFixed(1)) : "",
            "P&L (u)": parseFloat(totalProfit.toFixed(2)),
            "ROI (%)": totalG + totalR > 0 ? parseFloat(((totalProfit / (totalG + totalR)) * 100).toFixed(1)) : "",
        });

        const ws2 = XLSX.utils.json_to_sheet(dateRows);
        ws2['!cols'] = [{ wch: 12 }, { wch: 8 }, { wch: 8 }, { wch: 8 }, { wch: 8 }, { wch: 10 }, { wch: 12 }, { wch: 14 }, { wch: 10 }, { wch: 10 }];
        XLSX.utils.book_append_sheet(wb, ws2, "Resumo por Data");

        // Aba 3: Resumo por Mercado
        const mktGroups = {};
        filtered.forEach(o => {
            const k = o.market;
            if (!mktGroups[k]) mktGroups[k] = { total: 0, green: 0, red: 0, profit: 0 };
            mktGroups[k].total++;
            const pnl = calcPnl(o.result_status, o.market_odd);
            if (o.result_status === 'GREEN') { mktGroups[k].green++; mktGroups[k].profit += pnl; }
            else if (o.result_status === 'RED') { mktGroups[k].red++; mktGroups[k].profit += pnl; }
        });
        const mktRows = Object.entries(mktGroups).sort(([,a],[,b]) => (b.profit - a.profit)).map(([mkt, g]) => ({
            "Mercado": mkt,
            "Total": g.total,
            "Green": g.green,
            "Red": g.red,
            "Taxa Acerto (%)": g.green + g.red > 0 ? parseFloat(((g.green / (g.green + g.red)) * 100).toFixed(1)) : "",
            "P&L (u)": parseFloat(g.profit.toFixed(2)),
            "ROI (%)": g.green + g.red > 0 ? parseFloat(((g.profit / (g.green + g.red)) * 100).toFixed(1)) : "",
        }));
        const ws3 = XLSX.utils.json_to_sheet(mktRows);
        ws3['!cols'] = [{ wch: 30 }, { wch: 8 }, { wch: 8 }, { wch: 8 }, { wch: 14 }, { wch: 10 }, { wch: 10 }];
        XLSX.utils.book_append_sheet(wb, ws3, "Resumo por Mercado");

        // Aba 4: Resumo por Seleção
        const selGroups = {};
        filtered.forEach(o => {
            const k = o.selection;
            if (!selGroups[k]) selGroups[k] = { total: 0, green: 0, red: 0, profit: 0 };
            selGroups[k].total++;
            const pnl = calcPnl(o.result_status, o.market_odd);
            if (o.result_status === 'GREEN') { selGroups[k].green++; selGroups[k].profit += pnl; }
            else if (o.result_status === 'RED') { selGroups[k].red++; selGroups[k].profit += pnl; }
        });
        const selRows = Object.entries(selGroups).sort(([,a],[,b]) => (b.profit - a.profit)).map(([sel, g]) => ({
            "Seleção": sel,
            "Total": g.total,
            "Green": g.green,
            "Red": g.red,
            "Taxa Acerto (%)": g.green + g.red > 0 ? parseFloat(((g.green / (g.green + g.red)) * 100).toFixed(1)) : "",
            "P&L (u)": parseFloat(g.profit.toFixed(2)),
            "ROI (%)": g.green + g.red > 0 ? parseFloat(((g.profit / (g.green + g.red)) * 100).toFixed(1)) : "",
        }));
        const ws4 = XLSX.utils.json_to_sheet(selRows);
        ws4['!cols'] = [{ wch: 25 }, { wch: 8 }, { wch: 8 }, { wch: 8 }, { wch: 14 }, { wch: 10 }, { wch: 10 }];
        XLSX.utils.book_append_sheet(wb, ws4, "Resumo por Seleção");

        // Nome do arquivo com datas
        const dateStart = document.getElementById("date-start")?.value || "export";
        const dateFim = document.getElementById("date-end")?.value || "";
        const fileName = `ApostasIA_${dateStart}_${dateFim}_${filtered.length}opps.xlsx`;
        
        XLSX.writeFile(wb, fileName);

        btn.textContent = `✅ Exportado! (${filtered.length} linhas)`;
        setTimeout(() => { btn.textContent = "📥 Exportar Excel"; }, 3000);
    } catch (err) {
        console.error("Erro ao exportar:", err);
        alert("Erro ao gerar Excel: " + err.message);
        btn.textContent = "📥 Exportar Excel";
    } finally {
        btn.disabled = false;
    }
}

// ═══════════════════════════════════════════
// CHECK RESULTS — Verificar jogos finalizados
// ═══════════════════════════════════════════
async function checkResults(silent) {
    const btn = document.getElementById("btn-check-results");
    btn.disabled = true;
    
    // Timer de progresso visual
    const startTime = Date.now();
    let timerInterval;
    const phases = [
        { t: 0, text: "Buscando oportunidades pendentes..." },
        { t: 3, text: "Filtrando jogos encerrados (>120min)..." },
        { t: 6, text: "Consultando resultados na API..." },
        { t: 15, text: "Processando resultados (pode levar alguns minutos)..." },
        { t: 45, text: "Ainda processando jogos... Quase lá!" },
        { t: 120, text: "Muitos jogos a processar... Aguarde..." },
    ];
    
    timerInterval = setInterval(() => {
        const elapsed = Math.round((Date.now() - startTime) / 1000);
        const mins = Math.floor(elapsed / 60);
        const secs = elapsed % 60;
        const timeStr = mins > 0 ? `${mins}m${String(secs).padStart(2,'0')}s` : `${secs}s`;
        
        // Fase atual baseada no tempo
        let phase = phases[0].text;
        for (let i = phases.length - 1; i >= 0; i--) {
            if (elapsed >= phases[i].t) { phase = phases[i].text; break; }
        }
        
        btn.innerHTML = `⏳ ${timeStr} <span style="font-size:9px;opacity:0.8;display:block">${phase}</span>`;
    }, 500);
    
    try {
        const res = await fetch("/api/check-results", { method: "POST" });
        const data = await res.json();
        clearInterval(timerInterval);
        
        const elapsed = Math.round((Date.now() - startTime) / 1000);
        const elapsedStr = elapsed > 60 ? `${Math.floor(elapsed/60)}m${elapsed%60}s` : `${elapsed}s`;
        
        if (!data.ok) {
            if (!silent) alert("Erro: " + (data.error || "desconhecido"));
            return;
        }
        
        // Mostrar resultado detalhado (apenas se não for silencioso)
        if (!silent) {
            let msg = `✅ Verificação concluída em ${elapsedStr}\n\n`;
            msg += `📋 Total pendentes: ${data.total_pending || 0}\n`;
            msg += `⏭ Ignorados (ainda em jogo/futuro): ${data.skipped_not_finished || 0}\n`;
            msg += `🔍 Jogos consultados (encerrados): ${data.checked}\n`;
            msg += `📊 Jogos com resultado: ${data.finished}\n`;
            msg += `✏️ Oportunidades resolvidas: ${data.resolved}\n`;
            if (data.resolved > 0) {
                msg += `\n🟢 GREEN: ${data.green}\n🔴 RED: ${data.red}\n⬜ VOID: ${data.void || 0}`;
            }
            if (data.resolved === 0 && data.checked === 0) {
                msg += `\nℹ️ ${data.msg || 'Nenhum jogo encerrado para verificar.'}`;
            }
            alert(msg);
        } else {
            // Modo silencioso: exibir resumo no console e no botão
            const summary = `G:${data.green||0} R:${data.red||0} (${data.resolved||0} resolvidas)`;
            console.log(`[CHECK-RESULTS] ${summary}`);
        }
        
        // Recarregar dados para mostrar resultados atualizados na tabela
        btn.innerHTML = "🔄 Atualizando tabela...";
        const curDf = document.getElementById("date-start").value;
        const curDt = document.getElementById("date-end").value;
        if (curDf && curDt) {
            await loadDataByDates(curDf, curDt);
        } else {
            await loadCachedData();
            loadDashboard(true);
        }
        
    } catch (e) {
        clearInterval(timerInterval);
        console.error(e);
        if (!silent) alert("Erro de conexão: " + e.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = "✅ Resultados";
    }
}

// ═══════════════════════════════════════════
// DASHBOARD — FULL REDESIGN WITH CLIENT-SIDE FILTERS
// ═══════════════════════════════════════════
let dashboardRawData = null;  // { resolved: [...], pending_count: N }
let dashboardLoaded = false;

async function loadDashboard(forceReload) {
    // Dashboard agora usa os mesmos dados da tela principal (allOpps)
    // Isso garante 100% de consistência entre as telas
    if (!allOpps || !allOpps.length) {
        const container = document.getElementById("dashboard-content");
        container.innerHTML = '<div style="text-align:center;padding:60px;color:var(--text-muted)"><div style="font-size:48px;margin-bottom:16px">📊</div><div style="font-size:15px">Nenhum dado carregado ainda.<br>Execute uma análise primeiro.</div></div>';
        return;
    }

    // Montar dashboardRawData a partir de allOpps (mesma fonte da tela principal)
    const resolved = allOpps.filter(o => ['GREEN', 'RED', 'VOID'].includes(o.result_status));
    const pendingCount = allOpps.filter(o => !o.result_status || o.result_status === 'PENDENTE').length;
    dashboardRawData = { resolved, pending_count: pendingCount, all: allOpps };
    
    if (!dashboardLoaded || forceReload) {
        populateDashboardFilters(allOpps);  // Usar TODOS para popular filtros (não só resolvidas)
        dashboardLoaded = true;
    }

    // Apply pending sync if any
    if (_pendingSync === 'mainToDash') {
        _pendingSync = null;
        syncFiltersMainToDash();  // this calls applyDashboardFilters internally
    } else {
        applyDashboardFilters();
    }
}

function populateDashboardFilters(items) {
    const uniq = (arr) => [...new Set(arr)].filter(Boolean).sort();
    const markets = uniq(items.map(o => o.market));
    const selections = uniq(items.map(o => o.selection));
    const confidences = uniq(items.map(o => o.confidence));
    const countries = uniq(items.map(o => o.league_country));
    const leagues = uniq(items.map(o => o.league_name));
    const initMs = (id, placeholder, items) => {
        if (!msRegistry[id]) {
            msRegistry[id] = new MultiSelect(id, { placeholder, onChange: () => applyDashboardFilters() });
        }
        msRegistry[id].setItems(items);
    };

    initMs('df-market', 'Todos', markets);
    initMs('df-selection', 'Todas', selections);
    initMs('df-confidence', 'Todas', confidences);
    initMs('df-country', 'Todos', countries);
    initMs('df-league', 'Todas', leagues);

    const analysisTypes = uniq(items.map(o => o.analysis_type || 'PRE_JOGO'));
    initMs('df-analysis-type', 'Todos', analysisTypes);
}

function clearDashboardFilters() {
    ['df-date-start','df-date-end','df-odd-min','df-odd-max','df-fair-odd-min','df-fair-odd-max','df-edge-min','df-edge-max'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = '';
    });
    // Reset all dashboard multi-selects
    ['df-market','df-selection','df-confidence','df-country','df-league','df-analysis-type'].forEach(id => {
        if (msRegistry[id]) msRegistry[id].reset();
    });
    applyDashboardFilters();
}

function applyDashboardFilters() {
    if (!dashboardRawData) return;
    // Usar TODOS os dados (allOpps) como base
    const allData = dashboardRawData.all || allOpps || [];
    
    // Read filter values — multi-selects return [] if all/none selected
    const dateStart = document.getElementById('df-date-start')?.value || '';
    const dateEnd = document.getElementById('df-date-end')?.value || '';
    const marketFilter = msRegistry['df-market'] ? msRegistry['df-market'].getSelected() : [];
    const selectionFilter = msRegistry['df-selection'] ? msRegistry['df-selection'].getSelected() : [];
    const confidenceFilter = msRegistry['df-confidence'] ? msRegistry['df-confidence'].getSelected() : [];
    const countryFilter = msRegistry['df-country'] ? msRegistry['df-country'].getSelected() : [];
    const leagueFilter = msRegistry['df-league'] ? msRegistry['df-league'].getSelected() : [];
    const analysisTypeFilter = msRegistry['df-analysis-type'] ? msRegistry['df-analysis-type'].getSelected() : [];
    const oddMin = parseFloat(document.getElementById('df-odd-min')?.value) || null;
    const oddMax = parseFloat(document.getElementById('df-odd-max')?.value) || null;
    const fairOddMin = parseFloat(document.getElementById('df-fair-odd-min')?.value) || null;
    const fairOddMax = parseFloat(document.getElementById('df-fair-odd-max')?.value) || null;
    const edgeMin = parseFloat(document.getElementById('df-edge-min')?.value) || null;
    const edgeMax = parseFloat(document.getElementById('df-edge-max')?.value) || null;

    const hasFilter = dateStart || dateEnd || marketFilter.length || selectionFilter.length || confidenceFilter.length || countryFilter.length || leagueFilter.length || analysisTypeFilter.length || oddMin || oddMax || fairOddMin || fairOddMax || edgeMin || edgeMax;

    // Filter ALL data (resolved + pending)
    const filtered = allData.filter(o => {
        if (dateStart && (o.match_date || '') < dateStart) return false;
        if (dateEnd && (o.match_date || '') > dateEnd) return false;
        if (marketFilter.length && !marketFilter.includes(o.market)) return false;
        if (selectionFilter.length && !selectionFilter.includes(o.selection)) return false;
        if (confidenceFilter.length && !confidenceFilter.includes(o.confidence)) return false;
        if (countryFilter.length && !countryFilter.includes(o.league_country)) return false;
        if (leagueFilter.length && !leagueFilter.includes(o.league_name)) return false;
        if (analysisTypeFilter.length && !analysisTypeFilter.includes(o.analysis_type || 'PRE_JOGO')) return false;
        if (oddMin && (o.market_odd || 0) < oddMin) return false;
        if (oddMax && (o.market_odd || 0) > oddMax) return false;
        if (fairOddMin && (o.fair_odd || 0) < fairOddMin) return false;
        if (fairOddMax && (o.fair_odd || 0) > fairOddMax) return false;
        if (edgeMin && (o.edge || 0) < edgeMin) return false;
        if (edgeMax && (o.edge || 0) > edgeMax) return false;
        return true;
    });

    // Separar resolvidas e pendentes dos dados filtrados
    const resolvedFiltered = filtered.filter(o => ['GREEN', 'RED', 'VOID'].includes(o.result_status));
    const pendingFiltered = filtered.filter(o => !o.result_status || o.result_status === 'PENDENTE');

    // Show filter summary
    const summaryEl = document.getElementById('dash-filter-summary');
    if (summaryEl) {
        if (hasFilter) {
            summaryEl.className = 'dash-filter-summary active';
            summaryEl.innerHTML = `🔍 Filtro ativo: <strong>${filtered.length}</strong> de ${allData.length} oportunidades (${resolvedFiltered.length} resolvidas, ${pendingFiltered.length} pendentes)`;
        } else {
            summaryEl.className = 'dash-filter-summary';
        }
    }

    renderDashboard(resolvedFiltered, pendingFiltered.length, filtered.length);
}

// ═══════════════════════════════════════════
// DASHBOARD — RENDER (completely new)
// ═══════════════════════════════════════════
function renderDashboard(items, pendingCount, totalAll) {
    const container = document.getElementById("dashboard-content");
    if (!container) return;
    
    if (!items.length) {
        container.innerHTML = '<div style="text-align:center;padding:60px;color:var(--text-muted)"><div style="font-size:48px;margin-bottom:16px">🔍</div><div style="font-size:15px">Nenhuma oportunidade corresponde aos filtros selecionados.</div></div>';
        return;
    }

    // ── Compute stats ──
    const greens = items.filter(o => o.result_status === 'GREEN');
    const reds = items.filter(o => o.result_status === 'RED');
    const voids = items.filter(o => o.result_status === 'VOID');
    const decided = greens.length + reds.length;
    const hitRate = decided > 0 ? (greens.length / decided * 100).toFixed(1) : 0;
    const profitGreens = greens.reduce((s, o) => s + ((o.market_odd || 0) - 1), 0);
    const profitTotal = profitGreens - reds.length;
    const roi = decided > 0 ? (profitTotal / decided * 100).toFixed(1) : 0;
    const avgOdd = items.length > 0 ? (items.reduce((s, o) => s + (o.market_odd || 0), 0) / items.length).toFixed(2) : 0;
    const avgEdge = items.length > 0 ? (items.reduce((s, o) => s + (o.edge || 0), 0) / items.length).toFixed(1) : 0;

    const hitColor = (hr) => hr >= 55 ? 'var(--accent-green)' : hr >= 45 ? 'var(--accent-yellow)' : 'var(--accent-red)';
    const sign = (v) => v >= 0 ? '+' : '';
    const pc = (v) => v >= 0 ? 'profit-positive' : 'profit-negative';

    let html = '';

    // ═══════════════════════════════
    // KPI CARDS (5 cols)
    // ═══════════════════════════════
    html += `<div class="dash-kpi-grid">
        <div class="dash-kpi kpi-blue">
            <div class="dash-kpi-icon">📊</div>
            <div class="dash-kpi-label">Resolvidas</div>
            <div class="dash-kpi-val" style="color:var(--accent-blue)">${items.length}</div>
            <div class="dash-kpi-sub">${decided} decididas · ${voids.length} void · ${pendingCount} pend.</div>
        </div>
        <div class="dash-kpi kpi-green">
            <div class="dash-kpi-icon">🎯</div>
            <div class="dash-kpi-label">Taxa de Acerto</div>
            <div class="dash-kpi-val" style="color:${hitColor(hitRate)}">${hitRate}%</div>
            <div class="dash-kpi-sub">${greens.length} GREEN · ${reds.length} RED</div>
        </div>
        <div class="dash-kpi ${profitTotal >= 0 ? 'kpi-green' : 'kpi-red'}">
            <div class="dash-kpi-icon">💰</div>
            <div class="dash-kpi-label">Lucro / Prejuízo</div>
            <div class="dash-kpi-val ${pc(profitTotal)}">${sign(profitTotal)}${profitTotal.toFixed(2)}u</div>
            <div class="dash-kpi-sub">+${profitGreens.toFixed(2)}u ganhos · -${reds.length}.00u perdas</div>
        </div>
        <div class="dash-kpi ${parseFloat(roi) >= 0 ? 'kpi-green' : 'kpi-red'}">
            <div class="dash-kpi-icon">📈</div>
            <div class="dash-kpi-label">ROI</div>
            <div class="dash-kpi-val ${pc(parseFloat(roi))}">${sign(parseFloat(roi))}${roi}%</div>
            <div class="dash-kpi-sub">Investido: ${decided}u · Retorno: ${(decided + profitTotal).toFixed(2)}u</div>
        </div>
        <div class="dash-kpi kpi-purple">
            <div class="dash-kpi-icon">⚡</div>
            <div class="dash-kpi-label">Odds / Edge Médio</div>
            <div class="dash-kpi-val" style="color:var(--accent-purple);font-size:22px">${avgOdd} / ${avgEdge}%</div>
            <div class="dash-kpi-sub">Média de todas as oportunidades</div>
        </div>
    </div>`;

    // ═══════════════════════════════
    // DONUT + CHART ROW
    // ═══════════════════════════════
    const greenPct = decided > 0 ? (greens.length / decided * 100) : 0;
    const redPct = decided > 0 ? (reds.length / decided * 100) : 0;
    const voidPct = items.length > 0 ? (voids.length / items.length * 100) : 0;

    // SVG Donut
    const donutSvg = _buildDonutSVG(greenPct, redPct, hitRate);

    // Build accumulated profit chart
    const chartSvg = _buildProfitChart(items);

    html += `<div class="dash-main-row">
        <div class="dash-donut-card">
            <div style="font-size:12px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:16px">Distribuição de Resultados</div>
            ${donutSvg}
            <div class="dash-donut-legend-row">
                <div class="dash-donut-legend-item"><div class="dash-legend-dot" style="background:var(--accent-green)"></div><strong class="txt-green">${greens.length}</strong> <span class="txt-muted">G (${greenPct.toFixed(0)}%)</span></div>
                <div class="dash-donut-legend-item"><div class="dash-legend-dot" style="background:var(--accent-red)"></div><strong class="txt-red">${reds.length}</strong> <span class="txt-muted">R (${redPct.toFixed(0)}%)</span></div>
                <div class="dash-donut-legend-item"><div class="dash-legend-dot" style="background:var(--text-muted)"></div><strong class="txt-muted">${voids.length}</strong> <span class="txt-muted">V</span></div>
            </div>
        </div>
        <div class="dash-chart">
            <div class="dash-chart-title">📈 Lucro Acumulado por Data</div>
            ${chartSvg}
        </div>
    </div>`;

    // ═══════════════════════════════
    // BREAKDOWN TABLES
    // ═══════════════════════════════
    const groupBy = (arr, keyFn) => {
        const map = {};
        arr.forEach(o => { const k = keyFn(o) || '?'; if (!map[k]) map[k] = []; map[k].push(o); });
        return Object.entries(map).map(([label, items]) => {
            const g = items.filter(x => x.result_status === 'GREEN');
            const r = items.filter(x => x.result_status === 'RED');
            const d = g.length + r.length;
            const hr = d > 0 ? (g.length / d * 100).toFixed(1) : 0;
            const pft = g.reduce((s, x) => s + ((x.market_odd||0)-1), 0) - r.length;
            const roiV = d > 0 ? (pft / d * 100).toFixed(1) : 0;
            return { label, total: items.length, green: g.length, red: r.length, hit_rate: parseFloat(hr), profit: Math.round(pft*100)/100, roi: parseFloat(roiV) };
        }).sort((a, b) => b.roi - a.roi || b.profit - a.profit);
    };

    const edgeRange = (o) => {
        const e = o.edge || 0;
        if (e < 3) return '0-3%';
        if (e < 5) return '3-5%';
        if (e < 10) return '5-10%';
        if (e < 20) return '10-20%';
        if (e < 50) return '20-50%';
        return '50%+';
    };
    const oddsRange = (o) => {
        const odd = o.market_odd || 0;
        if (odd < 1.3) return '1.00-1.30';
        if (odd < 1.5) return '1.30-1.50';
        if (odd < 1.8) return '1.50-1.80';
        if (odd < 2.0) return '1.80-2.00';
        if (odd < 2.5) return '2.00-2.50';
        if (odd < 3.0) return '2.50-3.00';
        if (odd < 5.0) return '3.00-5.00';
        return '5.00+';
    };

    const byMarket = groupBy(items, o => o.market);
    const byConfidence = groupBy(items, o => o.confidence);
    const byEdge = groupBy(items, edgeRange);
    const byOdds = groupBy(items, oddsRange);
    const byCountry = groupBy(items, o => o.league_country);
    const bySelection = groupBy(items, o => o.selection);
    const byLeague = groupBy(items, o => o.league_name);
    const byDate = groupBy(items, o => o.match_date);
    const byAnalysisType = groupBy(items, o => (o.analysis_type || 'PRE_JOGO') === 'PRE_JOGO' ? '🟢 Pré-Jogo' : '🔵 Retroativa');

    // 3-column grid for main breakdowns
    html += '<div class="dash-grid-3">';
    html += _renderBreakdownCard('🎯 Por Mercado', byMarket);
    html += _renderBreakdownCard('📈 Por Confiança', byConfidence);
    html += _renderBreakdownCard('📐 Por Faixa de Edge', byEdge);
    html += '</div>';

    html += '<div class="dash-grid-3">';
    html += _renderBreakdownCard('💰 Por Faixa de Odds', byOdds);
    html += _renderBreakdownCard('🌍 Por País', byCountry);
    html += _renderBreakdownCard('🔬 Por Tipo de Análise', byAnalysisType);
    html += '</div>';

    html += '<div class="dash-grid-3">';
    html += _renderBreakdownCard('▶ Por Seleção', bySelection);
    html += '</div>';

    // Full-width tables
    html += '<div class="dash-grid-2">';
    html += _renderBreakdownCard('🏆 Por Liga', byLeague);
    html += _renderBreakdownCard('📅 Por Data', byDate.sort((a,b) => (a.label||'').localeCompare(b.label||'')), true);
    html += '</div>';

    // ═══════════════════════════════
    // COMBO ANALYZER SECTION
    // ═══════════════════════════════
    html += `<div class="combo-analyzer">
        <div class="combo-analyzer-header">
            <div class="combo-analyzer-title">
                <span class="ca-icon">🧬</span> Analisador de Combinações Lucrativas
                <span style="font-size:10px;font-weight:400;color:var(--text-muted);margin-left:4px">— Identifica padrões de variáveis com melhor performance</span>
            </div>
            <div class="combo-analyzer-controls">
                <div class="ca-ctrl">
                    <label>Profundidade:</label>
                    <div class="ca-depth-btns">
                        <button class="ca-depth-btn ${_caState.depth===1?'active':''}" data-depth="1" onclick="_caUpdateDepth(1)" title="Variáveis individuais">1 var</button>
                        <button class="ca-depth-btn ${_caState.depth===2?'active':''}" data-depth="2" onclick="_caUpdateDepth(2)" title="Pares de variáveis">2 vars</button>
                        <button class="ca-depth-btn ${_caState.depth===3?'active':''}" data-depth="3" onclick="_caUpdateDepth(3)" title="Trios de variáveis (mais lento)">3 vars</button>
                    </div>
                </div>
                <div class="ca-ctrl">
                    <label>Min. Amostra:</label>
                    <input type="number" value="${_caState.minSample}" min="2" max="100" onchange="_caUpdateMinSample(this.value)">
                </div>
                <div class="ca-ctrl">
                    <label>Ordenar:</label>
                    <select onchange="_caUpdateSort(this.value)">
                        <option value="score" ${_caState.sortBy==='score'?'selected':''}>⭐ Score Composto</option>
                        <option value="roi" ${_caState.sortBy==='roi'?'selected':''}>📈 ROI</option>
                        <option value="hitRate" ${_caState.sortBy==='hitRate'?'selected':''}>🎯 Taxa de Acerto</option>
                        <option value="profit" ${_caState.sortBy==='profit'?'selected':''}>💰 P&L</option>
                        <option value="sample" ${_caState.sortBy==='sample'?'selected':''}>📊 Amostra</option>
                    </select>
                </div>
                <div class="ca-ctrl">
                    <label>Mostrar:</label>
                    <select onchange="_caUpdateMaxResults(this.value)">
                        <option value="10" ${_caState.maxResults===10?'selected':''}>Top 10</option>
                        <option value="20" ${_caState.maxResults===20?'selected':''}>Top 20</option>
                        <option value="50" ${_caState.maxResults===50?'selected':''}>Top 50</option>
                        <option value="100" ${_caState.maxResults===100?'selected':''}>Top 100</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="combo-analyzer-body">
            <div class="ca-vars-panel">
                <div class="ca-vars-title">
                    🎛️ Controle de Variáveis
                    <div class="ca-vars-legend">
                        <span><span style="color:var(--accent-blue)">●</span> Auto</span>
                        <span><span style="color:var(--accent-green)">●</span> Obrigatória</span>
                        <span><span style="color:var(--accent-red)">●</span> Excluída</span>
                    </div>
                </div>
                <div class="ca-vars-grid" id="ca-var-chips"></div>
            </div>
            <div id="ca-container">
                <div class="ca-empty"><div class="ca-empty-icon">⏳</div><div>Processando combinações...</div></div>
            </div>
        </div>
    </div>`;

    container.innerHTML = html;

    // Render variable mode chips
    _caRenderVarChips();

    // Render combo analyzer async (to not block the main render)
    setTimeout(() => _caRender(items), 50);
}

// ── SVG Donut ──
function _buildDonutSVG(greenPct, redPct, hitRate) {
    const r = 70, cx = 90, cy = 90, sw = 18;
    const circ = 2 * Math.PI * r;
    const gLen = circ * greenPct / 100;
    const rLen = circ * redPct / 100;
    const vLen = circ - gLen - rLen;
    const gOff = 0;
    const rOff = circ - gLen;
    const vOff = circ - gLen - rLen;

    return `<svg class="dash-donut-svg" viewBox="0 0 180 180">
        <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="${sw}"/>
        <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="var(--accent-green)" stroke-width="${sw}"
            stroke-dasharray="${gLen} ${circ - gLen}" stroke-dashoffset="0"
            transform="rotate(-90 ${cx} ${cy})" stroke-linecap="round"/>
        <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="var(--accent-red)" stroke-width="${sw}"
            stroke-dasharray="${rLen} ${circ - rLen}" stroke-dashoffset="${-gLen}"
            transform="rotate(-90 ${cx} ${cy})" stroke-linecap="round"/>
        <text x="${cx}" y="${cy - 6}" text-anchor="middle" fill="var(--text-primary)" font-size="28" font-weight="900" font-family="JetBrains Mono, monospace">${hitRate}%</text>
        <text x="${cx}" y="${cy + 14}" text-anchor="middle" fill="var(--text-muted)" font-size="11" font-weight="600">ACERTO</text>
    </svg>`;
}

// ── Accumulated Profit Chart ──
function _buildProfitChart(items) {
    // Group by date and compute cumulative
    const byDateMap = {};
    items.forEach(o => {
        const d = o.match_date || '?';
        if (!byDateMap[d]) byDateMap[d] = [];
        byDateMap[d].push(o);
    });
    const sortedDates = Object.keys(byDateMap).sort();
    if (sortedDates.length < 2) {
        return '<div style="text-align:center;padding:40px;color:var(--text-muted);font-size:13px">Dados insuficientes para o gráfico (necessário ≥2 datas)</div>';
    }

    let cumProfit = 0;
    const points = sortedDates.map(d => {
        const ops = byDateMap[d];
        const gp = ops.filter(x => x.result_status === 'GREEN').reduce((s, x) => s + ((x.market_odd||0)-1), 0);
        const rp = ops.filter(x => x.result_status === 'RED').length;
        const daily = gp - rp;
        cumProfit += daily;
        return { date: d, cum: cumProfit, daily, g: ops.filter(x=>x.result_status==='GREEN').length, r: rp, total: ops.length };
    });

    const svgW = 800, svgH = 200, padX = 40, padY = 24;
    const maxP = Math.max(...points.map(p => p.cum), 0.5);
    const minP = Math.min(...points.map(p => p.cum), -0.5);
    const range = maxP - minP || 1;
    const xStep = points.length > 1 ? (svgW - padX * 2) / (points.length - 1) : (svgW - padX * 2) / 2;
    const toY = (v) => padY + (svgH - padY * 2) * (1 - (v - minP) / range);
    const zeroY = toY(0);

    let pathD = '', areaD = '';
    const dots = [];
    points.forEach((p, i) => {
        const x = padX + i * xStep;
        const y = toY(p.cum);
        if (i === 0) { pathD += `M${x},${y}`; areaD += `M${x},${zeroY} L${x},${y}`; }
        else { pathD += ` L${x},${y}`; areaD += ` L${x},${y}`; }
        if (i === points.length - 1) areaD += ` L${x},${zeroY} Z`;
        const col = p.cum >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        dots.push(`<circle cx="${x}" cy="${y}" r="4.5" fill="${col}" stroke="var(--bg-card)" stroke-width="2.5"><title>${p.date}\nAcumulado: ${p.cum >= 0 ? '+' : ''}${p.cum.toFixed(2)}u\nDia: ${p.daily >= 0 ? '+' : ''}${p.daily.toFixed(2)}u (${p.g}G/${p.r}R)</title></circle>`);
    });

    const finalVal = points[points.length - 1].cum;
    const lineCol = finalVal >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
    const areaCol = finalVal >= 0 ? 'rgba(0,230,138,0.08)' : 'rgba(239,68,68,0.08)';

    // Y-axis labels
    const yLabels = [maxP, 0, minP].filter((v, i, a) => a.indexOf(v) === i);
    let yLabelsSvg = yLabels.map(v => {
        const y = toY(v);
        const col = v > 0 ? 'var(--accent-green)' : v < 0 ? 'var(--accent-red)' : 'rgba(255,255,255,0.3)';
        return `<text x="${padX - 6}" y="${y + 4}" text-anchor="end" fill="${col}" font-size="10" font-family="JetBrains Mono, monospace">${v >= 0 ? '+' : ''}${v.toFixed(1)}</text>
                <line x1="${padX}" y1="${y}" x2="${svgW - 10}" y2="${y}" stroke="rgba(255,255,255,0.06)" stroke-width="1" stroke-dasharray="3,3"/>`;
    }).join('');

    // X-axis labels (first, last, middle)
    const xLabels = [];
    if (points.length <= 8) {
        points.forEach((p, i) => xLabels.push({ i, label: p.date.slice(5) })); // MM-DD
    } else {
        [0, Math.floor(points.length/2), points.length-1].forEach(i => xLabels.push({ i, label: points[i].date.slice(5) }));
    }
    const xLabelsSvg = xLabels.map(({ i, label }) => {
        const x = padX + i * xStep;
        return `<text x="${x}" y="${svgH - 4}" text-anchor="middle" fill="var(--text-muted)" font-size="10">${label}</text>`;
    }).join('');

    return `<svg class="dash-chart-svg" viewBox="0 0 ${svgW} ${svgH}" preserveAspectRatio="xMidYMid meet">
        ${yLabelsSvg}
        <line x1="${padX}" y1="${zeroY}" x2="${svgW - 10}" y2="${zeroY}" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
        <path d="${areaD}" fill="${areaCol}"/>
        <path d="${pathD}" fill="none" stroke="${lineCol}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
        ${dots.join('')}
        ${xLabelsSvg}
    </svg>
    <div class="dash-chart-footer">
        <span>${points[0].date}</span>
        <span>Final: <strong class="${finalVal >= 0 ? 'profit-positive' : 'profit-negative'}">${finalVal >= 0 ? '+' : ''}${finalVal.toFixed(2)}u</strong></span>
        <span>${points[points.length-1].date}</span>
    </div>`;
}

// ── Breakdown Card ──
function _renderBreakdownCard(title, items, skipSort) {
    if (!items || !items.length) return '';
    const sorted = skipSort ? items : [...items].sort((a, b) => b.roi - a.roi || b.profit - a.profit);

    let h = `<div class="dash-bd-card">
        <div class="dash-bd-header">
            <div class="dash-bd-title">${title}</div>
            <div class="dash-bd-count">${sorted.length}</div>
        </div>
        <div class="dash-bd-scroll">
            <div class="dash-bd-head">
                <div>Nome</div><div>G</div><div>R</div><div>Acerto</div><div>P&L</div><div>ROI</div>
            </div>`;

    sorted.forEach(item => {
        const hr = item.hit_rate || 0;
        const p = item.profit || 0;
        const r = item.roi || 0;
        const hc = hr >= 55 ? 'var(--accent-green)' : hr >= 45 ? 'var(--accent-yellow)' : 'var(--accent-red)';
        const pClass = p >= 0 ? 'txt-green' : 'txt-red';
        const rClass = r >= 0 ? 'txt-green' : 'txt-red';

        h += `<div class="dash-bd-row">
            <div class="dash-bd-row-name" title="${item.label}">${item.label} <span class="txt-muted" style="font-size:10px;font-weight:400">(${item.total})</span></div>
            <div class="dash-bd-row-g">${item.green}</div>
            <div class="dash-bd-row-r">${item.red}</div>
            <div class="dash-bd-row-hr">
                <div class="dash-bd-minibar"><div class="dash-bd-minibar-fill" style="width:${Math.min(hr, 100)}%;background:${hc}"></div></div>
                <div class="dash-bd-row-hr-pct" style="color:${hc}">${hr}%</div>
            </div>
            <div class="dash-bd-row-pnl ${pClass}">${p >= 0 ? '+' : ''}${p.toFixed(2)}u</div>
            <div class="dash-bd-row-roi ${rClass}">${r >= 0 ? '+' : ''}${r}%</div>
        </div>`;
    });

    h += '</div></div>';
    return h;
}


// ═══════════════════════════════════════════
// COMBO ANALYZER ENGINE — Identificador de Padrões Lucrativos
// ═══════════════════════════════════════════
let _caState = {
    depth: 2, minSample: 5, sortBy: 'score', maxResults: 20,
    // Variable modes: 'auto' (system decides), 'force' (must include), 'exclude' (never include)
    varModes: {} // key → 'auto'|'force'|'exclude'
};

function _caGetVarMode(key) { return _caState.varModes[key] || 'auto'; }
function _caSetVarMode(key, mode) {
    if (mode === 'auto') { delete _caState.varModes[key]; } else { _caState.varModes[key] = mode; }
    // Re-render variable chips UI
    _caRenderVarChips();
    // Re-run analysis
    if (dashboardRawData) applyDashboardFilters();
}
function _caCycleVarMode(key) {
    const cur = _caGetVarMode(key);
    const next = cur === 'auto' ? 'force' : cur === 'force' ? 'exclude' : 'auto';
    _caSetVarMode(key, next);
}

function _caRenderVarChips() {
    const container = document.getElementById('ca-var-chips');
    if (!container) return;
    const dims = _caDimensions();
    container.innerHTML = dims.map(d => {
        const mode = _caGetVarMode(d.key);
        const stClass = mode === 'force' ? 'state-force' : mode === 'exclude' ? 'state-exclude' : '';
        return `<div class="ca-var-chip ${stClass}">
            <div class="ca-var-chip-label">${d.label}</div>
            <div class="ca-var-chip-btns">
                <button class="ca-var-btn vmode-auto ${mode==='auto'?'active':''}" onclick="_caSetVarMode('${d.key}','auto')" title="Automático — sistema decide">Auto</button>
                <button class="ca-var-btn vmode-force ${mode==='force'?'active':''}" onclick="_caSetVarMode('${d.key}','force')" title="Obrigatória — sempre incluída">✓</button>
                <button class="ca-var-btn vmode-exclude ${mode==='exclude'?'active':''}" onclick="_caSetVarMode('${d.key}','exclude')" title="Excluída — nunca usada">✕</button>
            </div>
        </div>`;
    }).join('');
}

function _caDimensions() {
    return [
        { key: 'market',     label: 'Mercado',    css: 'dim-market',    extract: o => o.market },
        { key: 'selection',  label: 'Seleção',    css: 'dim-selection', extract: o => o.selection },
        { key: 'confidence', label: 'Confiança',  css: 'dim-confidence',extract: o => o.confidence },
        { key: 'edgeRange',  label: 'Edge',       css: 'dim-edge',     extract: o => {
            const e = o.edge || 0;
            if (e < 3) return '0-3%'; if (e < 5) return '3-5%'; if (e < 10) return '5-10%';
            if (e < 20) return '10-20%'; if (e < 50) return '20-50%'; return '50%+';
        }},
        { key: 'oddsRange',  label: 'Odds',       css: 'dim-odds',     extract: o => {
            const odd = o.market_odd || 0;
            if (odd < 1.3) return '1.00-1.30'; if (odd < 1.5) return '1.30-1.50';
            if (odd < 1.8) return '1.50-1.80'; if (odd < 2.0) return '1.80-2.00';
            if (odd < 2.5) return '2.00-2.50'; if (odd < 3.0) return '2.50-3.00';
            if (odd < 5.0) return '3.00-5.00'; return '5.00+';
        }},
        { key: 'country',    label: 'País',       css: 'dim-country',  extract: o => o.league_country },
        { key: 'league',     label: 'Liga',       css: 'dim-league',   extract: o => o.league_name },
        { key: 'analysisType',label:'Tipo',       css: 'dim-analysis', extract: o => o.analysis_type || 'PRE_JOGO' },
        { key: 'timeOfDay',  label: 'Horário',    css: 'dim-time',     extract: o => {
            const h = parseInt((o.match_time || '12:00').split(':')[0]);
            if (h < 12) return '🌅 Manhã'; if (h < 18) return '☀️ Tarde'; return '🌙 Noite';
        }},
    ];
}

function _caComputeMetrics(items) {
    const g = items.filter(x => x.result_status === 'GREEN');
    const r = items.filter(x => x.result_status === 'RED');
    const v = items.filter(x => x.result_status === 'VOID');
    const pend = items.filter(x => !x.result_status || x.result_status === 'PENDENTE');
    const decided = g.length + r.length;
    const hitRate = decided > 0 ? (g.length / decided * 100) : 0;
    const profitG = g.reduce((s, x) => s + ((x.market_odd || 0) - 1), 0);
    const profit = profitG - r.length;
    const roi = decided > 0 ? (profit / decided * 100) : 0;
    const avgOdd = items.length > 0 ? items.reduce((s, x) => s + (x.market_odd || 0), 0) / items.length : 0;
    const avgEdge = items.length > 0 ? items.reduce((s, x) => s + (x.edge || 0), 0) / items.length : 0;

    // Consistency: standard deviation of per-day ROI (lower = more consistent)
    const byDay = {};
    items.forEach(x => { const d = x.match_date || '?'; if (!byDay[d]) byDay[d] = []; byDay[d].push(x); });
    const dailyRois = Object.values(byDay).map(dayItems => {
        const dg = dayItems.filter(x => x.result_status === 'GREEN');
        const dr = dayItems.filter(x => x.result_status === 'RED');
        const dd = dg.length + dr.length;
        if (dd === 0) return 0;
        const dp = dg.reduce((s, x) => s + ((x.market_odd||0)-1), 0) - dr.length;
        return (dp / dd) * 100;
    });
    const avgDailyRoi = dailyRois.length ? dailyRois.reduce((a, b) => a + b, 0) / dailyRois.length : 0;
    const stdDev = dailyRois.length > 1 ? Math.sqrt(dailyRois.reduce((s, r) => s + (r - avgDailyRoi) ** 2, 0) / dailyRois.length) : 50;
    const consistency = Math.max(0, 100 - stdDev);

    // Composite Score: ROI (40%) + Hit Rate (30%) + Sample bonus (20%) + Consistency (10%)
    const sampleBonus = Math.min(100, Math.log2(Math.max(decided, 1) + 1) * 20);
    const roiNorm = Math.max(0, Math.min(100, roi + 30)); // normalize ROI to ~0-100
    const score = decided >= 2
        ? (roiNorm * 0.40) + (hitRate * 0.30) + (sampleBonus * 0.20) + (consistency * 0.10)
        : 0;

    return {
        total: items.length, green: g.length, red: r.length, voids: v.length, pending: pend.length,
        decided, hitRate: Math.round(hitRate * 10) / 10, profit: Math.round(profit * 100) / 100,
        roi: Math.round(roi * 10) / 10, avgOdd: Math.round(avgOdd * 100) / 100,
        avgEdge: Math.round(avgEdge * 10) / 10, consistency: Math.round(consistency),
        score: Math.round(score * 10) / 10, items
    };
}

function _caGenerateCombinations(items, depth) {
    const allDims = _caDimensions();

    // Separate dims by mode
    const forcedIdxs = [];  // must appear in every combo
    const autoIdxs = [];    // optional — system mixes
    allDims.forEach((d, i) => {
        const mode = _caGetVarMode(d.key);
        if (mode === 'exclude') return; // skip entirely
        if (mode === 'force') forcedIdxs.push(i);
        else autoIdxs.push(i);
    });

    const combos = [];

    // Pre-compute dimension values for each item
    const dimValues = items.map(o => {
        const vals = {};
        allDims.forEach(d => vals[d.key] = d.extract(o));
        return vals;
    });

    // Effective depth = total dims per combo. Forced dims always present.
    // Additional "auto" slots = depth - forcedIdxs.length (but at least 0)
    const autoSlots = Math.max(0, depth - forcedIdxs.length);

    // Generate combos of auto dims to fill remaining slots
    const autoIdxCombos = [];
    const nA = autoIdxs.length;

    if (autoSlots === 0) {
        // Only forced dims (if any)
        if (forcedIdxs.length > 0) autoIdxCombos.push([]);
    } else {
        // Depth 0 (just forced): always include if forced exists
        if (forcedIdxs.length > 0) autoIdxCombos.push([]);
        // Depth 1 autos
        for (let i = 0; i < nA; i++) autoIdxCombos.push([autoIdxs[i]]);
        // Depth 2 autos
        if (autoSlots >= 2) for (let i = 0; i < nA; i++) for (let j = i + 1; j < nA; j++) autoIdxCombos.push([autoIdxs[i], autoIdxs[j]]);
        // Depth 3 autos
        if (autoSlots >= 3) for (let i = 0; i < nA; i++) for (let j = i + 1; j < nA; j++) for (let k = j + 1; k < nA; k++) autoIdxCombos.push([autoIdxs[i], autoIdxs[j], autoIdxs[k]]);
    }

    autoIdxCombos.forEach(autoArr => {
        // Combine forced + this auto set
        const idxArr = [...forcedIdxs, ...autoArr];
        if (idxArr.length === 0) return;

        const groupMap = {};
        items.forEach((o, oi) => {
            const key = idxArr.map(idx => dimValues[oi][allDims[idx].key]).join('|||');
            if (!groupMap[key]) groupMap[key] = {
                dimVals: idxArr.map(idx => ({
                    key: allDims[idx].key, label: allDims[idx].label,
                    css: allDims[idx].css, value: dimValues[oi][allDims[idx].key]
                })),
                items: []
            };
            groupMap[key].items.push(o);
        });

        Object.values(groupMap).forEach(g => {
            combos.push({ dims: g.dimVals, ...(_caComputeMetrics(g.items)) });
        });
    });

    return combos;
}

function _caRender(items) {
    const { depth, minSample, sortBy, maxResults } = _caState;
    const container = document.getElementById('ca-container');
    if (!container) return;

    // Generate all combinations
    const allCombos = _caGenerateCombinations(items, depth);

    // Filter by min sample
    const filtered = allCombos.filter(c => c.decided >= minSample);

    // Sort
    const sortFns = {
        score: (a, b) => b.score - a.score,
        roi: (a, b) => b.roi - a.roi || b.score - a.score,
        hitRate: (a, b) => b.hitRate - a.hitRate || b.score - a.score,
        profit: (a, b) => b.profit - a.profit || b.score - a.score,
        sample: (a, b) => b.decided - a.decided || b.score - a.score,
    };
    filtered.sort(sortFns[sortBy] || sortFns.score);

    const top = filtered.slice(0, maxResults);
    const totalCombos = allCombos.length;
    const profitable = allCombos.filter(c => c.decided >= minSample && c.roi > 0).length;
    const avgScore = top.length ? (top.reduce((s, c) => s + c.score, 0) / top.length).toFixed(1) : 0;

    let html = '';

    // Summary bar
    html += `<div class="ca-summary-bar">
        <div class="ca-summary-chip">🔬 Combinações analisadas: <strong>${totalCombos.toLocaleString()}</strong></div>
        <div class="ca-summary-chip">✅ Acima do mínimo (${minSample}+): <strong>${filtered.length}</strong></div>
        <div class="ca-summary-chip" style="${profitable > 0 ? 'border-color:rgba(0,230,138,0.3)' : ''}">💰 Lucrativas: <strong style="color:var(--accent-green)">${profitable}</strong></div>
        <div class="ca-summary-chip">⭐ Score médio top ${top.length}: <strong>${avgScore}</strong></div>
    </div>`;

    if (!top.length) {
        html += '<div class="ca-empty"><div class="ca-empty-icon">🔍</div><div>Nenhuma combinação encontrada com amostra mínima de <strong>' + minSample + '</strong> apostas resolvidas.<br>Tente reduzir o mínimo ou carregar mais dados.</div></div>';
        container.innerHTML = html;
        return;
    }

    // Heatmap of single dimensions
    html += _caRenderHeatmap(items);

    // Cards grid
    html += '<div class="ca-cards-grid">';
    top.forEach((combo, idx) => {
        const medal = idx === 0 ? 'gold' : idx === 1 ? 'silver' : idx === 2 ? 'bronze' : '';
        const rankIcon = idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : `#${idx + 1}`;

        // Dimension tags
        const dimTags = combo.dims.map(d => `<span class="ca-dim-tag ${d.css}">${d.label}: ${d.value}</span>`).join('');

        // Metrics colors
        const roiColor = combo.roi >= 10 ? 'var(--accent-green)' : combo.roi >= 0 ? 'var(--accent-yellow)' : 'var(--accent-red)';
        const hrColor = combo.hitRate >= 55 ? 'var(--accent-green)' : combo.hitRate >= 45 ? 'var(--accent-yellow)' : 'var(--accent-red)';
        const profitColor = combo.profit >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        const profitSign = combo.profit >= 0 ? '+' : '';
        const roiSign = combo.roi >= 0 ? '+' : '';

        // Encode combo for button actions
        const comboJson = encodeURIComponent(JSON.stringify(combo.dims));

        html += `<div class="ca-card">
            <div class="ca-card-rank ${medal}">${rankIcon}</div>
            <div class="ca-card-name">${dimTags}</div>
            <div class="ca-card-score">
                <div class="ca-score-bar"><div class="ca-score-fill" style="width:${Math.min(combo.score, 100)}%"></div></div>
                <div class="ca-score-val">${combo.score}</div>
            </div>
            <div class="ca-card-metrics">
                <div class="ca-metric">
                    <div class="ca-metric-label">ROI</div>
                    <div class="ca-metric-val" style="color:${roiColor}">${roiSign}${combo.roi}%</div>
                </div>
                <div class="ca-metric">
                    <div class="ca-metric-label">Acerto</div>
                    <div class="ca-metric-val" style="color:${hrColor}">${combo.hitRate}%</div>
                </div>
                <div class="ca-metric">
                    <div class="ca-metric-label">P&L</div>
                    <div class="ca-metric-val" style="color:${profitColor}">${profitSign}${combo.profit.toFixed(2)}u</div>
                </div>
                <div class="ca-metric">
                    <div class="ca-metric-label">Amostra</div>
                    <div class="ca-metric-val" style="color:var(--text-primary)">${combo.decided}<span style="font-size:9px;color:var(--text-muted);font-weight:400"> (${combo.total})</span></div>
                </div>
            </div>
            <div style="display:flex;gap:8px;font-size:10px;color:var(--text-muted);margin-bottom:6px">
                <span>✅ ${combo.green}G</span>
                <span>❌ ${combo.red}R</span>
                <span>Odd méd: ${combo.avgOdd}</span>
                <span>Edge méd: ${combo.avgEdge}%</span>
                <span title="Consistência entre dias">📊 ${combo.consistency}%</span>
            </div>
            <div class="ca-card-actions">
                <button class="ca-btn ca-btn-apply" onclick="_caApplyAsFilter('${comboJson}')">🔍 Aplicar como Filtro</button>
                <button class="ca-btn ca-btn-save" onclick="_caSaveAsView('${comboJson}')">💾 Salvar como Visão</button>
            </div>
        </div>`;
    });
    html += '</div>';

    container.innerHTML = html;
}

function _caRenderHeatmap(items) {
    const dims = _caDimensions().filter(d => _caGetVarMode(d.key) !== 'exclude');
    // For each single dimension, compute the best value by ROI
    let html = '<div class="ca-heatmap"><div class="ca-heatmap-title">🗺️ Mapa de Calor — Melhores valores por dimensão</div><div class="ca-heatmap-grid">';

    dims.forEach(dim => {
        const groups = {};
        items.forEach(o => {
            const v = dim.extract(o);
            if (!groups[v]) groups[v] = [];
            groups[v].push(o);
        });

        // Find best value by ROI (min 3 decided)
        let best = null, bestRoi = -Infinity;
        Object.entries(groups).forEach(([val, arr]) => {
            const g = arr.filter(x => x.result_status === 'GREEN');
            const r = arr.filter(x => x.result_status === 'RED');
            const d = g.length + r.length;
            if (d < 3) return;
            const pft = g.reduce((s, x) => s + ((x.market_odd||0)-1), 0) - r.length;
            const roi = (pft / d) * 100;
            if (roi > bestRoi) { bestRoi = roi; best = { val, roi, total: arr.length, decided: d, green: g.length, red: r.length }; }
        });

        if (!best) return;

        const bgAlpha = Math.min(0.6, Math.max(0.1, best.roi / 100));
        const bgColor = best.roi >= 0
            ? `rgba(0,230,138,${bgAlpha})`
            : `rgba(239,68,68,${Math.min(0.5, Math.abs(best.roi) / 100)})`;
        const sign = best.roi >= 0 ? '+' : '';

        html += `<div class="ca-heat-cell" style="background:${bgColor}" onclick="_caApplyDimFilter('${dim.key}','${best.val.replace(/'/g, "\\'")}')">
            <div class="ca-heat-cell-name" title="${dim.label}: ${best.val}">${dim.label}</div>
            <div class="ca-heat-cell-val" style="color:${best.roi >= 0 ? '#fff' : '#fca5a5'}">${sign}${best.roi.toFixed(1)}%</div>
            <div class="ca-heat-cell-sub">${best.val} (${best.green}G/${best.red}R de ${best.decided})</div>
        </div>`;
    });

    html += '</div></div>';
    return html;
}

function _caApplyDimFilter(dimKey, dimValue) {
    _caApplyAsFilter(encodeURIComponent(JSON.stringify([{ key: dimKey, value: dimValue }])));
}

function _caApplyAsFilter(encodedDims) {
    const dims = JSON.parse(decodeURIComponent(encodedDims));

    // Reset all dashboard filters first
    clearDashboardFilters();

    // Wait a tick for clearDashboardFilters to execute, then apply specific filters
    setTimeout(() => {
        dims.forEach(d => {
            switch (d.key) {
                case 'market':
                    if (msRegistry['df-market']) msRegistry['df-market'].setSelected([d.value]);
                    break;
                case 'selection':
                    if (msRegistry['df-selection']) msRegistry['df-selection'].setSelected([d.value]);
                    break;
                case 'confidence':
                    if (msRegistry['df-confidence']) msRegistry['df-confidence'].setSelected([d.value]);
                    break;
                case 'country':
                    if (msRegistry['df-country']) msRegistry['df-country'].setSelected([d.value]);
                    break;
                case 'league':
                    if (msRegistry['df-league']) msRegistry['df-league'].setSelected([d.value]);
                    break;
                case 'analysisType':
                    if (msRegistry['df-analysis-type']) msRegistry['df-analysis-type'].setSelected([d.value]);
                    break;
                case 'edgeRange': {
                    const match = d.value.match(/^([\d.]+)-([\d.]+)/);
                    if (match) {
                        const el1 = document.getElementById('df-edge-min');
                        const el2 = document.getElementById('df-edge-max');
                        if (el1) el1.value = match[1];
                        if (el2) el2.value = match[2];
                    } else if (d.value === '50%+') {
                        const el1 = document.getElementById('df-edge-min');
                        if (el1) el1.value = '50';
                    }
                    break;
                }
                case 'oddsRange': {
                    const match = d.value.match(/^([\d.]+)-([\d.]+)/);
                    if (match) {
                        const el1 = document.getElementById('df-odd-min');
                        const el2 = document.getElementById('df-odd-max');
                        if (el1) el1.value = match[1];
                        if (el2) el2.value = match[2];
                    } else if (d.value === '5.00+') {
                        const el1 = document.getElementById('df-odd-min');
                        if (el1) el1.value = '5.0';
                    }
                    break;
                }
                case 'timeOfDay':
                    // Time of day doesn't have a direct filter, so we skip
                    break;
            }
        });

        // Re-apply filters to update dashboard
        applyDashboardFilters();

        // Scroll to top of dashboard to show updated results
        document.getElementById('sec-performance')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 50);
}

function _caSaveAsView(encodedDims) {
    const dims = JSON.parse(decodeURIComponent(encodedDims));
    const viewName = dims.map(d => `${d.label}: ${d.value}`).join(' + ');

    // First apply the filter
    _caApplyAsFilter(encodedDims);

    // Then save as a view after filters are applied
    setTimeout(() => {
        const state = _captureDashFilters();
        const views = _fvLoad();
        const id = 'fv_' + Date.now();
        views.push({ id, name: '🧬 ' + viewName, target: 'dash', state, createdAt: new Date().toISOString() });
        _fvSave(views);
        renderFilterViews();
    }, 120);
}

function _caUpdateDepth(newDepth) {
    _caState.depth = newDepth;
    document.querySelectorAll('.ca-depth-btn').forEach(b => {
        b.classList.toggle('active', parseInt(b.dataset.depth) === newDepth);
    });
    // Re-render with current filtered data
    if (dashboardRawData) applyDashboardFilters();
}

function _caUpdateSort(val) { _caState.sortBy = val; if (dashboardRawData) applyDashboardFilters(); }
function _caUpdateMinSample(val) { _caState.minSample = parseInt(val) || 3; if (dashboardRawData) applyDashboardFilters(); }
function _caUpdateMaxResults(val) { _caState.maxResults = parseInt(val) || 20; if (dashboardRawData) applyDashboardFilters(); }


// ═══════════════════════════════════════════
// RENDER ALL
// ═══════════════════════════════════════════
function renderAll() {
    renderRunInfo();
    renderStats();
    populateFilters();
    applyColumnFilters();  // Aplica sort padrão (data asc) e filtros
    renderMatches();
    renderFilterViews();
}

function renderRunInfo() {
    document.getElementById("ri-last-run").textContent = stats.last_run_at || "--";
    const dates = stats.analysis_dates || [];
    document.getElementById("ri-dates").textContent = 
        dates.length >= 2 ? `${dates[0]} → ${dates[dates.length - 1]}` : (dates[0] || "--");
    document.getElementById("ri-runtime").textContent = stats.run_time ? `${stats.run_time}s` : "--";
    document.getElementById("ri-api-calls").textContent = stats.api_calls_this_run || "--";
}

// ═══════════════════════════════════════════
// TABS
// ═══════════════════════════════════════════
let _previousTab = 'opportunities';
let _pendingSync = null;  // 'mainToDash' | 'dashToMain' | null

function switchTab(tab) {
    // When going to dashboard: flag pending sync (will run AFTER loadDashboard completes)
    if (_previousTab === 'opportunities' && tab === 'performance') {
        _pendingSync = 'mainToDash';
    }
    // When leaving dashboard → main: sync immediately (main data already loaded)
    if (_previousTab === 'performance' && tab === 'opportunities') {
        syncFiltersDashToMain();
    }
    _previousTab = tab;

    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    document.querySelector(`.tab[data-tab="${tab}"]`).classList.add("active");
    document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
    document.getElementById(`sec-${tab}`).classList.add("active");

    // Ao abrir o dashboard, sempre recarregar com dados atuais
    if (tab === 'performance') {
        loadDashboard(true);
    }
}

// ═══════════════════════════════════════════
// SYNC FILTERS BETWEEN MAIN & DASHBOARD
// ═══════════════════════════════════════════

// Helper: sync a multi-select value from one to another
function _syncMultiSelect(fromId, toId) {
    const from = msRegistry[fromId];
    const to = msRegistry[toId];
    if (!from || !to) return;

    // Check if source has an active filter (some but not all items selected)
    if (from.hasActiveFilter()) {
        // Copy the raw selection (actual selected values)
        const rawSelected = from.getRawSelected();
        to.setSelected(rawSelected);
    } else {
        // No active filter → clear target filter too (= show all)
        to.reset();
    }
}

// Helper: sync a numeric input value
function _syncInput(fromId, toId) {
    const from = document.getElementById(fromId);
    const to = document.getElementById(toId);
    if (from && to) to.value = from.value;
}

// Main screen → Dashboard
function syncFiltersMainToDash() {
    // Multi-selects (same type on both screens)
    _syncMultiSelect('cf-league', 'df-league');
    _syncMultiSelect('cf-market', 'df-market');
    _syncMultiSelect('cf-confidence', 'df-confidence');
    _syncMultiSelect('cf-analysis-type', 'df-analysis-type');

    // Selection: both are multi-selects now
    _syncMultiSelect('cf-selection', 'df-selection');

    // Date: cf-dt-start/end (datetime-local) → df-date-start/end (date)
    const dtStart = document.getElementById('cf-dt-start')?.value || '';
    const dtEnd = document.getElementById('cf-dt-end')?.value || '';
    const dfDateStart = document.getElementById('df-date-start');
    const dfDateEnd = document.getElementById('df-date-end');
    if (dfDateStart) dfDateStart.value = dtStart ? dtStart.substring(0, 10) : '';
    if (dfDateEnd) dfDateEnd.value = dtEnd ? dtEnd.substring(0, 10) : '';

    // Numeric inputs
    _syncInput('cf-odd-min', 'df-odd-min');
    _syncInput('cf-odd-max', 'df-odd-max');
    _syncInput('cf-fair-odd-min', 'df-fair-odd-min');
    _syncInput('cf-fair-odd-max', 'df-fair-odd-max');
    _syncInput('cf-edge-min', 'df-edge-min');
    _syncInput('cf-edge-max', 'df-edge-max');

    // Country: main screen doesn't have a country filter, so leave dashboard's as is
    // Result filter: dashboard only shows resolved, so skip

    applyDashboardFilters();
}

// Dashboard → Main screen
function syncFiltersDashToMain() {
    // Multi-selects
    _syncMultiSelect('df-league', 'cf-league');
    _syncMultiSelect('df-market', 'cf-market');
    _syncMultiSelect('df-confidence', 'cf-confidence');
    _syncMultiSelect('df-analysis-type', 'cf-analysis-type');

    // Selection: both are multi-selects now
    _syncMultiSelect('df-selection', 'cf-selection');

    // Date: df-date-start/end (date) → cf-dt-start/end (datetime-local)
    const dateStart = document.getElementById('df-date-start')?.value || '';
    const dateEnd = document.getElementById('df-date-end')?.value || '';
    const cfDtStart = document.getElementById('cf-dt-start');
    const cfDtEnd = document.getElementById('cf-dt-end');
    if (cfDtStart) cfDtStart.value = dateStart ? dateStart + 'T00:00' : '';
    if (cfDtEnd) cfDtEnd.value = dateEnd ? dateEnd + 'T23:59' : '';

    // Numeric inputs
    _syncInput('df-odd-min', 'cf-odd-min');
    _syncInput('df-odd-max', 'cf-odd-max');
    _syncInput('df-fair-odd-min', 'cf-fair-odd-min');
    _syncInput('df-fair-odd-max', 'cf-fair-odd-max');
    _syncInput('df-edge-min', 'cf-edge-min');
    _syncInput('df-edge-max', 'cf-edge-max');

    applyColumnFilters();
}

// Global clear: limpa filtros de AMBAS as telas
function clearAllFiltersGlobal() {
    // ── Clear main screen filters ──
    ['cf-team', 'cf-dt-start', 'cf-dt-end',
     'cf-odd-min', 'cf-odd-max', 'cf-fair-odd-min', 'cf-fair-odd-max',
     'cf-edge-min', 'cf-edge-max',
     'cf-prob-min', 'cf-prob-max',
     'cf-score-min', 'cf-score-max'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    ['cf-league', 'cf-game-status', 'cf-result', 'cf-market', 'cf-selection', 'cf-confidence', 'cf-analysis-type'].forEach(id => {
        if (msRegistry[id]) msRegistry[id].reset();
    });
    currentSort = { key: 'date', dir: 'asc' };
    document.querySelectorAll('#opp-table th.sortable').forEach(h => {
        h.classList.remove('sort-asc', 'sort-desc');
    });

    // ── Clear dashboard filters ──
    ['df-date-start','df-date-end','df-odd-min','df-odd-max','df-fair-odd-min','df-fair-odd-max','df-edge-min','df-edge-max'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = '';
    });
    ['df-market','df-selection','df-confidence','df-country','df-league','df-analysis-type'].forEach(id => {
        if (msRegistry[id]) msRegistry[id].reset();
    });

    // Re-apply on both screens
    applyColumnFilters();
    if (dashboardRawData) applyDashboardFilters();
}

// ═══════════════════════════════════════════
// RENDER STATS
// ═══════════════════════════════════════════
function renderStats() {
    const row = document.getElementById("stats-row");
    row.innerHTML = `
        <div class="stat-card">
            <div class="stat-label">Ligas Analisadas</div>
            <div class="stat-value blue">${stats.total_leagues}</div>
            <div class="stat-sub">Cobertura global</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Partidas Processadas</div>
            <div class="stat-value">${stats.total_matches}</div>
            <div class="stat-sub">${(stats.analysis_dates||[])[0] || '?'} → ${(stats.analysis_dates||[]).slice(-1)[0] || '?'}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Oportunidades +EV</div>
            <div class="stat-value green">${stats.total_opportunities}</div>
            <div class="stat-sub">Edge ≥ 5%</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Confiança Alta</div>
            <div class="stat-value green">${stats.high_conf}</div>
            <div class="stat-sub">🟢 Alta certeza</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Confiança Média</div>
            <div class="stat-value yellow">${stats.med_conf}</div>
            <div class="stat-sub">🟡 Moderada</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Maior Edge</div>
            <div class="stat-value green">+${stats.max_edge}%</div>
            <div class="stat-sub">${stats.max_edge_match}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Edge Médio</div>
            <div class="stat-value purple">${stats.avg_edge}%</div>
            <div class="stat-sub">Todas oportunidades</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Tempo de Execução</div>
            <div class="stat-value">${stats.run_time}s</div>
            <div class="stat-sub">${stats.api_calls_this_run || 0} requests usadas</div>
        </div>
    `;
}

// ═══════════════════════════════════════════
// RENDER OPPORTUNITIES (já vem ordenada por Edge desc)
// ═══════════════════════════════════════════
function renderOpportunities(data) {
    const opps = data || allOpps;
    document.getElementById("opp-count").textContent = opps.length;
    const tbody = document.getElementById("opp-tbody");

    tbody.innerHTML = opps.map((o, i) => {
        const confClass = o.confidence === "ALTO" ? "badge-high" : o.confidence === "MÉDIO" ? "badge-med" : "badge-low";
        const edgeClass = o.edge > 15 ? "edge-high" : "edge-med";
        const marketClass = getMarketClass(o.market);

        const suspectBadge = o.odds_suspect ? ' <span title="Possivel inversao Casa/Fora na API" style="cursor:help;color:var(--accent-yellow);font-size:13px">⚠️</span>' : '';
        
        // Game status (LIVE / FINISHED / UPCOMING)
        const gs = getGameStatus(o.match_date, o.match_time);
        const gameStatusBadge = gs.status === 'LIVE' 
            ? '<span class="game-live">🔴 AO VIVO</span>'
            : gs.status === 'FINISHED'
            ? '<span class="game-finished">✔ Encerrado</span>'
            : '<span class="game-upcoming">📅 ' + gs.timeLabel + '</span>';
        
        // Result status badge + game details
        const resultStatus = o.result_status || 'PENDENTE';
        const resultBadge = (() => {
            if (resultStatus === 'GREEN') return '<span class="result-green">✅ GREEN</span>';
            if (resultStatus === 'RED') return '<span class="result-red">❌ RED</span>';
            if (resultStatus === 'VOID') return '<span class="result-void">⬜ VOID</span>';
            return '<span class="result-pending">⏳ Pend.</span>';
        })();
        const resultScore = o.result_score ? ` <span style="font-size:10px;color:var(--text-muted);font-family:'JetBrains Mono'">${o.result_score}</span>` : '';
        
        // Build game detail tooltip for finished games
        let gameDetailHtml = '';
        if (o.result_score && resultStatus !== 'PENDENTE') {
            const detailParts = [];
            if (o.result_ht_score) detailParts.push(`⏱️ HT: ${o.result_ht_score}`);
            if (o.result_corners) detailParts.push(`🚩 Escanteios: ${o.result_corners}`);
            if (o.result_cards) detailParts.push(`🟨 Cartões: ${o.result_cards}`);
            if (o.result_shots) detailParts.push(`🎯 Finalizações: ${o.result_shots}`);
            if (detailParts.length > 0) {
                gameDetailHtml = `<div class="game-detail-mini">${detailParts.join(' · ')}</div>`;
            }
        }
        
        // Row class based on status
        const rowClass = resultStatus === 'GREEN' ? 'row-green' 
            : resultStatus === 'RED' ? 'row-red'
            : gs.status === 'LIVE' ? 'row-live'
            : gs.status === 'FINISHED' ? 'row-finished' : '';
        const rowBorder = resultStatus === 'GREEN' ? ';border-left:3px solid var(--accent-green)' 
            : resultStatus === 'RED' ? ';border-left:3px solid var(--accent-red)' 
            : gs.status === 'LIVE' ? ';border-left:3px solid #ff6b6b'
            : o.odds_suspect ? ';border-left:3px solid var(--accent-yellow)' : '';
        
        return `<tr class="${rowClass}" onclick="showOppDetail(${allOpps.indexOf(o)})" style="cursor:pointer${rowBorder}">
            <td style="color:var(--text-muted);font-weight:600">${i+1}</td>
            <td class="team-cell">${o.result_score && resultStatus !== 'PENDENTE' 
                ? `${o.home_team} <span class="score-inline">${o.result_score.split('-')[0]}</span> <span class="vs">vs</span> <span class="score-inline">${o.result_score.split('-')[1]}</span> ${o.away_team}` 
                : `${o.home_team} <span class="vs">vs</span> ${o.away_team}`}${suspectBadge}</td>
            <td style="font-size:11px">${o.league_name}</td>
            <td style="font-size:11px;color:var(--text-secondary)">${o.match_date}<br>${o.match_time}</td>
            <td>${gameStatusBadge}</td>
            <td>${resultBadge}${resultScore}${gameDetailHtml}</td>
            <td><span class="market-tag ${marketClass}">${o.market}</span></td>
            <td style="font-weight:600;font-size:11px;color:var(--accent-green);max-width:130px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${o.selection}">▶ ${o.selection}</td>
            <td class="odd-cell">${o.market_odd.toFixed(2)}</td>
            <td class="odd-cell" style="color:var(--accent-green)">${o.fair_odd ? o.fair_odd.toFixed(2) : '--'}</td>
            <td class="edge-cell ${edgeClass}">${o.edge_pct}</td>
            <td style="font-size:12px">${o.model_prob}%</td>
            <td><span class="badge ${confClass}">${o.confidence}</span></td>
            <td style="font-size:11px;text-align:center;font-weight:600;color:${(o.confidence_score||0) >= 65 ? 'var(--accent-green)' : (o.confidence_score||0) >= 42 ? 'var(--accent-yellow)' : 'var(--accent-red)'}">${(o.confidence_score||0).toFixed(0)}</td>
            <td style="font-size:10px;text-align:center">${(o.analysis_type||'PRE_JOGO') === 'PRE_JOGO' ? '<span title="Análise feita antes do jogo" style="color:var(--accent-green)">🟢 Pré</span>' : '<span title="Análise retroativa (jogo já iniciado/encerrado)" style="color:var(--accent-blue)">🔵 Retro</span>'}</td>
            <td style="font-weight:700;font-size:12px;text-align:center;white-space:nowrap">${
                resultStatus === 'GREEN' ? `<span style="color:var(--accent-green)">+${(o.market_odd - 1).toFixed(2)}u</span>` 
                : resultStatus === 'RED' ? `<span style="color:var(--accent-red)">-1.00u</span>` 
                : resultStatus === 'VOID' ? `<span style="color:var(--text-muted)">0.00u</span>` 
                : '<span style="color:var(--text-muted)">--</span>'
            }</td>
        </tr>`;
    }).join("");
}

// ═══════════════════════════════════════════
// RENDER MATCHES
// ═══════════════════════════════════════════
function renderMatches(data) {
    const matches = data || allMatches;
    document.getElementById("match-count").textContent = matches.length;
    const tbody = document.getElementById("match-tbody");

    // Pre-build opp summary per match
    const oppsByMatch = {};
    allOpps.forEach(o => {
        if (!oppsByMatch[o.match_id]) oppsByMatch[o.match_id] = [];
        oppsByMatch[o.match_id].push(o);
    });

    tbody.innerHTML = matches.map(m => {
        // Weather — only show real data
        const hasWeather = m.has_real_weather;
        const weatherIcon = !hasWeather ? '❓' : m.weather_rain > 5 ? "🌧️" : m.weather_wind > 20 ? "💨" : m.weather_temp > 30 ? "🌡️" : "☀️";
        const weatherText = hasWeather ? `${weatherIcon} ${m.weather_temp}°C` : `<span style="color:var(--text-muted)">N/D</span>`;

        // Game status
        const gs = getGameStatus(m.match_date, m.match_time);
        const statusBadge = gs.status === 'LIVE'
            ? '<span class="game-live">🔴 AO VIVO</span>'
            : gs.status === 'FINISHED'
            ? '<span class="game-finished">✔ Encerrado</span>'
            : `<span class="game-upcoming">${gs.timeLabel}</span>`;

        // Opportunities summary
        const mOpps = oppsByMatch[m.match_id] || [];
        const nOpps = mOpps.length;
        const greens = mOpps.filter(o => o.result_status === 'GREEN').length;
        const reds = mOpps.filter(o => o.result_status === 'RED').length;
        const voids = mOpps.filter(o => o.result_status === 'VOID').length;
        const pending = nOpps - greens - reds - voids;
        const bestEdge = nOpps > 0 ? Math.max(...mOpps.map(o => o.edge || 0)) : 0;
        const hasHigh = mOpps.some(o => o.confidence === 'ALTO');
        const hasMed = mOpps.some(o => o.confidence === 'MÉDIO');

        let oppsHtml = '';
        if (nOpps === 0) {
            oppsHtml = '<span style="color:var(--text-muted);font-size:11px">—</span>';
        } else {
            const edgeColor = bestEdge >= 10 ? 'var(--accent-green)' : bestEdge >= 5 ? 'var(--accent-yellow)' : 'var(--text-secondary)';
            const confDot = hasHigh ? '🟢' : hasMed ? '🟡' : '🔴';
            let resultSummary = '';
            if (greens + reds + voids > 0) {
                const parts = [];
                if (greens) parts.push(`<span style="color:var(--accent-green)">${greens}✅</span>`);
                if (reds) parts.push(`<span style="color:var(--accent-red)">${reds}❌</span>`);
                if (voids) parts.push(`<span style="color:var(--text-muted)">${voids}⬜</span>`);
                if (pending) parts.push(`<span style="color:var(--accent-yellow)">${pending}⏳</span>`);
                resultSummary = `<div style="font-size:10px;margin-top:2px">${parts.join(' ')}</div>`;
            }
            oppsHtml = `<div style="text-align:center">
                <span style="font-weight:800;color:${edgeColor};font-family:'JetBrains Mono';font-size:12px">${nOpps}</span>
                <span style="font-size:10px;color:var(--text-muted)">op${nOpps>1?'s':''}</span>
                ${confDot}
                <span style="font-size:10px;color:${edgeColor};font-family:'JetBrains Mono'">${bestEdge.toFixed(1)}%</span>
                ${resultSummary}
            </div>`;
        }

        // Result score (from opportunities if available)
        let resultHtml = '';
        const resolvedOpp = mOpps.find(o => o.result_score);
        if (resolvedOpp && resolvedOpp.result_score) {
            const score = resolvedOpp.result_score;
            const htScore = resolvedOpp.result_ht_score ? `<div style="font-size:9px;color:var(--text-muted)">HT: ${resolvedOpp.result_ht_score}</div>` : '';
            resultHtml = `<span class="score-inline">${score}</span>${htScore}`;
        } else if (gs.status === 'FINISHED') {
            resultHtml = '<span style="color:var(--text-muted);font-size:10px">Enc.</span>';
        } else {
            resultHtml = '<span style="color:var(--text-muted);font-size:11px">—</span>';
        }

        // Fatigue
        const fatigueIcons = (m.home_fatigue ? "⚡H " : "") + (m.away_fatigue ? "⚡A" : "");

        // Row class
        const rowClass = gs.status === 'LIVE' ? 'row-live' : gs.status === 'FINISHED' ? 'row-finished' : '';

        return `<tr class="${rowClass}" onclick="showMatchDetail(${m.match_id})" style="cursor:pointer">
            <td class="team-cell">${m.home_team} <span class="vs">vs</span> ${m.away_team}${fatigueIcons ? '<br><span style="font-size:10px;color:var(--accent-yellow)">' + fatigueIcons + '</span>' : ''}</td>
            <td style="font-size:11px">${m.league_name}<br><span style="font-size:10px;color:var(--text-muted)">${m.league_country}</span></td>
            <td style="font-size:12px;color:var(--text-secondary);white-space:nowrap">${m.match_date}<br>${m.match_time}</td>
            <td>${statusBadge}</td>
            <td style="text-align:center">${resultHtml}</td>
            <td style="white-space:nowrap"><span class="odd-cell" style="color:var(--accent-green)">${m.home_xg}</span> <span style="color:var(--text-muted);font-size:10px">×</span> <span class="odd-cell" style="color:var(--accent-blue)">${m.away_xg}</span></td>
            <td style="font-size:11px;white-space:nowrap"><span style="font-weight:700">${m.prob_home}%</span> / ${m.prob_draw}% / ${m.prob_away}%</td>
            <td style="font-size:12px">${m.prob_over25}%</td>
            <td style="font-size:12px">${m.prob_btts}%</td>
            <td style="font-size:11px">${weatherText}</td>
            <td>${oppsHtml}</td>
        </tr>`;
    }).join("");
}

// ═══════════════════════════════════════════
// RENDER LEAGUES
// ═══════════════════════════════════════════
function renderLeagues() {
    const grid = document.getElementById("league-grid");
    grid.innerHTML = allLeagues.sort((a,b) => b.opportunities - a.opportunities).map(l => {
        const oppColor = l.opportunities > 10 ? "var(--accent-green)" : l.opportunities > 0 ? "var(--accent-yellow)" : "var(--text-muted)";
        return `<div class="league-card">
            <div class="league-card-header">
                <div>
                    <div class="league-card-name">${l.name}</div>
                    <div class="league-card-country">${l.country}</div>
                </div>
                <div style="font-size:28px">🏆</div>
            </div>
            <div class="league-card-stats">
                <div class="league-card-stat">
                    <div class="num" style="color:var(--accent-blue)">${l.matches}</div>
                    <div class="lbl">Jogos</div>
                </div>
                <div class="league-card-stat">
                    <div class="num" style="color:${oppColor}">${l.opportunities}</div>
                    <div class="lbl">Oportunidades</div>
                </div>
            </div>
        </div>`;
    }).join("");
}

// ═══════════════════════════════════════════
// SORTING
// ═══════════════════════════════════════════
let currentSort = { key: 'date', dir: 'asc' };

function sortTable(th) {
    const key = th.dataset.sort;
    const type = th.dataset.type;
    
    // Toggle direction
    if (currentSort.key === key) {
        currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
    } else {
        currentSort.key = key;
        currentSort.dir = type === 'num' ? 'desc' : 'asc';
    }
    
    // Update header classes
    document.querySelectorAll('#opp-table th.sortable').forEach(h => {
        h.classList.remove('sort-asc', 'sort-desc');
    });
    th.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
    
    applyColumnFilters();
}

function getSortValue(o, key) {
    switch(key) {
        case 'index': return 0;
        case 'team': return (o.home_team + ' ' + o.away_team).toLowerCase();
        case 'league': return (o.league_name || '').toLowerCase();
        case 'date': return o.match_date + ' ' + o.match_time;
        case 'market': return o.market || '';
        case 'selection': return o.selection || '';
        case 'bookmaker': return (o.bookmaker || '').toLowerCase();
        case 'odd': return o.market_odd || 0;
        case 'fair_odd': return o.fair_odd || 0;
        case 'edge': return o.edge || 0;
        case 'kelly': return parseFloat((o.kelly_bet_pct || '0').replace('%', '')) || 0;
        case 'prob': return o.model_prob || 0;
        case 'confidence': return o.confidence === 'ALTO' ? 3 : o.confidence === 'MÉDIO' ? 2 : 1;
        case 'conf_score': return o.confidence_score || 0;
        case 'analysis_type': return (o.analysis_type || 'PRE_JOGO') === 'PRE_JOGO' ? 2 : 1;
        case 'dq': return (o.data_quality || 0) * 100;
        case 'result': return o.result_status === 'GREEN' ? 3 : o.result_status === 'RED' ? 2 : o.result_status === 'VOID' ? 1 : 0;
        case 'game_status': {
            const gs = getGameStatus(o.match_date, o.match_time);
            return gs.status === 'LIVE' ? 3 : gs.status === 'UPCOMING' ? 2 : 1;
        }
        case 'pnl': {
            const rs = o.result_status || 'PENDENTE';
            if (rs === 'GREEN') return (o.market_odd || 0) - 1;
            if (rs === 'RED') return -1;
            if (rs === 'VOID') return 0;
            return -999; // PENDENTE goes to bottom
        }
        default: return 0;
    }
}

// ═══════════════════════════════════════════
// MULTI-SELECT COMPONENT
// ═══════════════════════════════════════════
class MultiSelect {
    constructor(container, options = {}) {
        this.container = typeof container === 'string' ? document.getElementById(container) : container;
        this.placeholder = options.placeholder || 'Todos';
        this.onChange = options.onChange || (() => {});
        this.items = [];            // [{value, label}]
        this.selected = new Set();  // set of selected values
        this._open = false;
        this._build();
    }

    _build() {
        this.container.innerHTML = '';
        this.container.classList.add('ms-wrap');

        // Trigger button
        this.trigger = document.createElement('div');
        this.trigger.className = 'ms-trigger';
        this.trigger.innerHTML = `<span class="ms-placeholder">${this.placeholder}</span>`;
        this.trigger.addEventListener('click', (e) => { e.stopPropagation(); this.toggle(); });
        this.container.appendChild(this.trigger);

        // Dropdown
        this.dropdown = document.createElement('div');
        this.dropdown.className = 'ms-dropdown';
        this.dropdown.addEventListener('click', e => e.stopPropagation());

        // Search
        const searchWrap = document.createElement('div');
        searchWrap.className = 'ms-search-wrap';
        this.searchInput = document.createElement('input');
        this.searchInput.className = 'ms-search';
        this.searchInput.type = 'text';
        this.searchInput.placeholder = '🔍 Buscar...';
        this.searchInput.addEventListener('input', () => this._filterList());
        searchWrap.appendChild(this.searchInput);
        this.dropdown.appendChild(searchWrap);

        // Actions
        const actions = document.createElement('div');
        actions.className = 'ms-actions';
        const btnAll = document.createElement('button');
        btnAll.textContent = '✅ Todos';
        btnAll.addEventListener('click', () => this.selectAll());
        const btnNone = document.createElement('button');
        btnNone.textContent = '❌ Nenhum';
        btnNone.addEventListener('click', () => this.selectNone());
        const btnInvert = document.createElement('button');
        btnInvert.textContent = '🔄 Inverter';
        btnInvert.addEventListener('click', () => this.invertSelection());
        actions.appendChild(btnAll);
        actions.appendChild(btnNone);
        actions.appendChild(btnInvert);
        this.dropdown.appendChild(actions);

        // List
        this.listEl = document.createElement('div');
        this.listEl.className = 'ms-list';
        this.dropdown.appendChild(this.listEl);

        this.container.appendChild(this.dropdown);

        // Close on outside click
        document.addEventListener('click', () => this.close());
    }

    setItems(items) {
        // items: array of strings or {value, label}
        this.items = items.map(it => typeof it === 'string' ? { value: it, label: it } : it);
        this.selected.clear();
        this._renderList();
        this._updateTrigger();
    }

    _renderList() {
        const query = (this.searchInput?.value || '').toLowerCase();
        this.listEl.innerHTML = '';
        let visible = 0;
        this.items.forEach(it => {
            if (query && !it.label.toLowerCase().includes(query)) return;
            visible++;
            const el = document.createElement('div');
            el.className = 'ms-item' + (this.selected.has(it.value) ? ' ms-selected' : '');
            el.innerHTML = `<div class="ms-check">${this.selected.has(it.value) ? '✓' : ''}</div><div class="ms-label" title="${it.label}">${it.label}</div>`;
            el.addEventListener('click', () => {
                if (this.selected.has(it.value)) {
                    this.selected.delete(it.value);
                } else {
                    this.selected.add(it.value);
                }
                this._renderList();
                this._updateTrigger();
                this.onChange(this.getSelected());
            });
            this.listEl.appendChild(el);
        });
        if (visible === 0) {
            this.listEl.innerHTML = '<div class="ms-empty">Nenhum resultado</div>';
        }
    }

    _updateTrigger() {
        const count = this.selected.size;
        const total = this.items.length;
        if (count === 0 || count === total) {
            this.trigger.innerHTML = `<span class="ms-placeholder">${this.placeholder}</span>`;
        } else if (count <= 2) {
            const labels = [...this.selected].map(v => {
                const item = this.items.find(it => it.value === v);
                return item ? item.label : v;
            });
            this.trigger.innerHTML = `<span class="ms-count">${count}</span><span style="overflow:hidden;text-overflow:ellipsis">${labels.join(', ')}</span>`;
        } else {
            this.trigger.innerHTML = `<span class="ms-count">${count}</span><span>${count} de ${total} selecionados</span>`;
        }
    }

    _filterList() {
        this._renderList();
    }

    toggle() {
        this._open ? this.close() : this.open();
    }

    open() {
        // Close all other MultiSelects
        document.querySelectorAll('.ms-dropdown.ms-open').forEach(d => d.classList.remove('ms-open'));
        document.querySelectorAll('.ms-trigger.ms-active').forEach(t => t.classList.remove('ms-active'));
        this.dropdown.classList.add('ms-open');
        this.trigger.classList.add('ms-active');
        this._open = true;
        this.searchInput.value = '';
        this._renderList();
        setTimeout(() => this.searchInput.focus(), 50);
    }

    close() {
        this.dropdown.classList.remove('ms-open');
        this.trigger.classList.remove('ms-active');
        this._open = false;
    }

    getSelected() {
        // Returns empty array = "all" (no filter), otherwise array of selected values
        if (this.selected.size === 0 || this.selected.size === this.items.length) return [];
        return [...this.selected];
    }

    selectAll() {
        this.items.forEach(it => this.selected.add(it.value));
        this._renderList();
        this._updateTrigger();
        this.onChange(this.getSelected());
    }

    selectNone() {
        this.selected.clear();
        this._renderList();
        this._updateTrigger();
        this.onChange(this.getSelected());
    }

    invertSelection() {
        this.items.forEach(it => {
            if (this.selected.has(it.value)) this.selected.delete(it.value);
            else this.selected.add(it.value);
        });
        this._renderList();
        this._updateTrigger();
        this.onChange(this.getSelected());
    }

    reset() {
        this.selected.clear();
        this._renderList();
        this._updateTrigger();
    }

    setSelected(values) {
        this.selected = new Set(values.filter(v => this.items.some(it => it.value === v)));
        this._renderList();
        this._updateTrigger();
    }

    // Returns the raw internal selected set (not empty when "all" selected)
    getRawSelected() {
        return [...this.selected];
    }

    getAllItems() {
        return this.items.map(it => it.value);
    }

    hasActiveFilter() {
        return this.selected.size > 0 && this.selected.size < this.items.length;
    }
}

// Registry of all multi-selects
const msRegistry = {};

// ═══════════════════════════════════════════
// COLUMN FILTERS
// ═══════════════════════════════════════════
function applyColumnFilters() {
    const team = (document.getElementById('cf-team')?.value || '').toLowerCase();
    const leagueFilter = msRegistry['cf-league'] ? msRegistry['cf-league'].getSelected() : [];
    const dtStartRaw = document.getElementById('cf-dt-start')?.value || '';
    const dtEndRaw = document.getElementById('cf-dt-end')?.value || '';
    const dtStart = dtStartRaw ? new Date(dtStartRaw) : null;
    const dtEnd = dtEndRaw ? new Date(dtEndRaw) : null;
    const gameStatusFilter = msRegistry['cf-game-status'] ? msRegistry['cf-game-status'].getSelected() : [];
    const resultFilter = msRegistry['cf-result'] ? msRegistry['cf-result'].getSelected() : [];
    const marketFilter = msRegistry['cf-market'] ? msRegistry['cf-market'].getSelected() : [];
    const selectionFilter = msRegistry['cf-selection'] ? msRegistry['cf-selection'].getSelected() : [];
    const oddMin = parseFloat(document.getElementById('cf-odd-min')?.value) || null;
    const oddMax = parseFloat(document.getElementById('cf-odd-max')?.value) || null;
    const fairOddMin = parseFloat(document.getElementById('cf-fair-odd-min')?.value) || null;
    const fairOddMax = parseFloat(document.getElementById('cf-fair-odd-max')?.value) || null;
    const edgeMin = parseFloat(document.getElementById('cf-edge-min')?.value) || null;
    const edgeMax = parseFloat(document.getElementById('cf-edge-max')?.value) || null;
    const probMin = parseFloat(document.getElementById('cf-prob-min')?.value) || null;
    const probMax = parseFloat(document.getElementById('cf-prob-max')?.value) || null;
    const confidenceFilter = msRegistry['cf-confidence'] ? msRegistry['cf-confidence'].getSelected() : [];
    const scoreMin = parseFloat(document.getElementById('cf-score-min')?.value) || null;
    const scoreMax = parseFloat(document.getElementById('cf-score-max')?.value) || null;
    const analysisTypeFilter = msRegistry['cf-analysis-type'] ? msRegistry['cf-analysis-type'].getSelected() : [];

    let filtered = allOpps.filter(o => {
        if (team && !(o.home_team.toLowerCase().includes(team) || o.away_team.toLowerCase().includes(team))) return false;
        if (leagueFilter.length && !leagueFilter.includes(o.league_name)) return false;
        // Datetime range filter
        if (dtStart || dtEnd) {
            const timeParts = (o.match_time || '00:00').split(':');
            const dateParts = (o.match_date || '').split('-');
            if (dateParts.length >= 3) {
                const matchDt = new Date(
                    parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                    parseInt(timeParts[0]) || 0, parseInt(timeParts[1]) || 0, 0
                );
                if (dtStart && matchDt < dtStart) return false;
                if (dtEnd && matchDt > dtEnd) return false;
            }
        }
        // Game status filter (multi)
        if (gameStatusFilter.length) {
            const gs = getGameStatus(o.match_date, o.match_time);
            if (!gameStatusFilter.includes(gs.status)) return false;
        }
        if (resultFilter.length && !resultFilter.includes(o.result_status || 'PENDENTE')) return false;
        if (marketFilter.length && !marketFilter.some(m => o.market.includes(m))) return false;
        if (selectionFilter.length && !selectionFilter.includes(o.selection)) return false;
        if (oddMin !== null && o.market_odd < oddMin) return false;
        if (oddMax !== null && o.market_odd > oddMax) return false;
        if (fairOddMin !== null && (o.fair_odd || 0) < fairOddMin) return false;
        if (fairOddMax !== null && (o.fair_odd || 0) > fairOddMax) return false;
        if (edgeMin !== null && o.edge < edgeMin) return false;
        if (edgeMax !== null && o.edge > edgeMax) return false;
        if (probMin !== null && o.model_prob < probMin) return false;
        if (probMax !== null && o.model_prob > probMax) return false;
        if (confidenceFilter.length && !confidenceFilter.includes(o.confidence)) return false;
        if (scoreMin !== null && (o.confidence_score || 0) < scoreMin) return false;
        if (scoreMax !== null && (o.confidence_score || 0) > scoreMax) return false;
        if (analysisTypeFilter.length && !analysisTypeFilter.includes(o.analysis_type || 'PRE_JOGO')) return false;
        return true;
    });

    // Sort
    filtered.sort((a, b) => {
        const va = getSortValue(a, currentSort.key);
        const vb = getSortValue(b, currentSort.key);
        let cmp = 0;
        if (typeof va === 'number' && typeof vb === 'number') {
            cmp = va - vb;
        } else {
            cmp = String(va).localeCompare(String(vb));
        }
        return currentSort.dir === 'asc' ? cmp : -cmp;
    });

    // Status
    const statusEl = document.getElementById('filter-status');
    if (statusEl) {
        const total = allOpps.length;
        const shown = filtered.length;
        statusEl.textContent = shown < total ? `Exibindo ${shown} de ${total} oportunidades` : `${total} oportunidades`;
    }

    renderOpportunities(filtered);
}

function clearAllFilters() {
    clearAllFiltersGlobal();
}

function populateFilters() {
    // ── MAIN TABLE MULTI-SELECTS ──
    const leagues = [...new Set(allOpps.map(o => o.league_name))].filter(Boolean).sort();
    const markets = [...new Set(allOpps.map(o => o.market))].filter(Boolean).sort();

    // League
    if (!msRegistry['cf-league']) {
        msRegistry['cf-league'] = new MultiSelect('cf-league', { placeholder: 'Todas', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-league'].setItems(leagues);

    // Game Status
    if (!msRegistry['cf-game-status']) {
        msRegistry['cf-game-status'] = new MultiSelect('cf-game-status', { placeholder: 'Todos', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-game-status'].setItems([
        { value: 'LIVE', label: '🔴 Ao Vivo' },
        { value: 'FINISHED', label: '✔ Encerrado' },
        { value: 'UPCOMING', label: '📅 Futuro' },
    ]);

    // Result
    if (!msRegistry['cf-result']) {
        msRegistry['cf-result'] = new MultiSelect('cf-result', { placeholder: 'Todos', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-result'].setItems([
        { value: 'GREEN', label: '✅ GREEN' },
        { value: 'RED', label: '❌ RED' },
        { value: 'VOID', label: '⬜ VOID' },
        { value: 'PENDENTE', label: '⏳ PENDENTE' },
    ]);

    // Market
    if (!msRegistry['cf-market']) {
        msRegistry['cf-market'] = new MultiSelect('cf-market', { placeholder: 'Todos', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-market'].setItems(markets);

    // Selection
    const selections = [...new Set(allOpps.map(o => o.selection))].filter(Boolean).sort();
    if (!msRegistry['cf-selection']) {
        msRegistry['cf-selection'] = new MultiSelect('cf-selection', { placeholder: 'Todas', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-selection'].setItems(selections);

    // Confidence
    if (!msRegistry['cf-confidence']) {
        msRegistry['cf-confidence'] = new MultiSelect('cf-confidence', { placeholder: 'Todos', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-confidence'].setItems(['ALTO', 'MÉDIO', 'BAIXO']);

    // Analysis type
    if (!msRegistry['cf-analysis-type']) {
        msRegistry['cf-analysis-type'] = new MultiSelect('cf-analysis-type', { placeholder: 'Todos', onChange: () => applyColumnFilters() });
    }
    msRegistry['cf-analysis-type'].setItems(['PRE_JOGO', 'RETROATIVA']);

    // Match filters - league multi-select
    const matchLeagues = [...new Set(allMatches.map(m => m.league_name))].filter(Boolean).sort();
    if (!msRegistry['filter-match-league']) {
        msRegistry['filter-match-league'] = new MultiSelect('filter-match-league', { placeholder: 'Todas as Ligas', onChange: () => filterMatches() });
    }
    msRegistry['filter-match-league'].setItems(matchLeagues);
}

function filterOpps() {
    applyColumnFilters();
}

function filterMatches() {
    const leagueFilter = msRegistry['filter-match-league'] ? msRegistry['filter-match-league'].getSelected() : [];
    const dtStartRaw = document.getElementById("filter-match-dt-start")?.value || '';
    const dtEndRaw = document.getElementById("filter-match-dt-end")?.value || '';
    const dtStart = dtStartRaw ? new Date(dtStartRaw) : null;
    const dtEnd = dtEndRaw ? new Date(dtEndRaw) : null;
    const search = document.getElementById("filter-match-search").value.toLowerCase();

    let filtered = allMatches;
    if (leagueFilter.length) filtered = filtered.filter(m => leagueFilter.includes(m.league_name));
    if (dtStart || dtEnd) {
        filtered = filtered.filter(m => {
            const timeParts = (m.match_time || '00:00').split(':');
            const dateParts = (m.match_date || '').split('-');
            if (dateParts.length < 3) return true;
            const matchDt = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]) || 0, parseInt(timeParts[1]) || 0, 0
            );
            if (dtStart && matchDt < dtStart) return false;
            if (dtEnd && matchDt > dtEnd) return false;
            return true;
        });
    }
    if (search) filtered = filtered.filter(m =>
        m.home_team.toLowerCase().includes(search) ||
        m.away_team.toLowerCase().includes(search)
    );
    renderMatches(filtered);
}

// ═══════════════════════════════════════════
// MODALS
// ═══════════════════════════════════════════
function showOppDetail(idx) {
    const o = allOpps[idx];
    if (!o) return;
    const m = allMatches.find(x => x.match_id === o.match_id);
    
    document.getElementById("modal-title").textContent = `${o.home_team} vs ${o.away_team}`;
    document.getElementById("modal-subtitle").textContent = `${o.league_name} — ${o.league_country} | ${o.match_date} ${o.match_time}`;
    
    const confClass = o.confidence === "ALTO" ? "badge-high" : o.confidence === "MÉDIO" ? "badge-med" : "badge-low";
    const marketClass = getMarketClass(o.market);
    // Helper: valor seguro (trata null/undefined mas mantém 0 como válido)
    const v = (val, fallback = 'N/D') => (val !== null && val !== undefined) ? val : fallback;
    const dq = o.data_quality ?? 0;
    const dqPct = (dq * 100).toFixed(0);
    const dqColor = dq >= 0.80 ? 'var(--accent-green)' : dq >= 0.60 ? 'var(--accent-blue)' : dq >= 0.40 ? 'var(--accent-yellow)' : 'var(--accent-red)';
    const dqLabel = dq >= 0.80 ? 'EXCELENTE' : dq >= 0.60 ? 'BOA' : dq >= 0.40 ? 'MODERADA' : 'BAIXA';

    // Helper: stat comparison bar
    function statBar(homeVal, awayVal, label, suffix = '', decimals = 1) {
        const hRaw = homeVal;
        const aRaw = awayVal;
        const hv = parseFloat(hRaw);
        const av = parseFloat(aRaw);
        const hValid = hRaw !== null && hRaw !== undefined && !isNaN(hv);
        const aValid = aRaw !== null && aRaw !== undefined && !isNaN(av);
        // Se ambos são inválidos ou ambos são 0 e vieram de cache sem dados, exibir N/D
        if (!hValid && !aValid) {
            return `<div class="stat-row">
                <div class="stat-row-val home" style="color:var(--text-muted)">N/D</div>
                <div style="text-align:center"><div class="stat-row-label">${label}</div><div class="stat-bar-wrap"></div></div>
                <div class="stat-row-val away" style="color:var(--text-muted)">N/D</div>
            </div>`;
        }
        const h = hValid ? hv : 0;
        const a = aValid ? av : 0;
        const total = h + a || 1;
        const hPct = ((h / total) * 100).toFixed(0);
        const aPct = ((a / total) * 100).toFixed(0);
        const hColor = h > a ? 'var(--accent-green)' : h === a ? 'var(--text-secondary)' : 'var(--text-muted)';
        const aColor = a > h ? 'var(--accent-blue)' : a === h ? 'var(--text-secondary)' : 'var(--text-muted)';
        return `<div class="stat-row">
            <div class="stat-row-val home" style="color:${hColor}">${hValid ? h.toFixed(decimals) : 'N/D'}${hValid ? suffix : ''}</div>
            <div style="text-align:center">
                <div class="stat-row-label">${label}</div>
                <div class="stat-bar-wrap"><div class="stat-bar-home" style="width:${hPct}%"></div><div class="stat-bar-away" style="width:${aPct}%"></div></div>
            </div>
            <div class="stat-row-val away" style="color:${aColor}">${aValid ? a.toFixed(decimals) : 'N/D'}${aValid ? suffix : ''}</div>
        </div>`;
    }

    // Helper: form dots
    function formHtml(form) {
        if (!form || !form.length) return '<span style="color:var(--text-muted)">Sem dados</span>';
        return form.map(f => `<div class="form-dot form-${f}">${f}</div>`).join("");
    }
    function formSummary(form) {
        if (!form || !form.length) return '';
        const w = form.filter(x=>x==='W').length, d = form.filter(x=>x==='D').length, l = form.filter(x=>x==='L').length;
        return `${w}V ${d}E ${l}D`;
    }
    function formLabel(form) {
        if (!form || !form.length) return 'FORMA RECENTE';
        return `FORMA RECENTE (${form.length} jogos)`;
    }

    // Build match opps for this match
    const matchOpps = allOpps.filter(op => op.match_id === o.match_id && op !== o);

    // ── BUILD HTML ──
    document.getElementById("modal-body").innerHTML = `
        <!-- ══ ODDS SUSPECT WARNING ══ -->
        ${o.odds_suspect ? `
        <div style="background:linear-gradient(135deg,#2d2000,#1f1700);border:2px solid var(--accent-yellow);border-radius:12px;padding:14px 20px;margin-bottom:14px;display:flex;align-items:flex-start;gap:12px">
            <div style="font-size:22px;flex-shrink:0">⚠️</div>
            <div>
                <div style="font-size:13px;font-weight:800;color:var(--accent-yellow);margin-bottom:4px">POSSÍVEL INVERSÃO CASA / FORA</div>
                <div style="font-size:11px;color:var(--text-secondary);line-height:1.5">
                    As odds sugerem que a API pode ter invertido quem é mandante e visitante nesta partida.
                    O mandante designado (<strong>${o.home_team}</strong>) tem odds ${m ? m.odds_home.toFixed(2) : '?'} enquanto o visitante (<strong>${o.away_team}</strong>) tem odds ${m ? m.odds_away.toFixed(2) : '?'}.
                    Normalmente o mandante tem odds menores (é favorecido).
                    <br><strong>Ajuste aplicado:</strong> O modelo usou estatísticas NEUTRAS (média casa+fora) e removeu a vantagem de mando para evitar distorções.
                    <strong>Recomendação:</strong> Confirme manualmente na casa de apostas quem é o real mandante antes de apostar.
                </div>
            </div>
        </div>
        ` : ''}

        <!-- ══ SUGGESTION BANNER ══ -->
        <div style="background:linear-gradient(135deg,#0d2818,#0a1f12);border:2px solid ${o.odds_suspect ? 'var(--accent-yellow)' : 'var(--accent-green)'};border-radius:12px;padding:18px 24px;margin-bottom:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px">
            <div>
                <div style="font-size:10px;text-transform:uppercase;letter-spacing:2px;color:var(--text-muted);margin-bottom:4px">SUGESTÃO DE APOSTA${o.odds_suspect ? ' (⚠️ VERIFICAR CASA/FORA)' : ''}</div>
                <div style="font-size:20px;font-weight:800;color:${o.odds_suspect ? 'var(--accent-yellow)' : 'var(--accent-green)'}">${o.selection}</div>
                <div style="font-size:12px;color:var(--text-secondary);margin-top:2px">${o.market} — Odd <strong style="color:var(--accent-yellow)">${o.market_odd.toFixed(2)}</strong> (${o.bookmaker})</div>
            </div>
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
                ${o.odds_suspect ? '<span style="background:rgba(255,165,0,0.15);color:var(--accent-yellow);padding:5px 12px;border-radius:6px;font-size:11px;font-weight:700;border:1px solid rgba(255,165,0,0.3)">⚠️ VERIFICAR</span>' : ''}
                <span class="badge ${confClass}" style="font-size:12px;padding:5px 12px">${o.confidence} <span style="font-size:10px;opacity:0.8">(${(o.confidence_score||0).toFixed(0)})</span></span>
                <span style="background:${(o.analysis_type||'PRE_JOGO') === 'PRE_JOGO' ? 'rgba(0,255,100,0.1);color:var(--accent-green);border:1px solid rgba(0,255,100,0.3)' : 'rgba(100,149,237,0.1);color:var(--accent-blue);border:1px solid rgba(100,149,237,0.3)'};padding:5px 12px;border-radius:6px;font-size:11px;font-weight:700">${(o.analysis_type||'PRE_JOGO') === 'PRE_JOGO' ? '🟢 Pré-Jogo' : '🔵 Retroativa'}</span>
                <span style="background:var(--accent-green-dim);color:var(--accent-green);padding:5px 14px;border-radius:6px;font-weight:800;font-size:16px;font-family:'JetBrains Mono'">${o.edge_pct}</span>
                <span style="background:rgba(255,255,255,0.05);padding:5px 12px;border-radius:6px;font-size:12px;color:${dqColor};font-weight:700;border:1px solid ${dqColor}40">Dados: ${dqPct}%</span>
            </div>
        </div>

        <!-- ══ RESULTADO DO JOGO (se encerrado) ══ -->
        ${(o.result_status && o.result_status !== 'PENDENTE' && o.result_score) ? `
        <div style="margin-bottom:16px;padding:16px 20px;background:${o.result_status === 'GREEN' ? 'linear-gradient(135deg,#0d2818,#0a1f12)' : o.result_status === 'RED' ? 'linear-gradient(135deg,#2d0d0d,#1f0a0a)' : 'linear-gradient(135deg,#1a1a2e,#16213e)'};border:2px solid ${o.result_status === 'GREEN' ? 'var(--accent-green)' : o.result_status === 'RED' ? 'var(--accent-red)' : 'var(--text-muted)'};border-radius:12px">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
                <div style="font-size:10px;text-transform:uppercase;letter-spacing:2px;color:var(--text-muted)">RESULTADO DO JOGO</div>
                <span class="result-${o.result_status.toLowerCase()}" style="font-size:13px;padding:4px 14px">${o.result_status === 'GREEN' ? '✅ GREEN' : o.result_status === 'RED' ? '❌ RED' : '⬜ VOID'}</span>
            </div>
            <div style="display:flex;align-items:center;justify-content:center;gap:24px;margin-bottom:14px">
                <div style="text-align:center">
                    <div style="font-size:12px;color:var(--text-muted);margin-bottom:4px">${o.home_team}</div>
                    <div style="font-size:32px;font-weight:900;color:var(--text-primary);font-family:'JetBrains Mono'">${o.result_score.split('-')[0] || '?'}</div>
                </div>
                <div style="font-size:18px;color:var(--text-muted);font-weight:300">×</div>
                <div style="text-align:center">
                    <div style="font-size:12px;color:var(--text-muted);margin-bottom:4px">${o.away_team}</div>
                    <div style="font-size:32px;font-weight:900;color:var(--text-primary);font-family:'JetBrains Mono'">${o.result_score.split('-')[1] || '?'}</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px">
                ${o.result_ht_score ? '<div style="background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;text-align:center"><div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:3px">⏱️ Primeiro Tempo</div><div style="font-size:16px;font-weight:800;color:var(--text-primary);font-family:JetBrains Mono">' + o.result_ht_score + '</div></div>' : ''}
                ${o.result_corners ? '<div style="background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;text-align:center"><div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:3px">🚩 Escanteios</div><div style="font-size:16px;font-weight:800;color:var(--text-primary);font-family:JetBrains Mono">' + o.result_corners + '</div></div>' : ''}
                ${o.result_cards ? '<div style="background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;text-align:center"><div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:3px">🟨 Cartões</div><div style="font-size:16px;font-weight:800;color:var(--text-primary);font-family:JetBrains Mono">' + o.result_cards + '</div></div>' : ''}
                ${o.result_shots ? '<div style="background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;text-align:center"><div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:3px">🎯 Finalizações</div><div style="font-size:16px;font-weight:800;color:var(--text-primary);font-family:JetBrains Mono">' + o.result_shots + '</div></div>' : ''}
            </div>
        </div>
        ` : ''}

        <!-- ══ ONDE APOSTAR (topo) ══ -->
        <div style="margin-bottom:16px;padding:16px;background:var(--bg-secondary);border:1px solid var(--border);border-radius:var(--radius-sm)">
            <div class="detail-label" style="margin-bottom:8px">🏦 ONDE APOSTAR</div>
            <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:10px">
                ${bookmakerBadgeHtml(o.bookmaker, o.home_team, o.away_team, o.market, o.selection, false, o.league_country, o.league_name)}
                ${(() => {
                    const info = getBookmakerInfo(o.bookmaker);
                    if (info.footballUrl) {
                        return '<a href="' + info.footballUrl + '" target="_blank" rel="noopener" style="font-size:12px;color:var(--accent-cyan);text-decoration:none" onmouseover="this.style.textDecoration=\'underline\'" onmouseout="this.style.textDecoration=\'none\'">Abrir ' + info.name + ' →</a>';
                    }
                    return '';
                })()}
            </div>
            ${(() => {
                // Mostrar odds alternativas de outras casas para este mesmo mercado
                if (!m) return '';
                const mkts = m.all_markets || {};
                const oppMkt = o.market.toLowerCase();
                let foundMk = null;
                const mktMapping = {
                    '1x2': '1x2', 'dupla chance': 'double_chance',
                    'gols o/u': 'goals_ou', 'btts': 'btts', 'ambas marcam': 'btts',
                    'escanteios': 'corners_ou', 'cartoes': 'cards_ou', 'cartões': 'cards_ou',
                    'gols casa': 'home_goals_ou', 'gols fora': 'away_goals_ou',
                    'clean sheet casa': 'cs_home', 'clean sheet fora': 'cs_away',
                    'vit. s/ sofrer casa': 'wtn_home', 'vit. s/ sofrer fora': 'wtn_away',
                    'par/impar': 'odd_even', '1o tempo': 'ht_result',
                    'finaliz. gol 1x2': 'sot_1x2', 'finaliz. 1x2': 'shots_1x2',
                    'finaliz. gol o/u': 'sot_ou', 'finaliz. totais o/u': 'shots_ou',
                };
                for (const [label, key] of Object.entries(mktMapping)) {
                    if (oppMkt.includes(label)) { foundMk = key; break; }
                }
                if (!foundMk) {
                    for (const k of Object.keys(mkts)) {
                        if (oppMkt.includes(k.replace(/_/g,' '))) { foundMk = k; break; }
                    }
                }
                if (!foundMk || !mkts[foundMk]) return '';
                const bkData = mkts[foundMk]._bookmakers;
                if (!bkData || Object.keys(bkData).length <= 1) return '';
                const probs = (m && m.model_probs) || {};

                const selLower = o.selection.toLowerCase();
                // Extrair linha numérica da seleção (ex: "Under 2.5 Gols" → "2.5")
                const lineMatch = selLower.match(/(\d+\.?\d*)/);
                const lineNum = lineMatch ? lineMatch[1] : null;
                const selMapping = {
                    'vitória casa': 'home', 'vitória fora': 'away', 'empate': 'draw',
                    'casa ou empate': 'home/draw', 'fora ou empate': 'draw/away',
                    'sim': 'yes', 'não': 'no',
                };
                let selKey = null;
                for (const [label, key] of Object.entries(selMapping)) {
                    if (selLower.includes(label)) { selKey = key; break; }
                }
                // Para mercados Over/Under: incluir a linha no selKey (ex: "over_2.5", "under_2.5")
                if (!selKey && (selLower.includes('over') || selLower.includes('under'))) {
                    const ouDir = selLower.includes('over') ? 'over' : 'under';
                    selKey = lineNum ? `${ouDir}_${lineNum}` : ouDir;
                }
                if (!selKey) {
                    selKey = selLower.replace(/ /g, '_');
                }

                let altHtml = '<div style="margin-top:10px;padding:10px 14px;background:rgba(46,213,115,0.04);border:1px solid rgba(46,213,115,0.15);border-radius:8px">';
                altHtml += '<div style="font-size:11px;font-weight:700;color:var(--accent-green);margin-bottom:8px">📊 Mesma aposta em outras casas:</div>';
                altHtml += '<div style="display:flex;flex-wrap:wrap;gap:8px">';
                let hasAlts = false;

                const entries = [];
                for (const [bkn, vals] of Object.entries(bkData)) {
                    let val = vals[selKey];
                    if (val == null || val === 0) {
                        // Busca exata primeiro: se selKey = "under_2.5", buscar exatamente essa chave
                        // Fallback parcial somente se não houver linha numérica
                        for (const [k2, v2] of Object.entries(vals)) {
                            if (typeof v2 === 'number' && v2 > 1.0 && k2 === selKey) { val = v2; break; }
                        }
                        // Se ainda não encontrou e NÃO tem linha numérica, tentar parcial
                        if ((val == null || val === 0) && !lineNum) {
                            for (const [k2, v2] of Object.entries(vals)) {
                                if (typeof v2 === 'number' && v2 > 1.0 && k2.includes(selKey)) { val = v2; break; }
                                if (typeof v2 === 'number' && v2 > 1.0 && selKey.includes(k2)) { val = v2; break; }
                            }
                        }
                    }
                    if (typeof val === 'number' && val > 1.0) {
                        entries.push([bkn, val]);
                    }
                }
                entries.sort((a, b) => b[1] - a[1]);
                const bestVal = entries.length > 0 ? entries[0][1] : 0;

                for (const [bkn, val] of entries) {
                    if (bkn === o.bookmaker) continue;
                    hasAlts = true;
                    const info2 = getBookmakerInfo(bkn);
                    const link2 = info2.footballUrl;
                    const isBest = val === bestVal;
                    const borderColor = isBest ? 'var(--accent-green)' : 'var(--border)';
                    const mp = probs[`${foundMk}__${selKey}`];
                    const isEV3 = mp && (mp * val - 1) > 0.03;
                    altHtml += `<div style="padding:6px 12px;background:var(--bg-primary);border:1px solid ${borderColor};border-radius:8px;text-align:center;min-width:90px">`;
                    if (link2) {
                        altHtml += `<a href="${link2}" target="_blank" rel="noopener" onclick="event.stopPropagation()" style="font-size:11px;font-weight:700;color:${info2.color || 'var(--accent-cyan)'};text-decoration:none" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${info2.name}</a>`;
                    } else {
                        altHtml += `<div style="font-size:11px;font-weight:700;color:var(--text-secondary)">${bkn}</div>`;
                    }
                    altHtml += `<div style="font-size:16px;font-weight:800;color:${isBest ? 'var(--accent-green)' : 'var(--text-primary)'};font-family:'JetBrains Mono',monospace;margin-top:2px">${val.toFixed(2)}${isBest ? ' ★' : ''}</div>`;
                    if (isEV3) altHtml += `<div style="font-size:9px;color:var(--accent-green);font-weight:700">EV+</div>`;
                    altHtml += '</div>';
                }
                altHtml += '</div></div>';
                return hasAlts ? altHtml : '';
            })()}
            <div style="padding:10px 14px;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:8px;font-size:12px;margin-top:10px">
                <div style="color:var(--accent-cyan);font-weight:700;margin-bottom:4px">Como encontrar:</div>
                <div style="color:var(--text-secondary);line-height:1.6">
                    Futebol → <strong style="color:var(--accent-yellow)">${o.league_country || '?'}</strong> → <strong style="color:var(--accent-yellow)">${o.league_name || '?'}</strong> → <strong style="color:var(--text-primary)">${o.home_team} vs ${o.away_team}</strong> → <strong style="color:var(--accent-green)">${o.market}: ${o.selection}</strong>
                </div>
            </div>
        </div>

        <!-- ══ TABS ══ -->
        <div class="modal-tabs">
            <button class="modal-tab active" onclick="switchModalTab(this, 'tab-teams')">⚔️ Comparativo</button>
            <button class="modal-tab" onclick="switchModalTab(this, 'tab-stats')">📊 Estatísticas</button>
            <button class="modal-tab" onclick="switchModalTab(this, 'tab-odds')">💰 Odds & Valor</button>
            <button class="modal-tab" onclick="switchModalTab(this, 'tab-context')">🌍 Contexto</button>
            <button class="modal-tab" onclick="switchModalTab(this, 'tab-analysis')">🧠 Análise Técnica</button>
        </div>

        <!-- ══ TAB 1: COMPARATIVO ══ -->
        <div id="tab-teams" class="modal-tab-content active">
            <div class="team-compare">
                <div class="team-col team-col-home">
                    <div class="team-name-lg" style="color:var(--accent-green)">${o.home_team}</div>
                    <div class="team-badge-info">${m ? (v(m.home_league_pos,'') ? m.home_league_pos + '° lugar' : '') + (v(m.home_league_pts,'') !== '' ? ' • ' + m.home_league_pts + ' pts' : '') + (v(m.home_games_played,'') !== '' ? ' • ' + m.home_games_played + ' jogos' : '') : 'N/D'}</div>
                    <div style="margin-bottom:6px"><span style="font-size:10px;color:var(--text-muted)">${m ? formLabel(m.home_form) : 'FORMA RECENTE'}</span></div>
                    <div class="form-dots" style="justify-content:flex-end">${m ? formHtml(m.home_form) : 'N/D'}</div>
                    <div style="font-size:11px;color:var(--text-muted);margin-top:4px">${m ? formSummary(m.home_form) : ''}</div>
                </div>
                <div class="team-col-vs">VS</div>
                <div class="team-col team-col-away">
                    <div class="team-name-lg" style="color:var(--accent-blue)">${o.away_team}</div>
                    <div class="team-badge-info">${m ? (v(m.away_league_pos,'') ? m.away_league_pos + '° lugar' : '') + (v(m.away_league_pts,'') !== '' ? ' • ' + m.away_league_pts + ' pts' : '') + (v(m.away_games_played,'') !== '' ? ' • ' + m.away_games_played + ' jogos' : '') : 'N/D'}</div>
                    <div style="margin-bottom:6px"><span style="font-size:10px;color:var(--text-muted)">${m ? formLabel(m.away_form) : 'FORMA RECENTE'}</span></div>
                    <div class="form-dots">${m ? formHtml(m.away_form) : 'N/D'}</div>
                    <div style="font-size:11px;color:var(--text-muted);margin-top:4px">${m ? formSummary(m.away_form) : ''}</div>
                </div>
            </div>

            ${m ? `
            <div style="background:var(--bg-secondary);border:1px solid var(--border);border-radius:12px;padding:16px 20px">
                ${statBar(m.home_attack, m.away_attack, 'Ataque (α)', '', 2)}
                ${statBar(m.home_defense, m.away_defense, 'Defesa (β)', '', 2)}
                ${statBar(m.home_goals_scored_avg, m.away_goals_scored_avg, 'Gols Marcados/Jogo', '')}
                ${statBar(m.home_goals_conceded_avg, m.away_goals_conceded_avg, 'Gols Sofridos/Jogo', '')}
                ${statBar(m.home_xg, m.away_xg, 'xG Esperado (Modelo)', '')}
                ${statBar(m.home_shots_total_avg ?? null, m.away_shots_total_avg ?? null, 'Finalizações Totais/Jogo', '')}
                ${statBar(m.home_shots_on_target_avg, m.away_shots_on_target_avg, 'Finalizações no Gol/Jogo', '')}
                ${statBar(m.home_corners_avg, m.away_corners_avg, 'Escanteios/Jogo', '')}
                ${statBar(m.home_cards_avg, m.away_cards_avg, 'Cartões/Jogo', '')}
                ${statBar(m.home_fouls_avg, m.away_fouls_avg, 'Faltas/Jogo', '')}
                ${statBar(m.home_possession, m.away_possession, 'Posse Terço Final', '')}
                ${statBar(m.home_form_points, m.away_form_points, 'Pontos de Forma', '', 2)}
            </div>
            ` : '<div style="color:var(--text-muted);padding:16px;text-align:center">Dados da partida não disponíveis no cache</div>'}

            ${m && (m.injuries_home?.length > 0 || m.injuries_away?.length > 0) ? `
            <div class="m-section">🏥 Lesões & Desfalques</div>
            <div class="ctx-grid">
                <div class="ctx-card">
                    <div class="ctx-card-title">${o.home_team}</div>
                    <div class="ctx-card-body">${m.injuries_home?.length > 0 ? m.injuries_home.map(i => '<div style="color:var(--accent-red);margin-bottom:3px">• ' + i + '</div>').join('') : '<span style="color:var(--accent-green)">Sem desfalques reportados</span>'}</div>
                </div>
                <div class="ctx-card">
                    <div class="ctx-card-title">${o.away_team}</div>
                    <div class="ctx-card-body">${m.injuries_away?.length > 0 ? m.injuries_away.map(i => '<div style="color:var(--accent-red);margin-bottom:3px">• ' + i + '</div>').join('') : '<span style="color:var(--accent-green)">Sem desfalques reportados</span>'}</div>
                </div>
            </div>
            ` : ''}

            <!-- ══ HISTÓRICO DE JOGOS (carregado sob demanda) ══ -->
            ${m ? `
            <div class="m-section" style="margin-top:20px">📋 Historico de Jogos Recentes</div>
            <div id="history-container" style="background:var(--bg-secondary);border:1px solid var(--border);border-radius:12px;padding:16px 20px">
                <div style="display:flex;gap:8px;margin-bottom:16px">
                    <button id="btn-load-history" onclick="loadTeamHistory(${m.home_team_id ?? 0}, ${m.away_team_id ?? 0}, ${m.league_id ?? 0}, '${(o.home_team||'').replace(/'/g,"\\'")}', '${(o.away_team||'').replace(/'/g,"\\'")}', '${(o.league_name||'').replace(/'/g,"\\'")}' )" style="flex:1;padding:10px 16px;background:var(--accent-green-dim);color:var(--accent-green);border:1px solid var(--accent-green)40;border-radius:8px;cursor:pointer;font-weight:700;font-size:13px">
                        Carregar Historico Detalhado + Confronto Direto
                    </button>
                </div>
                <div id="history-content" style="color:var(--text-muted);font-size:12px;text-align:center">
                    Clique acima para carregar historico e confronto direto (usa cache)
                </div>
            </div>
            ` : ''}
        </div>

        <!-- ══ TAB 2: ESTATÍSTICAS DETALHADAS ══ -->
        <div id="tab-stats" class="modal-tab-content">
            ${m ? `
            <div class="m-section">📈 Estatísticas Detalhadas por Time</div>
            <div style="overflow-x:auto">
                <table style="width:100%;border-collapse:collapse;min-width:auto">
                    <thead>
                        <tr>
                            <th style="text-align:left;padding:8px 12px;font-size:11px;background:var(--bg-secondary);border-bottom:1px solid var(--border);color:var(--text-muted)">MÉTRICA</th>
                            <th style="text-align:center;padding:8px 12px;font-size:11px;background:var(--bg-secondary);border-bottom:1px solid var(--border);color:var(--accent-green)">${o.home_team}</th>
                            <th style="text-align:center;padding:8px 12px;font-size:11px;background:var(--bg-secondary);border-bottom:1px solid var(--border);color:var(--accent-blue)">${o.away_team}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${buildStatsTableRows(m)}
                    </tbody>
                </table>
            </div>

            <div class="m-section" style="margin-top:24px">📊 Probabilidades do Modelo</div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:16px">
                <div style="text-align:center;padding:16px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:10px;text-transform:uppercase;color:var(--text-muted);margin-bottom:6px">Vitória Casa</div>
                    <div style="font-size:24px;font-weight:800;color:var(--accent-green);font-family:'JetBrains Mono'">${m.prob_home}%</div>
                </div>
                <div style="text-align:center;padding:16px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:10px;text-transform:uppercase;color:var(--text-muted);margin-bottom:6px">Empate</div>
                    <div style="font-size:24px;font-weight:800;color:var(--text-secondary);font-family:'JetBrains Mono'">${m.prob_draw}%</div>
                </div>
                <div style="text-align:center;padding:16px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:10px;text-transform:uppercase;color:var(--text-muted);margin-bottom:6px">Vitória Fora</div>
                    <div style="font-size:24px;font-weight:800;color:var(--accent-blue);font-family:'JetBrains Mono'">${m.prob_away}%</div>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px">
                <div style="text-align:center;padding:12px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:9px;text-transform:uppercase;color:var(--text-muted);margin-bottom:4px">Over 2.5</div>
                    <div style="font-size:18px;font-weight:800;color:var(--accent-purple);font-family:'JetBrains Mono'">${m.prob_over25}%</div>
                </div>
                <div style="text-align:center;padding:12px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:9px;text-transform:uppercase;color:var(--text-muted);margin-bottom:4px">BTTS</div>
                    <div style="font-size:18px;font-weight:800;color:var(--accent-cyan);font-family:'JetBrains Mono'">${m.prob_btts}%</div>
                </div>
                <div style="text-align:center;padding:12px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:9px;text-transform:uppercase;color:var(--text-muted);margin-bottom:4px">Escanteios Exp.</div>
                    <div style="font-size:18px;font-weight:800;color:var(--accent-yellow);font-family:'JetBrains Mono'">${m.corners_expected}</div>
                </div>
                <div style="text-align:center;padding:12px;background:var(--bg-secondary);border-radius:10px;border:1px solid var(--border)">
                    <div style="font-size:9px;text-transform:uppercase;color:var(--text-muted);margin-bottom:4px">Cartões Exp.</div>
                    <div style="font-size:18px;font-weight:800;color:var(--accent-red);font-family:'JetBrains Mono'">${m.cards_expected}</div>
                </div>
            </div>
            ` : '<div style="color:var(--text-muted);padding:16px;text-align:center">Dados não disponíveis</div>'}
        </div>

        <!-- ══ TAB 3: ODDS & VALOR ══ -->
        <div id="tab-odds" class="modal-tab-content">
            <div class="m-section">💰 Análise de Valor</div>
            <div class="detail-grid">
                <div class="detail-item">
                    <div class="detail-label">Odd de Mercado</div>
                    <div class="detail-value" style="font-family:'JetBrains Mono';font-size:22px;color:var(--accent-yellow)">${o.market_odd.toFixed(2)}</div>
                    <div style="font-size:11px;color:var(--text-muted)">${o.bookmaker}</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Odd Justa (Modelo)</div>
                    <div class="detail-value" style="font-family:'JetBrains Mono';font-size:22px;color:var(--accent-green)">${o.fair_odd.toFixed(2)}</div>
                    <div style="font-size:11px;color:var(--text-muted)">Dixon-Coles + Monte Carlo</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Prob. do Modelo</div>
                    <div class="detail-value" style="font-size:22px">${o.model_prob}%</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Prob. Implícita (De-Vig)</div>
                    <div class="detail-value" style="font-size:22px;color:var(--text-secondary)">${o.implied_prob}%</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Edge</div>
                    <div class="detail-value" style="font-family:'JetBrains Mono';font-size:22px;color:var(--accent-green)">${o.edge_pct}</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Kelly Sugerido</div>
                    <div class="detail-value" style="font-size:22px">${o.kelly_bet_pct}</div>
                </div>
            </div>

            ${m ? `
            <div class="m-section">📋 Todas as Odds & Probabilidades do Modelo (Principal: ${m.bookmaker})</div>
            ${buildAllMarketsOdds(m)}
            ` : ''}

            ${matchOpps.length > 0 ? `
            <div class="m-section" style="margin-top:20px">🎯 Outras Oportunidades neste Jogo</div>
            ${matchOpps.map(op => {
                const opConf = op.confidence === 'ALTO' ? 'badge-high' : op.confidence === 'MÉDIO' ? 'badge-med' : 'badge-low';
                return '<div style="display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);flex-wrap:wrap;gap:8px"><div style="display:flex;align-items:center;gap:8px"><span class="badge ' + opConf + '">' + op.confidence + '</span><span style="font-size:13px">' + op.market + ': <strong>' + op.selection + '</strong></span><span style="font-family:\'JetBrains Mono\';font-size:12px;color:var(--text-secondary)">@' + op.market_odd.toFixed(2) + '</span></div><span style="font-weight:800;color:var(--accent-green);font-family:\'JetBrains Mono\'">' + op.edge_pct + '</span></div>';
            }).join('')}
            ` : ''}
        </div>

        <!-- ══ TAB 4: CONTEXTO ══ -->
        <div id="tab-context" class="modal-tab-content">
            <div class="m-section">🏟️ Informações do Jogo</div>
            <div class="ctx-grid">
                <div class="ctx-card">
                    <div class="ctx-card-title">📍 Estádio</div>
                    <div class="ctx-card-body">${m?.venue || 'N/D'}</div>
                </div>
                <div class="ctx-card">
                    <div class="ctx-card-title">👨‍⚖️ Árbitro</div>
                    <div class="ctx-card-body">
                        ${m && m.referee && m.referee !== 'Desconhecido' ? m.referee : '<span style="color:var(--text-muted)">Não identificado</span>'}
                        ${m && m.referee_cards_avg != null ? '<br><span style="font-size:11px;color:var(--text-muted)">' + m.referee_cards_avg + ' cartões/jogo • ' + (m.referee_fouls_avg ?? '?') + ' faltas/jogo</span>' : ''}
                    </div>
                </div>
                <div class="ctx-card">
                    <div class="ctx-card-title">🌤️ Clima</div>
                    <div class="ctx-card-body">
                        ${m ? m.weather_desc + '<br>' + m.weather_temp + '°C • Vento: ' + (m.weather_wind ? m.weather_wind.toFixed(0) : '?') + ' km/h' + (m.weather_rain > 0 ? ' • Chuva: ' + m.weather_rain + 'mm' : '') : o.weather_note}
                    </div>
                </div>
                <div class="ctx-card">
                    <div class="ctx-card-title">⚡ Fadiga</div>
                    <div class="ctx-card-body">
                        ${m ? (m.home_fatigue ? '<span style="color:var(--accent-yellow)">' + o.home_team + ' — jogou nas últimas 72h</span><br>' : '') + (m.away_fatigue ? '<span style="color:var(--accent-yellow)">' + o.away_team + ' — jogou nas últimas 72h</span>' : '') + (!m.home_fatigue && !m.away_fatigue ? '<span style="color:var(--accent-green)">Nenhum time com fadiga</span>' : '') : 'N/D'}
                    </div>
                </div>
            </div>

            ${m ? `
            <div class="m-section">🏆 Contexto Competitivo</div>
            <div class="ctx-grid">
                <div class="ctx-card">
                    <div class="ctx-card-title" style="color:var(--accent-green)">${o.home_team}</div>
                    <div class="ctx-card-body">
                        <div style="margin-bottom:6px"><strong>${v(m.home_league_pos, '?')}° lugar</strong> — ${v(m.home_league_pts, '?')} pts</div>
                        <div style="margin-bottom:4px">Jogos: ${v(m.home_games_played, '?')} disputados, ${v(m.home_games_remaining, '?')} restantes</div>
                        <div style="margin-bottom:4px">Distância p/ título: <strong style="color:${(v(m.home_points_to_title, 99) <= 10) ? 'var(--accent-green)' : 'var(--text-secondary)'}">${v(m.home_points_to_title, 99) !== 99 ? m.home_points_to_title + ' pts' : 'N/D'}</strong></div>
                        <div>Distância p/ rebaixamento: <strong style="color:${(v(m.home_points_to_relegation, 99) <= 5) ? 'var(--accent-red)' : 'var(--text-secondary)'}">${v(m.home_points_to_relegation, 99) !== 99 ? m.home_points_to_relegation + ' pts' : 'N/D'}</strong></div>
                        <div style="margin-top:6px">Urgência: <strong>${m.urgency_home != null ? Number(m.urgency_home).toFixed(1) : '?'}</strong>/1.0</div>
                    </div>
                </div>
                <div class="ctx-card">
                    <div class="ctx-card-title" style="color:var(--accent-blue)">${o.away_team}</div>
                    <div class="ctx-card-body">
                        <div style="margin-bottom:6px"><strong>${v(m.away_league_pos, '?')}° lugar</strong> — ${v(m.away_league_pts, '?')} pts</div>
                        <div style="margin-bottom:4px">Jogos: ${v(m.away_games_played, '?')} disputados, ${v(m.away_games_remaining, '?')} restantes</div>
                        <div style="margin-bottom:4px">Distância p/ título: <strong style="color:${(v(m.away_points_to_title, 99) <= 10) ? 'var(--accent-green)' : 'var(--text-secondary)'}">${v(m.away_points_to_title, 99) !== 99 ? m.away_points_to_title + ' pts' : 'N/D'}</strong></div>
                        <div>Distância p/ rebaixamento: <strong style="color:${(v(m.away_points_to_relegation, 99) <= 5) ? 'var(--accent-red)' : 'var(--text-secondary)'}">${v(m.away_points_to_relegation, 99) !== 99 ? m.away_points_to_relegation + ' pts' : 'N/D'}</strong></div>
                        <div style="margin-top:6px">Urgência: <strong>${m.urgency_away != null ? Number(m.urgency_away).toFixed(1) : '?'}</strong>/1.0</div>
                    </div>
                </div>
            </div>
            ` : ''}

            <div class="m-section">📊 Qualidade dos Dados</div>
            <div style="background:var(--bg-secondary);border:1px solid var(--border);border-radius:10px;padding:16px">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
                    <div style="font-size:28px;font-weight:800;color:${dqColor};font-family:'JetBrains Mono'">${dqPct}%</div>
                    <div>
                        <div style="font-size:13px;font-weight:700;color:${dqColor}">${dqLabel}</div>
                        <div style="font-size:11px;color:var(--text-muted)">Índice de confiança dos dados</div>
                    </div>
                </div>
                ${m ? `
                <div style="font-size:12px;color:var(--text-secondary);line-height:1.8">
                    ${m.has_real_odds ? '✅' : '❌'} Odds Reais ${m.has_real_odds ? '(' + m.bookmaker + ')' : '— Estimadas'}<br>
                    ${m.has_real_standings ? '✅' : '❌'} Standings Reais<br>
                    ${m.home_has_real_data ? '✅' : '⚠️'} ${o.home_team}: ${m.home_has_real_data ? 'Dados reais da API' : 'Estimado'}<br>
                    ${m.away_has_real_data ? '✅' : '⚠️'} ${o.away_team}: ${m.away_has_real_data ? 'Dados reais da API' : 'Estimado'}<br>
                    ${m.has_real_weather ? '✅' : '❌'} Clima Real<br>
                    ${m.referee && m.referee !== 'Desconhecido' ? '✅' : '❌'} Árbitro Identificado
                </div>
                ` : ''}
            </div>
        </div>

        <!-- ══ TAB 5: ANÁLISE TÉCNICA ══ -->
        <div id="tab-analysis" class="modal-tab-content">
            ${buildExecutiveSummary(o)}
            <div style="padding:16px;background:var(--bg-secondary);border:1px solid var(--border);border-radius:8px;overflow-x:auto;margin-top:12px">
                <pre style="font-family:'JetBrains Mono','Fira Code',monospace;font-size:11.5px;line-height:1.7;color:var(--text-secondary);white-space:pre-wrap;word-break:break-word;margin:0">${buildDetailedAnalysis(o)}</pre>
            </div>
        </div>
    `;
    document.getElementById("modal-overlay").classList.add("show");
}

// ── MODAL TAB SWITCH ──
function switchModalTab(btn, tabId) {
    document.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.modal-tab-content').forEach(t => t.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(tabId).classList.add('active');
}

// ── BUILD STATS TABLE ROWS ──
function buildStatsTableRows(m) {
    const rows = [
        ['Posição na Liga', m.home_league_pos ? m.home_league_pos + '°' : 'N/D', m.away_league_pos ? m.away_league_pos + '°' : 'N/D'],
        ['Pontos', m.home_league_pts ?? 'N/D', m.away_league_pts ?? 'N/D'],
        ['Jogos Disputados', m.home_games_played ?? 'N/D', m.away_games_played ?? 'N/D'],
        ['Jogos Restantes', m.home_games_remaining ?? 'N/D', m.away_games_remaining ?? 'N/D'],
        ['Força de Ataque (α)', m.home_attack ?? 'N/D', m.away_attack ?? 'N/D'],
        ['Força de Defesa (β)', m.home_defense ?? 'N/D', m.away_defense ?? 'N/D'],
        ['xG Esperado', m.home_xg ?? 'N/D', m.away_xg ?? 'N/D'],
        ['Gols Marcados/Jogo', m.home_goals_scored_avg ?? 'N/D', m.away_goals_scored_avg ?? 'N/D'],
        ['Gols Sofridos/Jogo', m.home_goals_conceded_avg ?? 'N/D', m.away_goals_conceded_avg ?? 'N/D'],
        ['Finalizações Totais/Jogo', m.home_shots_total_avg ?? 'N/D', m.away_shots_total_avg ?? 'N/D'],
        ['Finalizações no Gol/Jogo', m.home_shots_on_target_avg ?? 'N/D', m.away_shots_on_target_avg ?? 'N/D'],
        ['Finalizações Bloqueadas/Jogo', m.home_shots_blocked_avg ?? 'N/D', m.away_shots_blocked_avg ?? 'N/D'],
        ['Escanteios/Jogo', m.home_corners_avg ?? 'N/D', m.away_corners_avg ?? 'N/D'],
        ['Cartões/Jogo', m.home_cards_avg ?? 'N/D', m.away_cards_avg ?? 'N/D'],
        ['Faltas/Jogo', m.home_fouls_avg ?? 'N/D', m.away_fouls_avg ?? 'N/D'],
        ['Posse Terço Final', m.home_possession ?? 'N/D', m.away_possession ?? 'N/D'],
        ['Pontos de Forma', m.home_form_points ?? 'N/D', m.away_form_points ?? 'N/D'],
        ['Urgência', m.urgency_home?.toFixed(1) ?? 'N/D', m.urgency_away?.toFixed(1) ?? 'N/D'],
        ['Fadiga (72h)', m.home_fatigue ? 'SIM' : 'NÃO', m.away_fatigue ? 'SIM' : 'NÃO'],
    ];
    
    return rows.map((r, i) => {
        const bg = i % 2 === 0 ? 'transparent' : 'rgba(255,255,255,0.02)';
        const hVal = parseFloat(r[1]);
        const aVal = parseFloat(r[2]);
        const hBold = !isNaN(hVal) && !isNaN(aVal) && hVal > aVal;
        const aBold = !isNaN(hVal) && !isNaN(aVal) && aVal > hVal;
        // Invert for "Gols Sofridos" and "Fadiga" (lower is better)
        const invertMetrics = ['Gols Sofridos/Jogo', 'Fadiga (72h)'];
        const inv = invertMetrics.includes(r[0]);
        const hStyle = (inv ? aBold : hBold) ? 'color:var(--accent-green);font-weight:800' : '';
        const aStyle = (inv ? hBold : aBold) ? 'color:var(--accent-blue);font-weight:800' : '';
        return '<tr style="background:' + bg + '"><td style="padding:7px 12px;font-size:12px;color:var(--text-muted);border-bottom:1px solid rgba(255,255,255,0.04)">' + r[0] + '</td><td style="text-align:center;padding:7px 12px;font-family:\'JetBrains Mono\';font-size:13px;border-bottom:1px solid rgba(255,255,255,0.04);' + hStyle + '">' + r[1] + '</td><td style="text-align:center;padding:7px 12px;font-family:\'JetBrains Mono\';font-size:13px;border-bottom:1px solid rgba(255,255,255,0.04);' + aStyle + '">' + r[2] + '</td></tr>';
    }).join('');
}

// ── RESUMO EXECUTIVO — Por que o modelo vê valor? ──
function buildExecutiveSummary(o) {
    const m = allMatches.find(x => x.match_id === o.match_id);
    if (!m) return '';

    const modelP = o.model_prob / 100;
    const impliedP = o.implied_prob / 100;
    const edge = parseFloat(o.edge_pct) || 0;
    const xgTotal = (o.home_xg + o.away_xg);
    const fairOdd = o.fair_odd;
    const marketOdd = o.market_odd;
    const hGP = m.home_games_played ?? 0;
    const aGP = m.away_games_played ?? 0;
    const minGP = Math.min(hGP, aGP);
    const alphaH = m.model_alpha_h ?? m.home_attack ?? 1.0;
    const betaH = m.model_beta_h ?? m.home_defense ?? 1.0;
    const alphaA = m.model_alpha_a ?? m.away_attack ?? 1.0;
    const betaA = m.model_beta_a ?? m.away_defense ?? 1.0;
    const leagueAvg = m.league_avg_goals ?? 2.7;

    // ── Identificar os DRIVERS (fatores-chave) da análise ──
    const drivers = [];
    const warnings = [];

    // 1. Amostra pequena
    if (minGP < 10) {
        warnings.push({
            icon: '⚠️',
            title: 'Amostra pequena',
            desc: `Apenas ${hGP} jogos (casa) e ${aGP} jogos (fora) disputados. A regressão à média (peso ${Math.min(100, Math.round(minGP/15*100))}% dados obs.) suaviza, mas campeonatos em fase inicial são naturalmente imprevisíveis.`,
            severity: 'high'
        });
    }

    // 2. Analisar por tipo de mercado
    const sel = o.selection.toLowerCase();
    const mkt = o.market.toLowerCase();

    if (mkt.includes('o/u') || mkt.includes('gols')) {
        // Mercado de gols
        if (sel.includes('under')) {
            drivers.push({
                icon: '🛡️',
                title: 'Defesas sólidas',
                desc: `β Casa = ${betaH.toFixed(2)} e β Fora = ${betaA.toFixed(2)} (média da liga = 1.00). Ambas as defesas estão ${Math.min(betaH, betaA) < 0.85 ? 'MUITO acima' : 'acima'} da média, dificultando gols.`
            });
            if (xgTotal < 2.0) {
                drivers.push({
                    icon: '📉',
                    title: 'xG Total muito baixo',
                    desc: `O modelo espera apenas ${xgTotal.toFixed(2)} gols na partida (média da liga: ${leagueAvg.toFixed(2)}). Com poucos gols esperados, a probabilidade de Under é naturalmente alta.`
                });
            }
        } else if (sel.includes('over')) {
            if (xgTotal > leagueAvg) {
                drivers.push({
                    icon: '⚡',
                    title: 'Ataques acima da média',
                    desc: `α Casa = ${alphaH.toFixed(2)} e α Fora = ${alphaA.toFixed(2)}. O xG Total de ${xgTotal.toFixed(2)} gols supera a média da liga (${leagueAvg.toFixed(2)}).`
                });
            }
            if (Math.max(betaH, betaA) > 1.15) {
                drivers.push({
                    icon: '🔓',
                    title: 'Defesa(s) vulnerável(is)',
                    desc: `${betaH > 1.15 ? o.home_team + ' (β=' + betaH.toFixed(2) + ') ' : ''}${betaA > 1.15 ? o.away_team + ' (β=' + betaA.toFixed(2) + ')' : ''} — acima de 1.00 significa que sofre(m) mais gols que a média.`
                });
            }
        }
    } else if (mkt.includes('1x2') || mkt.includes('dupla chance')) {
        // Mercado 1x2
        if (sel.includes('casa')) {
            drivers.push({
                icon: '🏟️',
                title: 'Vantagem de mando + ataque forte',
                desc: `α Casa = ${alphaH.toFixed(2)} com fator de mando 1.08. Contra defesa de β = ${betaA.toFixed(2)}, o modelo projeta ${o.home_xg.toFixed(2)} gols do mandante.`
            });
        } else if (sel.includes('fora')) {
            drivers.push({
                icon: '✈️',
                title: 'Visitante com ataque superior',
                desc: `α Fora = ${alphaA.toFixed(2)} contra defesa de β = ${betaH.toFixed(2)}. Mesmo sem vantagem de mando, o modelo projeta ${o.away_xg.toFixed(2)} gols do visitante.`
            });
        }
    } else if (mkt.includes('btts') || mkt.includes('ambas')) {
        if (sel.includes('sim') || sel.includes('yes')) {
            drivers.push({
                icon: '⚽',
                title: 'Ambos times com ataque ativo',
                desc: `α Casa = ${alphaH.toFixed(2)}, α Fora = ${alphaA.toFixed(2)}. Com xG Casa = ${o.home_xg.toFixed(2)} e xG Fora = ${o.away_xg.toFixed(2)}, ambos têm chances reais de marcar.`
            });
        } else {
            drivers.push({
                icon: '🛡️',
                title: 'Pelo menos uma defesa forte',
                desc: `${Math.min(betaH, betaA) < 0.85 ? 'Defesa muito sólida presente' : 'Uma defesa dificulta o ataque adversário'}. xG mais baixo = ${Math.min(o.home_xg, o.away_xg).toFixed(2)}.`
            });
        }
    }

    // Drivers genéricos
    // Forma recente
    const hForm = m.home_form || [];
    const aForm = m.away_form || [];
    const hFormW = hForm.filter(x => x === 'W').length;
    const hFormL = hForm.filter(x => x === 'L').length;
    const aFormW = aForm.filter(x => x === 'W').length;
    const aFormL = aForm.filter(x => x === 'L').length;
    if (hForm.length >= 3 || aForm.length >= 3) {
        let formNote = '';
        if (hFormL === 0 && hForm.length >= 3) formNote += `${o.home_team} invicto nos últimos ${hForm.length} jogos. `;
        if (aFormL === 0 && aForm.length >= 3) formNote += `${o.away_team} invicto nos últimos ${aForm.length} jogos. `;
        if (hFormW === 0 && hForm.length >= 3) formNote += `${o.home_team} sem vitórias nos últimos ${hForm.length} jogos. `;
        if (aFormW === 0 && aForm.length >= 3) formNote += `${o.away_team} sem vitórias nos últimos ${aForm.length} jogos. `;
        if (formNote) {
            drivers.push({ icon: '📊', title: 'Forma recente', desc: formNote.trim() });
        }
    }

    // Discrepância modelo vs mercado
    const gapPct = ((modelP - impliedP) * 100).toFixed(1);
    drivers.push({
        icon: '💰',
        title: 'Discrepância modelo vs mercado',
        desc: `O modelo atribui ${o.model_prob}% ao evento, mas o mercado precifica apenas ${o.implied_prob}% (diferença de ${gapPct} p.p.). Isso gera a odd justa de ${fairOdd.toFixed(2)} vs a odd real de ${marketOdd.toFixed(2)}.`
    });

    // Urgência
    if (o.urgency_home >= 0.9 || o.urgency_away >= 0.9) {
        const urgTeams = [];
        if (o.urgency_home >= 0.9) urgTeams.push(o.home_team);
        if (o.urgency_away >= 0.9) urgTeams.push(o.away_team);
        drivers.push({
            icon: '🔥',
            title: 'Alta urgência competitiva',
            desc: `${urgTeams.join(' e ')} em disputa por título ou contra rebaixamento — fator motivacional elevado.`
        });
    }

    // Odds suspect
    if (o.odds_suspect || m.odds_home_away_suspect) {
        warnings.push({
            icon: '🔄',
            title: 'Possível inversão Casa/Fora',
            desc: 'As odds sugerem que o mandante designado pela API pode estar incorreto. O modelo usou estatísticas neutras para compensar.',
            severity: 'medium'
        });
    }

    // ── Classificar edge ──
    let edgeClass = 'normal';
    let edgeLabel = 'Edge moderado';
    let edgeColor = 'var(--accent-green)';
    if (edge >= 30) { edgeClass = 'extreme'; edgeLabel = 'Edge EXTREMO'; edgeColor = '#ff4444'; }
    else if (edge >= 15) { edgeClass = 'high'; edgeLabel = 'Edge muito alto'; edgeColor = 'var(--accent-yellow)'; }
    else if (edge >= 8) { edgeClass = 'good'; edgeLabel = 'Edge bom'; edgeColor = 'var(--accent-green)'; }

    // ── Construir HTML ──
    let html = `<div style="background:linear-gradient(135deg, rgba(59,130,246,0.06), rgba(139,92,246,0.04));border:1px solid rgba(59,130,246,0.2);border-radius:12px;padding:20px;margin-bottom:4px">`;

    // Header
    html += `<div style="display:flex;align-items:center;gap:10px;margin-bottom:16px">
        <div style="font-size:20px">🧠</div>
        <div>
            <div style="font-size:15px;font-weight:800;color:var(--text-primary)">RESUMO: Por que o modelo vê valor?</div>
            <div style="font-size:11px;color:var(--text-muted);margin-top:2px">${o.market} → ${o.selection} | Edge: <span style="color:${edgeColor};font-weight:700">${o.edge_pct}</span></div>
        </div>
    </div>`;

    // A explicação em linguagem natural
    html += `<div style="background:rgba(0,0,0,0.15);border-radius:8px;padding:14px 16px;margin-bottom:14px;border-left:3px solid ${edgeColor}">
        <div style="font-size:12px;font-weight:700;color:${edgeColor};margin-bottom:6px">${edgeLabel}</div>
        <div style="font-size:12px;color:var(--text-secondary);line-height:1.7">`;

    // Gerar o parágrafo explicativo
    html += `O modelo calcula que <strong style="color:var(--text-primary)">${o.selection}</strong> tem
        <strong style="color:var(--accent-green)">${o.model_prob}%</strong> de probabilidade, usando o modelo Dixon-Coles
        com base nos parâmetros de ataque/defesa dos times (média da liga: ${leagueAvg.toFixed(2)} gols/jogo).`;

    if (minGP < 10) {
        html += ` <span style="color:var(--accent-yellow)">Como os times jogaram apenas ${minGP}–${Math.max(hGP,aGP)} partidas,
        o modelo aplica <strong>regressão à média</strong> (${Math.round(minGP/15*100)}% peso observado, ${100-Math.round(minGP/15*100)}% média da liga)
        para não superestimar padrões de amostra pequena.</span>`;
    }

    html += `<br><br>A odd justa calculada é <strong style="color:var(--text-primary)">${fairOdd.toFixed(2)}</strong>,
        mas o mercado oferece <strong style="color:var(--accent-green)">${marketOdd.toFixed(2)}</strong>.
        Essa diferença gera o edge de <strong style="color:${edgeColor}">${o.edge_pct}</strong>.`;

    if (edge >= 30) {
        html += `<br><br><span style="color:#ff4444;font-weight:700">⚠️ ATENÇÃO: Edge acima de 30% é incomum e pode indicar que o modelo está superestimando a probabilidade
        (ex: amostra pequena, dados insuficientes, ou particularidades que o modelo não captura). Recomenda-se cautela.</span>`;
    }

    html += `</div></div>`;

    // ── Fatores-chave (drivers) ──
    html += `<div style="font-size:11px;font-weight:800;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">📌 Fatores-chave</div>`;
    html += `<div style="display:grid;grid-template-columns:repeat(auto-fill, minmax(280px, 1fr));gap:8px;margin-bottom:${warnings.length ? '14px' : '0'}">`;
    drivers.forEach(d => {
        html += `<div style="background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:10px 12px">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px">
                <span style="font-size:14px">${d.icon}</span>
                <span style="font-size:11px;font-weight:700;color:var(--text-primary)">${d.title}</span>
            </div>
            <div style="font-size:11px;color:var(--text-secondary);line-height:1.5">${d.desc}</div>
        </div>`;
    });
    html += '</div>';

    // ── Avisos ──
    if (warnings.length) {
        html += `<div style="font-size:11px;font-weight:800;color:var(--accent-yellow);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">⚠️ Pontos de atenção</div>`;
        warnings.forEach(w => {
            const borderC = w.severity === 'high' ? '#ff4444' : 'var(--accent-yellow)';
            html += `<div style="background:rgba(255,200,0,0.04);border:1px solid rgba(255,200,0,0.15);border-left:3px solid ${borderC};border-radius:8px;padding:10px 12px;margin-bottom:6px">
                <div style="display:flex;align-items:center;gap:6px;margin-bottom:3px">
                    <span style="font-size:13px">${w.icon}</span>
                    <span style="font-size:11px;font-weight:700;color:var(--accent-yellow)">${w.title}</span>
                </div>
                <div style="font-size:11px;color:var(--text-secondary);line-height:1.5">${w.desc}</div>
            </div>`;
        });
    }

    // ── Mini pipeline visual ──
    html += `<div style="margin-top:14px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.06)">
        <div style="font-size:10px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">🔄 Como a odd justa é calculada</div>
        <div style="display:flex;align-items:center;gap:0;flex-wrap:wrap">
            <div style="background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.25);border-radius:6px;padding:6px 10px;font-size:10px;text-align:center">
                <div style="color:var(--accent-cyan);font-weight:700">1. Dados</div>
                <div style="color:var(--text-muted);margin-top:2px">Gols, forma,<br>standings</div>
            </div>
            <div style="color:var(--text-muted);padding:0 4px;font-size:12px">→</div>
            <div style="background:rgba(139,92,246,0.1);border:1px solid rgba(139,92,246,0.25);border-radius:6px;padding:6px 10px;font-size:10px;text-align:center">
                <div style="color:#a78bfa;font-weight:700">2. α / β</div>
                <div style="color:var(--text-muted);margin-top:2px">Ataque/defesa<br>+ regressão</div>
            </div>
            <div style="color:var(--text-muted);padding:0 4px;font-size:12px">→</div>
            <div style="background:rgba(16,185,129,0.1);border:1px solid rgba(16,185,129,0.25);border-radius:6px;padding:6px 10px;font-size:10px;text-align:center">
                <div style="color:var(--accent-green);font-weight:700">3. xG</div>
                <div style="color:var(--text-muted);margin-top:2px">λ=${o.home_xg.toFixed(2)}<br>μ=${o.away_xg.toFixed(2)}</div>
            </div>
            <div style="color:var(--text-muted);padding:0 4px;font-size:12px">→</div>
            <div style="background:rgba(245,158,11,0.1);border:1px solid rgba(245,158,11,0.25);border-radius:6px;padding:6px 10px;font-size:10px;text-align:center">
                <div style="color:var(--accent-yellow);font-weight:700">4. Monte Carlo</div>
                <div style="color:var(--text-muted);margin-top:2px">5.000 sim.<br>→ P=${o.model_prob}%</div>
            </div>
            <div style="color:var(--text-muted);padding:0 4px;font-size:12px">→</div>
            <div style="background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.25);border-radius:6px;padding:6px 10px;font-size:10px;text-align:center">
                <div style="color:#f87171;font-weight:700">5. Odd Justa</div>
                <div style="color:var(--text-muted);margin-top:2px">1/P = ${fairOdd.toFixed(2)}<br>vs mkt ${marketOdd.toFixed(2)}</div>
            </div>
        </div>
    </div>`;

    html += '</div>';
    return html;
}

function buildDetailedAnalysis(o) {
    // Buscar partida associada para dados completos
    const m = allMatches.find(x => x.match_id === o.match_id);
    const L = [];

    // ── 0. QUALIDADE DOS DADOS ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("🔍  QUALIDADE DOS DADOS (Data Quality Gate)");
    L.push("═══════════════════════════════════════════════════════");
    const dq = o.data_quality || (m ? m.data_quality : 0);
    const dqPct = (dq * 100).toFixed(0);
    const dqBar = "█".repeat(Math.round(dq * 20)) + "░".repeat(20 - Math.round(dq * 20));
    const dqLabel = dq >= 0.80 ? "EXCELENTE" : dq >= 0.60 ? "BOA" : dq >= 0.40 ? "MODERADA" : "BAIXA";
    L.push(`  Score:     [${dqBar}] ${dqPct}% — ${dqLabel}`);
    L.push("");
    if (m) {
        L.push(`  ✅ Odds REAIS:      ${m.has_real_odds ? 'SIM (' + o.bookmaker + ')' : '❌ NÃO — Estimadas pelo modelo (NÃO CONFIÁVEL)'}`);
        L.push(`  ✅ Standings REAIS:  ${m.has_real_standings ? 'SIM' : '❌ NÃO — Usando defaults (NÃO CONFIÁVEL)'}`);
        L.push(`    ├─ ${o.home_team}: ${m.home_has_real_data ? '✅ Dados reais da API' : '⚠️ ESTIMADO (defaults)'}`);
        L.push(`    └─ ${o.away_team}: ${m.away_has_real_data ? '✅ Dados reais da API' : '⚠️ ESTIMADO (defaults)'}`);
        L.push(`  ✅ Clima REAL:       ${m.has_real_weather ? 'SIM' : '❌ NÃO — Sem dados meteorológicos'}`);
        L.push(`  ✅ Árbitro:          ${m.referee && m.referee !== 'Desconhecido' ? 'SIM (' + m.referee + ')' : '❌ NÃO IDENTIFICADO'}`);
        if (m.odds_home_away_suspect || o.odds_suspect) {
            L.push("");
            L.push(`  ⚠️ INVERSÃO CASA/FORA DETECTADA:`);
            L.push(`     As odds indicam que "${o.home_team}" (designado como mandante`);
            L.push(`     pela API) é na verdade o visitante/underdog.`);
            L.push(`     Odds: ${o.home_team}=${m.odds_home.toFixed(2)} vs ${o.away_team}=${m.odds_away.toFixed(2)}`);
            L.push(`     → Modelo ajustado: stats neutras + sem vantagem de mando.`);
        }
    } else {
        L.push(`  ⚠️ Dados detalhados da partida não disponíveis no cache`);
    }
    L.push("");
    L.push("  ⚠️ NOTA: Campos de Escanteios, Cartões, Faltas e Posse de Bola");
    L.push("  são ESTIMADOS a partir da força de ataque/defesa, pois a API de");
    L.push("  standings não fornece esses dados granulares diretamente.");
    L.push("");

    // ── 1. MODELO ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("📐  MODELO ESTATÍSTICO UTILIZADO");
    L.push("═══════════════════════════════════════════════════════");
    L.push("  Modelo:         Dixon-Coles (Poisson Bivariada Ajustada, 1997)");
    L.push("  Simulação:      Monte Carlo — 5.000 iterações por jogo");
    L.push("  Matriz placar:  9×9 (0 a 8 gols por equipe)");
    L.push("  De-Vigging:     Power Method (Método da Potência)");
    L.push("  Kelly:          Fracionário (Kelly/4) — máx. 5% da banca");
    L.push("");

    // ── 2. FORÇA DOS TIMES ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("⚔️  FORÇA DOS TIMES (Ataque α / Defesa β)");
    L.push("═══════════════════════════════════════════════════════");
    if (m) {
        // Verificar se os dados são reais ou estimados
        const homeHasReal = m.home_has_real_data !== false;
        const awayHasReal = m.away_has_real_data !== false;
        
        // Usar α/β REAIS do modelo (não attack_strength/defense_strength genéricos)
        const alphaH = (m.model_alpha_h ?? m.home_attack ?? 1.0).toFixed(2);
        const betaH = (m.model_beta_h ?? m.home_defense ?? 1.0).toFixed(2);
        const alphaA = (m.model_alpha_a ?? m.away_attack ?? 1.0).toFixed(2);
        const betaA = (m.model_beta_a ?? m.away_defense ?? 1.0).toFixed(2);
        L.push(`  Média de gols da liga: ${(m.league_avg_goals ?? 2.7).toFixed(2)} gols/jogo`);
        const hGP = m.home_games_played ?? 0;
        const aGP = m.away_games_played ?? 0;
        if (hGP < 15 || aGP < 15) {
            L.push(`  ⚠️ Amostra pequena (Casa:${hGP} jogos, Fora:${aGP} jogos) — regressão à média aplicada`);
        }
        L.push("");
        L.push(`  ${o.home_team} (CASA):`);
        if (homeHasReal) {
            L.push(`    ├─ Ataque (α):     ${alphaH}`);
            L.push(`    ├─ Defesa (β):     ${betaH}`);
            L.push(`    ├─ Gols/jogo (casa):  marcados ${m.home_goals_scored_avg ?? 'N/D'} | sofridos ${m.home_goals_conceded_avg ?? 'N/D'}`);
            L.push(`    ├─ Posição:        ${m.home_league_pos ?? 'N/D'}° (${m.home_league_pts ?? 'N/D'} pts)`);
            L.push(`    └─ Forma (pontos): ${m.home_form_points ?? 'N/D'}`);
        } else {
            L.push(`    ⚠️  DADOS ESTIMADOS (não reais da API) - análise não confiável`);
            L.push(`    ├─ Ataque (α):     ${alphaH} (estimado)`);
            L.push(`    ├─ Defesa (β):     ${betaH} (estimado)`);
        }
        L.push("");
        L.push(`  ${o.away_team} (FORA):`);
        if (awayHasReal) {
            L.push(`    ├─ Ataque (α):     ${alphaA}`);
            L.push(`    ├─ Defesa (β):     ${betaA}`);
            L.push(`    ├─ Gols/jogo (fora):  marcados ${m.away_goals_scored_avg ?? 'N/D'} | sofridos ${m.away_goals_conceded_avg ?? 'N/D'}`);
            L.push(`    ├─ Posição:        ${m.away_league_pos ?? 'N/D'}° (${m.away_league_pts ?? 'N/D'} pts)`);
            L.push(`    └─ Forma (pontos): ${m.away_form_points ?? 'N/D'}`);
        } else {
            L.push(`    ⚠️  DADOS ESTIMADOS (não reais da API) - análise não confiável`);
            L.push(`    ├─ Ataque (α):     ${alphaA} (estimado)`);
            L.push(`    ├─ Defesa (β):     ${betaA} (estimado)`);
        }
    } else {
        L.push(`  ⚠️ Dados da partida não encontrados no cache`);
        L.push(`  ⚠️ Esta análise não pode ser exibida - dados insuficientes`);
    }
    L.push("");

    // ── 3. FORMA RECENTE ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("  FORMA RECENTE");
    L.push("═══════════════════════════════════════════════════════");
    if (m) {
        const hf = m.home_form || [];
        const af = m.away_form || [];
        if (hf.length) {
            const hW = hf.filter(x=>x==='W').length, hD = hf.filter(x=>x==='D').length, hL = hf.filter(x=>x==='L').length;
            L.push(`  ${o.home_team} (ult. ${hf.length} jogos): ${hf.join(' ')} -> ${hW}V ${hD}E ${hL}D`);
        } else {
            L.push(`  ${o.home_team}: Dados de forma indisponiveis`);
        }
        if (af.length) {
            const aW = af.filter(x=>x==='W').length, aD = af.filter(x=>x==='D').length, aL = af.filter(x=>x==='L').length;
            L.push(`  ${o.away_team} (ult. ${af.length} jogos): ${af.join(' ')} -> ${aW}V ${aD}E ${aL}D`);
        } else {
            L.push(`  ${o.away_team}: Dados de forma indisponiveis`);
        }
    }
    L.push("");

    // ── 4. CÁLCULO DE xG ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("⚽  CÁLCULO DE xG (Gols Esperados)");
    L.push("═══════════════════════════════════════════════════════");
    const isSuspect = o.odds_suspect || (m && m.odds_home_away_suspect);
    if (isSuspect) {
        L.push("  ⚠️  ATENÇÃO: Possível inversão Casa/Fora detectada.");
        L.push("  As odds sugerem que o mandante designado pode estar incorreto.");
        L.push("  → Modelo usou estatísticas NEUTRAS (média casa+fora de cada time).");
        L.push("  → Vantagem de mando REMOVIDA (fator = 1.0 em vez de 1.08).");
        L.push("");
        L.push("  Fórmula AJUSTADA (campo neutro):");
        L.push("    λ = α_avg × β_avg × 1.00 × fator_forma");
        L.push("    μ = α_avg × β_avg × fator_forma");
    } else {
        L.push("  Fórmula (Dixon-Coles):");
        L.push("    λ (Casa) = α_casa × β_fora × vantagem_mando(1.08) × fator_forma");
        L.push("    μ (Fora) = α_fora × β_casa × fator_forma");
    }
    L.push("");
    if (m) {
        const hFormFactor = (0.85 + (m.home_form_points ?? 0.5) * 0.30).toFixed(2);
        const aFormFactor = (0.85 + (m.away_form_points ?? 0.5) * 0.30).toFixed(2);
        const homeHasReal = m.home_has_real_data !== false;
        const awayHasReal = m.away_has_real_data !== false;
        const hmAdv = isSuspect ? '1.00' : '1.08';
        
        if (homeHasReal && awayHasReal) {
            // Usar α/β REAIS do modelo (consistentes com o xG calculado)
            const fAlphaH = (m.model_alpha_h ?? m.home_attack ?? 1.0).toFixed(2);
            const fBetaA = (m.model_beta_a ?? m.away_defense ?? 1.0).toFixed(2);
            const fAlphaA = (m.model_alpha_a ?? m.away_attack ?? 1.0).toFixed(2);
            const fBetaH = (m.model_beta_h ?? m.home_defense ?? 1.0).toFixed(2);
            const rawLambda = parseFloat(fAlphaH) * parseFloat(fBetaA) * parseFloat(hmAdv) * parseFloat(hFormFactor);
            const rawMu = parseFloat(fAlphaA) * parseFloat(fBetaH) * parseFloat(aFormFactor);
            L.push(`  Cálculo λ (${o.home_team}):`);
            L.push(`    = ${fAlphaH} × ${fBetaA} × ${hmAdv} × ${hFormFactor}`);
            L.push(`    = ${rawLambda.toFixed(2)}${rawLambda > 3.5 ? ' → clamped 3.5' : ''}`);
            L.push(`    → xG Casa = ${o.home_xg.toFixed(2)}`);
            L.push("");
            L.push(`  Cálculo μ (${o.away_team}):`);
            L.push(`    = ${fAlphaA} × ${fBetaH} × ${aFormFactor}`);
            L.push(`    = ${rawMu.toFixed(2)}${rawMu > 3.0 ? ' → clamped 3.0' : ''}`);
            L.push(`    → xG Fora = ${o.away_xg.toFixed(2)}`);
        } else {
            L.push(`  ⚠️  Cálculo de xG baseado em dados ESTIMADOS (não reais)`);
            L.push(`  ⚠️  Resultados podem não ser confiáveis`);
            L.push(`  → xG Casa = ${o.home_xg.toFixed(2)} (estimado)`);
            L.push(`  → xG Fora = ${o.away_xg.toFixed(2)} (estimado)`);
        }
    } else {
        L.push(`  ⚠️  Dados insuficientes para exibir cálculo detalhado`);
        L.push(`  → xG Casa = ${o.home_xg.toFixed(2)}`);
        L.push(`  → xG Fora = ${o.away_xg.toFixed(2)}`);
    }
    L.push(`  → xG Total = ${(o.home_xg + o.away_xg).toFixed(2)}`);
    L.push("");

    // ── 5. PROBABILIDADES DO MODELO ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("🎯  PROBABILIDADES (Matriz Dixon-Coles + Monte Carlo)");
    L.push("═══════════════════════════════════════════════════════");
    if (m) {
        L.push(`  Vitória Casa:   ${m.prob_home}%`);
        L.push(`  Empate:         ${m.prob_draw}%`);
        L.push(`  Vitória Fora:   ${m.prob_away}%`);
        L.push(`  Over 2.5 Gols:  ${m.prob_over25}%`);
        L.push(`  BTTS (Ambas):   ${m.prob_btts}%`);
        L.push(`  Escanteios:     ${m.corners_expected} esperados`);
        L.push(`  Cartões:        ${m.cards_expected} esperados`);
        if (m.model_total_shots) {
            L.push(`  Finalizações:   ${m.model_total_shots} esperadas (${m.home_team}: ${m.model_home_shots ?? '?'} | ${m.away_team}: ${m.model_away_shots ?? '?'})`);
            L.push(`  Fin. ao Gol:    ${m.model_total_sot} esperadas (${m.home_team}: ${m.model_home_sot ?? '?'} | ${m.away_team}: ${m.model_away_sot ?? '?'})`);
        }
    }
    L.push("");

    // ── 6. ODDS DE MERCADO ──
    L.push("═══════════════════════════════════════════════════════");
    L.push(`💰  ODDS DE MERCADO (${o.bookmaker})`);
    L.push("═══════════════════════════════════════════════════════");
    if (m) {
        L.push(`  1x2:    Casa=${m.odds_home}  |  Empate=${m.odds_draw}  |  Fora=${m.odds_away}`);
        L.push(`  O/U 2.5: Over=${m.odds_over25 ?? '?'}  |  Under=${m.odds_under25 ?? '?'}`);
        L.push(`  BTTS:   Sim=${m.odds_btts_yes ?? '?'}  |  Não=${m.odds_btts_no ?? '?'}`);
    }
    L.push("");

    // ── 7. CÁLCULO DO VALOR (EDGE) ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("📈  CÁLCULO DO EDGE (Valor Esperado)");
    L.push("═══════════════════════════════════════════════════════");
    L.push("  Método de de-vigging: Power Method (Método da Potência)");
    L.push("  O Power Method remove a margem (vig) da casa de apostas");
    L.push("  distribuindo-a proporcionalmente (favoritos recebem menos vig).");
    L.push("");
    L.push("  Fórmula do Edge:");
    L.push("    Edge = (Prob_Modelo × Odd_Mercado) − 1");
    L.push("");
    L.push(`  Neste mercado (${o.market} → ${o.selection}):`);
    L.push(`    Prob. do Modelo:    ${o.model_prob}%`);
    L.push(`    Prob. Implícita:    ${o.implied_prob}% (após de-vig)`);
    L.push(`    Odd de Mercado:     ${o.market_odd.toFixed(2)}`);
    L.push(`    Odd Justa (Modelo): ${o.fair_odd.toFixed(2)}`);
    L.push("");
    L.push(`    Edge = (${(o.model_prob/100).toFixed(3)} × ${o.market_odd.toFixed(2)}) − 1`);
    L.push(`         = ${((o.model_prob/100) * o.market_odd).toFixed(3)} − 1`);
    L.push(`         = ${o.edge_pct}`);
    L.push("");
    L.push("  Kelly Criterion (gestão de risco):");
    L.push("    f* = (p × b − 1) / (b − 1)   |   aplicado: Kelly/4");
    L.push(`    Aposta sugerida: ${o.kelly_bet_pct} da banca`);
    L.push("");

    // ── 8. AJUSTES CONTEXTUAIS ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("🌐  AJUSTES CONTEXTUAIS APLICADOS");
    L.push("═══════════════════════════════════════════════════════");

    // Clima
    if (m && m.weather_desc && m.weather_desc !== "N/D") {
        L.push(`  ☁️ Clima: ${m.weather_desc ?? 'N/D'} | ${m.weather_temp != null ? m.weather_temp.toFixed(0) : '?'}°C | Vento: ${m.weather_wind != null ? m.weather_wind.toFixed(0) : '?'} km/h${m.weather_rain > 0 ? ' | Chuva: ' + m.weather_rain + 'mm' : ''}`);
        if (m.weather_wind > 20)
            L.push("    → Penalidade: xG reduzido ~8% (degradação de passes longos/bolas paradas)");
        if (m.weather_rain > 5)
            L.push("    → Ajuste: +5% variância de erros (superfície molhada)");
        if (m.weather_temp > 30)
            L.push("    → Ajuste: pressing reduzido no 2° tempo (calor extremo)");
    } else {
        L.push("  ☁️ Clima: Dados não disponíveis");
    }
    L.push("");

    // Fadiga
    if (m) {
        if (m.home_fatigue)
            L.push(`  ⚡ ${o.home_team}: jogou nas últimas 72h → penalidade de 15% nos ratings`);
        if (m.away_fatigue)
            L.push(`  ⚡ ${o.away_team}: jogou nas últimas 72h → penalidade de 15% nos ratings`);
        if (!m.home_fatigue && !m.away_fatigue)
            L.push("  ⚡ Fadiga: Nenhum time com sobrecarga (<72h) — sem penalidade");
    }
    L.push("");

    // Lesões
    if (m) {
        if (m.injuries_home && m.injuries_home.length > 0)
            L.push(`  🏥 Lesões ${o.home_team} (${m.injuries_home.length}): ${m.injuries_home.slice(0,4).join(', ')}`);
        if (m.injuries_away && m.injuries_away.length > 0)
            L.push(`  🏥 Lesões ${o.away_team} (${m.injuries_away.length}): ${m.injuries_away.slice(0,4).join(', ')}`);
        if ((!m.injuries_home || m.injuries_home.length === 0) && (!m.injuries_away || m.injuries_away.length === 0))
            L.push("  🏥 Lesões: Nenhuma lesão reportada");
    }
    L.push("");

    // Urgência
    L.push(`  🔥 Urgência (LUS — League Urgency Score):`);
    L.push(`     ${o.home_team}: ${o.urgency_home.toFixed(1)} ${o.urgency_home >= 0.9 ? '← MÁXIMA (título/rebaixamento)' : o.urgency_home <= 0.4 ? '← BAIXA (meio de tabela)' : ''}`);
    L.push(`     ${o.away_team}: ${o.urgency_away.toFixed(1)} ${o.urgency_away >= 0.9 ? '← MÁXIMA (título/rebaixamento)' : o.urgency_away <= 0.4 ? '← BAIXA (meio de tabela)' : ''}`);
    L.push("");

    // Árbitro
    if (m && m.referee && m.referee !== "Desconhecido") {
        L.push(`  👨‍⚖️ Árbitro: ${m.referee}`);
        L.push(`     Média: ${m.referee_cards_avg ?? '?'} cartões/jogo | ${m.referee_fouls_avg ?? '?'} faltas/jogo`);
    }
    L.push("");

    // ── 9. CONCLUSÃO ──
    L.push("═══════════════════════════════════════════════════════");
    L.push("✅  CONCLUSÃO");
    L.push("═══════════════════════════════════════════════════════");
    L.push(`  O modelo Dixon-Coles atribui ${o.model_prob}% de probabilidade`);
    L.push(`  ao evento "${o.selection}" (mercado ${o.market}),`);
    L.push(`  enquanto o mercado (${o.bookmaker}) implica apenas ${o.implied_prob}%.`);
    L.push("");
    L.push(`  A odd de mercado (${o.market_odd.toFixed(2)}) está acima da odd justa`);
    L.push(`  calculada pelo modelo (${o.fair_odd.toFixed(2)}), gerando um`);
    L.push(`  edge de ${o.edge_pct} — oportunidade de valor positivo (+EV).`);
    L.push("");
    L.push(`  Confiança: ${o.confidence} (Score: ${(o.confidence_score||0).toFixed(1)}/100)`);
    L.push(`  Tipo de Análise: ${(o.analysis_type||'PRE_JOGO') === 'PRE_JOGO' ? 'Pré-Jogo (antes do início)' : 'Retroativa (jogo já iniciado/encerrado)'}`);
    L.push("");
    L.push("  Score de Confiança considera:");
    L.push("  - Edge (sweet spot: 5-10%)");
    L.push("  - Faixa de Odds (odds baixas = mais previsível)");
    L.push("  - Probabilidade do modelo");
    L.push("  - Qualidade dos dados (odds reais, standings reais)");
    L.push("  - Condições contextuais (clima, fadiga)");
    L.push("  - Concordância modelo vs mercado");

    return L.join("\n");
}

function showMatchDetail(matchId) {
    const m = allMatches.find(x => x.match_id === matchId);
    if (!m) return;

    document.getElementById("modal-title").textContent = `${m.home_team} vs ${m.away_team}`;
    document.getElementById("modal-subtitle").textContent = `${m.league_name} — ${m.league_country} | ${m.match_date} ${m.match_time}`;

    const formHtml = (form) => {
        if (!form || !form.length) return '<span style="color:var(--text-muted)">Sem dados</span>';
        return form.map(f => `<div class="form-dot form-${f}">${f}</div>`).join("");
    };
    const matchOpps = allOpps.filter(o => o.match_id === matchId);
    const oppsHtml = matchOpps.length > 0 ? matchOpps.map(o => {
        const confClass = o.confidence === "ALTO" ? "badge-high" : o.confidence === "MÉDIO" ? "badge-med" : "badge-low";
        const oppIdx = allOpps.indexOf(o);
        const resultBadge = o.result_status && o.result_status !== 'PENDENTE'
            ? `<span class="result-${o.result_status.toLowerCase()}" style="font-size:9px;padding:2px 6px">${o.result_status === 'GREEN' ? '✅' : o.result_status === 'RED' ? '❌' : '⬜'} ${o.result_status}</span>`
            : '<span class="result-pending" style="font-size:9px;padding:2px 6px">⏳</span>';
        return `<div onclick="showOppDetail(${oppIdx})" style="display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border);flex-wrap:wrap;gap:8px;cursor:pointer;border-radius:8px;transition:background 0.15s" onmouseover="this.style.background='var(--bg-card-hover)'" onmouseout="this.style.background='transparent'">
            <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                ${resultBadge}
                <span class="badge ${confClass}">${o.confidence} <span style="font-size:9px;opacity:0.7">(${(o.confidence_score||0).toFixed(0)})</span></span>
                <span class="market-tag ${getMarketClass(o.market)}">${o.market}</span>
                <span style="font-weight:700">${o.selection}</span>
                <span style="font-family:'JetBrains Mono';font-size:12px;color:var(--text-secondary)">@${o.market_odd.toFixed(2)}</span>
            </div>
            <div style="display:flex;align-items:center;gap:10px">
                <span style="font-size:11px;color:var(--text-muted)">Prob: ${o.model_prob.toFixed(0)}%</span>
                <span style="font-weight:800;color:var(--accent-green);font-family:'JetBrains Mono';font-size:14px">${o.edge_pct}</span>
                ${bookmakerBadgeHtml(o.bookmaker, o.home_team, o.away_team, o.market, o.selection, true, o.league_country, o.league_name)}
                <span style="font-size:11px;color:var(--accent-blue)">Ver detalhes →</span>
            </div>
        </div>`;
    }).join("") : '<div style="color:var(--text-muted);padding:8px 0">Nenhuma oportunidade +EV identificada para este jogo</div>';

    // Calculate game status
    const gs = getGameStatus(m.match_date, m.match_time);
    const statusBadge = gs.status === 'LIVE'
        ? '<span class="game-live">🔴 AO VIVO</span>'
        : gs.status === 'FINISHED'
        ? '<span class="game-finished">✔ ENCERRADO</span>'
        : `<span class="game-upcoming">📅 ${gs.timeLabel}</span>`;

    document.getElementById("modal-body").innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:16px">
            ${statusBadge}
            <span style="font-size:11px;color:var(--text-muted)">${matchOpps.length} oportunidade(s) +EV</span>
        </div>

        <div class="detail-grid">
            <div class="detail-item">
                <div class="detail-label">xG Casa</div>
                <div class="detail-value" style="color:var(--accent-green);font-family:'JetBrains Mono';font-size:28px">${m.home_xg}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">xG Fora</div>
                <div class="detail-value" style="color:var(--accent-blue);font-family:'JetBrains Mono';font-size:28px">${m.away_xg}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Probabilidades 1x2</div>
                <div class="detail-value">${m.prob_home}% / ${m.prob_draw}% / ${m.prob_away}%</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Over 2.5 / BTTS</div>
                <div class="detail-value">${m.prob_over25}% / ${m.prob_btts}%</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Odds (H/D/A)</div>
                <div class="detail-value" style="font-family:'JetBrains Mono'">${m.odds_home} / ${m.odds_draw} / ${m.odds_away}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Escanteios / Cartões</div>
                <div class="detail-value">${m.corners_expected} / ${m.cards_expected}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Clima</div>
                <div class="detail-value">${m.has_real_weather ? (m.weather_desc + ' | ' + m.weather_temp + '°C | 💨' + m.weather_wind.toFixed(0) + 'km/h' + (m.weather_rain > 0 ? ' | 🌧️' + m.weather_rain + 'mm' : '')) : '<span style="color:var(--text-muted)">Dados de clima não disponíveis</span>'}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Árbitro</div>
                <div class="detail-value">${m.referee} (${m.referee_cards_avg} cartões/jogo)</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Estádio</div>
                <div class="detail-value">${m.venue}</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Urgência (H/A)</div>
                <div class="detail-value">${m.urgency_home.toFixed(1)} / ${m.urgency_away.toFixed(1)}</div>
            </div>
        </div>

        <div style="margin-bottom:16px">
            <div class="detail-label" style="margin-bottom:8px">Forma Recente — ${m.home_team}</div>
            <div class="form-dots">${formHtml(m.home_form)}</div>
        </div>
        <div style="margin-bottom:16px">
            <div class="detail-label" style="margin-bottom:8px">Forma Recente — ${m.away_team}</div>
            <div class="form-dots">${formHtml(m.away_form)}</div>
        </div>

        ${m.injuries_home && m.injuries_home.length > 0 ? `<div style="margin-bottom:12px"><div class="detail-label" style="margin-bottom:6px">🏥 Lesões ${m.home_team}</div><div style="font-size:13px;color:var(--accent-red)">${m.injuries_home.join('<br>')}</div></div>` : ''}
        ${m.injuries_away && m.injuries_away.length > 0 ? `<div style="margin-bottom:12px"><div class="detail-label" style="margin-bottom:6px">🏥 Lesões ${m.away_team}</div><div style="font-size:13px;color:var(--accent-red)">${m.injuries_away.join('<br>')}</div></div>` : ''}
        ${m.home_fatigue || m.away_fatigue ? `<div style="margin-bottom:12px;padding:10px;background:var(--accent-yellow-dim);border-radius:8px;font-size:13px;color:var(--accent-yellow)">⚡ Fadiga: ${m.home_fatigue ? m.home_team + ' (Casa)' : ''} ${m.away_fatigue ? m.away_team + ' (Fora)' : ''} — jogou nas últimas 72h</div>` : ''}

        <div style="margin-top:16px;padding:12px;background:var(--bg-secondary);border:1px solid var(--border);border-radius:var(--radius-sm)">
            <div class="detail-label" style="margin-bottom:6px">🏦 Odds fornecidas por</div>
            <div>${bookmakerBadgeHtml(m.bookmaker, m.home_team, m.away_team, '1x2', '', false, m.league_country, m.league_name)}</div>
        </div>

        <div style="margin-top:20px;border-top:1px solid var(--border);padding-top:16px">
            <div class="detail-label" style="margin-bottom:12px">🎯 Oportunidades de Valor (+EV) — <span style="font-weight:400;color:var(--text-muted);font-size:11px">clique para ver detalhes completos</span></div>
            ${oppsHtml}
        </div>
    `;
    document.getElementById("modal-overlay").classList.add("show");
}

function closeModal(e) {
    if (e && e.target !== document.getElementById("modal-overlay")) return;
    document.getElementById("modal-overlay").classList.remove("show");
}
document.addEventListener("keydown", e => { if (e.key === "Escape") closeModal(); });

// ═══════════════════════════════════════════════════════
// HISTORICO DE TIMES — Carregamento sob demanda
// ═══════════════════════════════════════════════════════

// ── Troca de aba de mercado no painel de análise ──
function switchMktTab(uid, tabId) {
    document.querySelectorAll('[data-mkt-uid="' + uid + '"]').forEach(el => el.style.display = 'none');
    const p = document.getElementById(uid + '_' + tabId);
    if (p) p.style.display = 'block';
    document.querySelectorAll('[data-mkt-btn="' + uid + '"]').forEach(btn => {
        btn.style.background = 'rgba(255,255,255,0.05)';
        btn.style.color = 'var(--text-secondary)';
        btn.style.borderColor = 'rgba(255,255,255,0.08)';
    });
    const ab = document.getElementById(uid + '_btn_' + tabId);
    if (ab) { ab.style.background = 'var(--accent-green)'; ab.style.color = '#000'; ab.style.borderColor = 'var(--accent-green)'; }
}

async function loadTeamHistory(homeId, awayId, leagueId, homeName, awayName, leagueName) {
    const btn = document.getElementById('btn-load-history');
    const container = document.getElementById('history-content');
    if (!btn || !container) return;

    btn.disabled = true;
    btn.textContent = 'Carregando...';
    container.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted)">Buscando historico + confronto direto... (usa cache se disponivel)</div>';

    try {
        const [homeRes, awayRes, h2hRes] = await Promise.all([
            fetch(`/api/team-history/${homeId}?league_id=${leagueId}&last=10`).then(r => r.json()),
            fetch(`/api/team-history/${awayId}?league_id=${leagueId}&last=10`).then(r => r.json()),
            fetch(`/api/h2h/${homeId}/${awayId}`).then(r => r.json()),
        ]);

        btn.style.display = 'none';
        container.innerHTML = renderTeamHistory(homeRes, awayRes, h2hRes, leagueId, homeName, awayName, leagueName);
    } catch (err) {
        container.innerHTML = `<div style="color:var(--accent-red);padding:12px">Erro ao carregar: ${err.message}</div>`;
        btn.disabled = false;
        btn.textContent = 'Tentar Novamente';
    }
}

function renderTeamHistory(homeData, awayData, h2hData, leagueId, homeName, awayName, leagueName) {

    // ── Helpers reutilizaveis ──
    const calcSummary = (matches) => {
        if (!matches.length) return null;
        const w = matches.filter(m => m.result === 'W').length;
        const d = matches.filter(m => m.result === 'D').length;
        const l = matches.filter(m => m.result === 'L').length;
        const goalsFor = matches.reduce((s, m) => s + (m.is_home ? m.score_home : m.score_away), 0);
        const goalsAgainst = matches.reduce((s, m) => s + (m.is_home ? m.score_away : m.score_home), 0);
        const over25 = matches.filter(m => m.total_goals > 2.5).length;
        const tCorners = matches.filter(m => m.stats?.total_corners != null).reduce((s, m) => s + (m.stats.total_corners || 0), 0);
        const nCorners = matches.filter(m => m.stats?.total_corners != null).length;
        const tCards = matches.filter(m => m.stats?.total_cards != null).reduce((s, m) => s + (m.stats.total_cards || 0), 0);
        const nCards = matches.filter(m => m.stats?.total_cards != null).length;
        const favW = matches.filter(m => m.was_favorite && m.result === 'W').length;
        const favT = matches.filter(m => m.was_favorite === true).length;
        return { w, d, l, goalsFor, goalsAgainst, over25, tCorners, nCorners, tCards, nCards, favW, favT, total: matches.length };
    };

    const badge = (text, bg, fg) => `<span style="padding:3px 8px;border-radius:4px;font-size:10px;font-weight:700;background:${bg};color:${fg}">${text}</span>`;

    const summaryBadges = (s) => {
        if (!s) return '';
        const avg = ((s.goalsFor + s.goalsAgainst) / s.total).toFixed(1);
        const avgC = s.nCorners > 0 ? (s.tCorners / s.nCorners).toFixed(1) : '-';
        const avgK = s.nCards > 0 ? (s.tCards / s.nCards).toFixed(1) : '-';
        const o25 = ((s.over25 / s.total) * 100).toFixed(0);
        const fPct = s.favT > 0 ? ((s.favW / s.favT) * 100).toFixed(0) + '%' : '';
        return `<div style="display:flex;flex-wrap:wrap;gap:5px;margin:6px 0 10px">
            ${badge(s.w+'V','rgba(0,255,136,0.12)','var(--accent-green)')}
            ${badge(s.d+'E','rgba(255,200,0,0.12)','var(--accent-yellow)')}
            ${badge(s.l+'D','rgba(255,80,80,0.12)','var(--accent-red)')}
            ${badge(s.goalsFor+'GP '+s.goalsAgainst+'GC','rgba(255,255,255,0.05)','var(--text-secondary)')}
            ${badge('Media '+avg+'g/j','rgba(255,255,255,0.05)','var(--text-secondary)')}
            ${badge('O2.5: '+o25+'%','rgba(255,255,255,0.05)','var(--text-secondary)')}
            ${badge('Esc: '+avgC+'/j','rgba(255,255,255,0.05)','var(--text-secondary)')}
            ${badge('Cart: '+avgK+'/j','rgba(255,255,255,0.05)','var(--text-secondary)')}
            ${fPct ? badge('Fav: '+fPct,'rgba(255,255,255,0.05)','var(--accent-yellow)') : ''}
        </div>`;
    };

    const thStyle = 'padding:6px 8px;text-align:left;font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.5px;border-bottom:1px solid var(--border)';
    const tdStyle = 'padding:6px 8px;font-size:12px;border-bottom:1px solid rgba(255,255,255,0.04)';

    const matchRowBase = (m, showLeague) => {
        const rc = m.result === 'W' ? 'var(--accent-green)' : m.result === 'L' ? 'var(--accent-red)' : 'var(--accent-yellow)';
        const rl = m.result === 'W' ? 'V' : m.result === 'L' ? 'D' : 'E';
        const hac = m.is_home ? 'var(--accent-green)' : 'var(--accent-blue)';
        const ha = m.is_home ? 'C' : 'F';
        const fav = m.was_favorite === true ? ' <span title="Favorito" style="color:var(--accent-yellow)">★</span>' : m.was_favorite === false ? ' <span title="Underdog" style="color:var(--text-muted)">☆</span>' : '';
        const ou = m.total_goals > 2.5 ? '<span style="color:var(--accent-green)">O2.5</span>' : '<span style="color:var(--accent-red)">U2.5</span>';
        const s = m.stats || {};
        const esc = s.total_corners != null ? s.total_corners : '-';
        const cart = s.total_cards != null ? s.total_cards : '-';
        const xi = m.lineup_type === 'disponivel' ? '<span style="font-size:9px;padding:1px 4px;border-radius:3px;background:rgba(0,255,136,0.1);color:var(--accent-green)">XI</span>' : '';
        const leagueCol = showLeague ? `<td style="${tdStyle};font-size:10px;color:var(--text-muted);max-width:140px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${m.league_name || ''}">${m.league_name || '-'}</td>` : '';
        return `<tr>
            <td style="${tdStyle};color:var(--text-muted);white-space:nowrap">${m.date}</td>
            ${leagueCol}
            <td style="${tdStyle};text-align:center"><span style="color:${hac};font-weight:700;font-size:10px">${ha}</span></td>
            <td style="${tdStyle};max-width:180px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${m.opponent}">${m.opponent}${fav}</td>
            <td style="${tdStyle};text-align:center;font-weight:800;font-family:'JetBrains Mono'"><span style="color:${rc}">${m.score_home}-${m.score_away}</span></td>
            <td style="${tdStyle};text-align:center"><span style="background:${rc}20;color:${rc};padding:2px 6px;border-radius:4px;font-weight:800;font-size:10px">${rl}</span></td>
            <td style="${tdStyle};text-align:center;font-size:10px">${ou}</td>
            <td style="${tdStyle};text-align:center;color:var(--text-muted)">${esc}</td>
            <td style="${tdStyle};text-align:center;color:var(--text-muted)">${cart}</td>
            <td style="${tdStyle};text-align:center">${xi}</td>
        </tr>`;
    };
    const matchRow = (m) => matchRowBase(m, false);
    const matchRowFull = (m) => matchRowBase(m, true);

    const tableWrap = (rows) => `<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;min-width:600px">
        <thead><tr>
            <th style="${thStyle}">Data</th>
            <th style="${thStyle};text-align:center">C/F</th>
            <th style="${thStyle}">Adversario</th>
            <th style="${thStyle};text-align:center">Placar</th>
            <th style="${thStyle};text-align:center">Res</th>
            <th style="${thStyle};text-align:center">O/U</th>
            <th style="${thStyle};text-align:center">Esc</th>
            <th style="${thStyle};text-align:center">Cart</th>
            <th style="${thStyle};text-align:center">XI</th>
        </tr></thead><tbody>${rows}</tbody></table></div>`;

    const tableWrapFull = (rows) => `<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;min-width:700px">
        <thead><tr>
            <th style="${thStyle}">Data</th>
            <th style="${thStyle}">Campeonato</th>
            <th style="${thStyle};text-align:center">C/F</th>
            <th style="${thStyle}">Adversario</th>
            <th style="${thStyle};text-align:center">Placar</th>
            <th style="${thStyle};text-align:center">Res</th>
            <th style="${thStyle};text-align:center">O/U</th>
            <th style="${thStyle};text-align:center">Esc</th>
            <th style="${thStyle};text-align:center">Cart</th>
            <th style="${thStyle};text-align:center">XI</th>
        </tr></thead><tbody>${rows}</tbody></table></div>`;

    const sectionTitle = (icon, text, color) => `<div style="font-size:15px;font-weight:800;color:${color};margin:20px 0 4px;padding-bottom:6px;border-bottom:2px solid ${color}30">${icon} ${text}</div>`;
    const subTitle = (text) => `<div style="font-size:11px;font-weight:700;color:var(--text-secondary);margin:12px 0 4px;text-transform:uppercase;letter-spacing:1px">${text}</div>`;

    // ═══════════════════════════════════════════════════════════════
    //  ANÁLISE POR MERCADO — painel completo com tabs
    // ═══════════════════════════════════════════════════════════════
    const buildMarketAnalysis = (matches, uid) => {
        const ms = matches.filter(m => m.stats && Object.keys(m.stats).length > 0);
        const n = ms.length;
        if (!n) return '<div style="color:var(--text-muted);padding:12px;font-size:11px;text-align:center">Estatisticas detalhadas indisponiveis para analise de mercados</div>';

        const parsePoss = (v) => { if (v == null) return null; if (typeof v === 'string') return parseFloat(v.replace('%','')); return parseFloat(v); };
        const si = (v) => v != null ? parseInt(v) : null;

        // ── Helpers visuais ──
        const kpi = (label, value, color) => `<div style="background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px;text-align:center;min-width:80px;flex:1">
            <div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.5px;margin-bottom:2px">${label}</div>
            <div style="font-size:17px;font-weight:800;color:${color}">${value}</div>
        </div>`;

        const pctBar = (label, count, total, color) => {
            const pct = total > 0 ? ((count / total) * 100) : 0;
            return `<div style="display:flex;align-items:center;gap:8px;margin:3px 0">
                <div style="min-width:48px;font-size:11px;color:var(--text-secondary);text-align:right;font-weight:600">${label}</div>
                <div style="flex:1;height:22px;background:rgba(255,255,255,0.04);border-radius:4px;overflow:hidden;position:relative">
                    <div style="height:100%;width:${pct.toFixed(0)}%;background:${color};border-radius:4px;transition:width .3s"></div>
                    <span style="position:absolute;right:8px;top:3px;font-size:10px;font-weight:700;color:var(--text-primary)">${count}/${total} (${pct.toFixed(0)}%)</span>
                </div>
            </div>`;
        };

        const evBar = (label, count, total, color) => {
            const pct = total > 0 ? (count / total) : 0;
            const pctStr = (pct * 100).toFixed(0);
            const fairOdd = pct > 0 ? (1 / pct).toFixed(2) : '∞';
            const evColor = pct >= 0.55 ? 'var(--accent-green)' : pct >= 0.40 ? 'var(--accent-yellow)' : 'var(--text-muted)';
            return `<div style="display:flex;align-items:center;gap:8px;margin:3px 0">
                <div style="min-width:48px;font-size:11px;color:var(--text-secondary);text-align:right;font-weight:600">${label}</div>
                <div style="flex:1;height:22px;background:rgba(255,255,255,0.04);border-radius:4px;overflow:hidden;position:relative">
                    <div style="height:100%;width:${pctStr}%;background:${color};border-radius:4px;transition:width .3s"></div>
                    <span style="position:absolute;right:8px;top:3px;font-size:10px;font-weight:700;color:var(--text-primary)">${count}/${total} (${pctStr}%)</span>
                </div>
                <div style="min-width:68px;text-align:center;font-size:10px;font-weight:700;color:${evColor};background:rgba(255,255,255,0.03);padding:2px 6px;border-radius:4px" title="Odd justa calculada (se mercado oferece odd MAIOR que esta, pode ser EV+)">Fair: ${fairOdd}</div>
            </div>`;
        };

        const detailOpen = `<details style="margin-top:10px"><summary style="cursor:pointer;font-size:10px;color:var(--accent-green);font-weight:700;padding:4px 0">▶ VER JOGO A JOGO</summary><div style="overflow-x:auto;margin-top:6px">`;
        const detailClose = `</div></details>`;
        const _th = thStyle;
        const _td = tdStyle;

        // ═══ TAB 1: GOLS & BTTS (COMPLETO) ═══
        const goalsPanel = (() => {
            let teamG = 0, oppG = 0, btts = 0, cs = 0, fts = 0;
            const lines = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5];
            const oc = lines.map(() => 0);
            // Gols do Time O/U
            const teamLines = [0.5, 1.5, 2.5, 3.5];
            const teamOC = teamLines.map(() => 0);
            const oppLines = [0.5, 1.5, 2.5];
            const oppOC = oppLines.map(() => 0);

            ms.forEach(m => {
                const my = m.is_home ? m.score_home : m.score_away;
                const op = m.is_home ? m.score_away : m.score_home;
                teamG += my; oppG += op;
                if (my > 0 && op > 0) btts++;
                if (op === 0) cs++;
                if (my === 0) fts++;
                lines.forEach((l, i) => { if (m.total_goals > l) oc[i]++; });
                teamLines.forEach((l, i) => { if (my > l) teamOC[i]++; });
                oppLines.forEach((l, i) => { if (op > l) oppOC[i]++; });
            });
            let h = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
                ${kpi('Media Gols/J', ((teamG + oppG) / n).toFixed(1), 'var(--text-primary)')}
                ${kpi('Gols Pro/J', (teamG / n).toFixed(1), 'var(--accent-green)')}
                ${kpi('Gols Contra/J', (oppG / n).toFixed(1), 'var(--accent-red)')}
                ${kpi('BTTS (Ambas)', ((btts / n) * 100).toFixed(0) + '%', 'var(--accent-yellow)')}
                ${kpi('Clean Sheet', ((cs / n) * 100).toFixed(0) + '%', 'var(--accent-blue)')}
                ${kpi('Falhou Marcar', ((fts / n) * 100).toFixed(0) + '%', 'var(--accent-red)')}
            </div>`;

            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-green);margin-bottom:4px;text-transform:uppercase">⚡ EV+ Over/Under Gols Totais</div>';
            h += '<div style="font-size:9px;color:var(--text-muted);margin-bottom:6px">Se a casa oferece odd MAIOR que a "Fair", historicamente e EV+</div>';
            lines.forEach((l, i) => { h += evBar('O ' + l, oc[i], n, 'var(--accent-green)'); });

            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-blue);margin:12px 0 4px;text-transform:uppercase">⚡ EV+ Gols do Time (Over/Under)</div>';
            teamLines.forEach((l, i) => { h += evBar('O ' + l, teamOC[i], n, 'var(--accent-blue)'); });

            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-red);margin:12px 0 4px;text-transform:uppercase">⚡ EV+ Gols Adversario (Over/Under)</div>';
            oppLines.forEach((l, i) => { h += evBar('O ' + l, oppOC[i], n, 'var(--accent-red)'); });

            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-yellow);margin:12px 0 4px;text-transform:uppercase">⚡ EV+ BTTS (Ambas Marcam)</div>';
            h += evBar('BTTS Sim', btts, n, 'var(--accent-yellow)');
            h += evBar('BTTS Nao', n - btts, n, 'var(--accent-cyan)');

            h += detailOpen + `<table style="width:100%;border-collapse:collapse;font-size:11px">
            <thead><tr>
                <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                <th style="${_th};text-align:center">GP</th><th style="${_th};text-align:center">GC</th>
                <th style="${_th};text-align:center">Total</th><th style="${_th};text-align:center">O/U 2.5</th>
                <th style="${_th};text-align:center">BTTS</th>
            </tr></thead><tbody>`;
            ms.forEach(m => {
                const my = m.is_home ? m.score_home : m.score_away;
                const op = m.is_home ? m.score_away : m.score_home;
                const ou = m.total_goals > 2.5 ? '<span style="color:var(--accent-green)">Over</span>' : '<span style="color:var(--accent-red)">Under</span>';
                const bt = (my > 0 && op > 0) ? '<span style="color:var(--accent-green)">Sim</span>' : '<span style="color:var(--accent-red)">Nao</span>';
                h += `<tr><td style="${_td};color:var(--text-muted)">${m.date}</td><td style="${_td}">${m.opponent}</td>
                    <td style="${_td};text-align:center;color:var(--accent-green)">${my}</td>
                    <td style="${_td};text-align:center;color:var(--accent-red)">${op}</td>
                    <td style="${_td};text-align:center;font-weight:700">${m.total_goals}</td>
                    <td style="${_td};text-align:center">${ou}</td>
                    <td style="${_td};text-align:center">${bt}</td></tr>`;
            });
            h += '</tbody></table>' + detailClose;
            return h;
        })();

        // ═══ TAB 2: ESCANTEIOS ═══
        const cornersPanel = (() => {
            const valid = ms.filter(m => m.stats?.total_corners != null);
            if (!valid.length) return '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados de escanteios indisponiveis</div>';
            const vn = valid.length;
            let tc = 0, oc_ = 0;
            const lines = [7.5, 8.5, 9.5, 10.5, 11.5];
            const ovc = lines.map(() => 0);
            valid.forEach(m => {
                const t = si(m.stats.team_corners) || 0;
                const o = si(m.stats.opp_corners) || 0;
                tc += t; oc_ += o;
                lines.forEach((l, i) => { if (m.stats.total_corners > l) ovc[i]++; });
            });
            let h = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
                ${kpi('Media Total/J', ((tc + oc_) / vn).toFixed(1), 'var(--text-primary)')}
                ${kpi('Media Time/J', (tc / vn).toFixed(1), 'var(--accent-green)')}
                ${kpi('Media Advers./J', (oc_ / vn).toFixed(1), 'var(--accent-red)')}
                ${kpi('Jogos c/ Dados', vn + '/' + n, 'var(--text-muted)')}
            </div>`;
            h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:4px;text-transform:uppercase">Over/Under Escanteios</div>';
            lines.forEach((l, i) => { h += pctBar('O ' + l, ovc[i], vn, 'var(--accent-blue)'); });

            h += detailOpen + `<table style="width:100%;border-collapse:collapse;font-size:11px">
            <thead><tr>
                <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                <th style="${_th};text-align:center">Time</th><th style="${_th};text-align:center">Advers.</th>
                <th style="${_th};text-align:center">Total</th><th style="${_th};text-align:center">O/U 9.5</th>
            </tr></thead><tbody>`;
            valid.forEach(m => {
                const t = si(m.stats.team_corners) ?? '-';
                const o = si(m.stats.opp_corners) ?? '-';
                const tot = m.stats.total_corners;
                const ou = tot > 9.5 ? '<span style="color:var(--accent-green)">Over</span>' : '<span style="color:var(--accent-red)">Under</span>';
                h += `<tr><td style="${_td};color:var(--text-muted)">${m.date}</td><td style="${_td}">${m.opponent}</td>
                    <td style="${_td};text-align:center">${t}</td><td style="${_td};text-align:center">${o}</td>
                    <td style="${_td};text-align:center;font-weight:700">${tot}</td>
                    <td style="${_td};text-align:center">${ou}</td></tr>`;
            });
            h += '</tbody></table>' + detailClose;
            return h;
        })();

        // ═══ TAB 3: CARTÕES ═══
        const cardsPanel = (() => {
            const valid = ms.filter(m => m.stats?.total_cards != null);
            if (!valid.length) return '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados de cartoes indisponiveis</div>';
            const vn = valid.length;
            let ty = 0, tr_ = 0, oy = 0, or_ = 0;
            const lines = [2.5, 3.5, 4.5, 5.5, 6.5];
            const ovc = lines.map(() => 0);
            valid.forEach(m => {
                ty += si(m.stats.team_cards_yellow) || 0;
                tr_ += si(m.stats.team_cards_red) || 0;
                oy += si(m.stats.opp_cards_yellow) || 0;
                or_ += si(m.stats.opp_cards_red) || 0;
                lines.forEach((l, i) => { if (m.stats.total_cards > l) ovc[i]++; });
            });
            const totalC = ty + tr_ + oy + or_;
            let h = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
                ${kpi('Media Total/J', (totalC / vn).toFixed(1), 'var(--text-primary)')}
                ${kpi('🟨 Time/J', (ty / vn).toFixed(1), 'var(--accent-yellow)')}
                ${kpi('🟥 Time/J', (tr_ / vn).toFixed(1), 'var(--accent-red)')}
                ${kpi('🟨 Advers./J', (oy / vn).toFixed(1), 'var(--accent-yellow)')}
                ${kpi('🟥 Advers./J', (or_ / vn).toFixed(1), 'var(--accent-red)')}
            </div>`;
            h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:4px;text-transform:uppercase">Over/Under Cartoes</div>';
            lines.forEach((l, i) => { h += pctBar('O ' + l, ovc[i], vn, 'var(--accent-yellow)'); });

            h += detailOpen + `<table style="width:100%;border-collapse:collapse;font-size:11px">
            <thead><tr>
                <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                <th style="${_th};text-align:center">🟨 T</th><th style="${_th};text-align:center">🟥 T</th>
                <th style="${_th};text-align:center">🟨 A</th><th style="${_th};text-align:center">🟥 A</th>
                <th style="${_th};text-align:center">Total</th><th style="${_th};text-align:center">O/U 4.5</th>
            </tr></thead><tbody>`;
            valid.forEach(m => {
                const _ty = si(m.stats.team_cards_yellow) ?? '-';
                const _tr = si(m.stats.team_cards_red) ?? '-';
                const _oy = si(m.stats.opp_cards_yellow) ?? '-';
                const _or = si(m.stats.opp_cards_red) ?? '-';
                const tot = m.stats.total_cards;
                const ou = tot > 4.5 ? '<span style="color:var(--accent-green)">Over</span>' : '<span style="color:var(--accent-red)">Under</span>';
                h += `<tr><td style="${_td};color:var(--text-muted)">${m.date}</td><td style="${_td}">${m.opponent}</td>
                    <td style="${_td};text-align:center">${_ty}</td><td style="${_td};text-align:center">${_tr}</td>
                    <td style="${_td};text-align:center">${_oy}</td><td style="${_td};text-align:center">${_or}</td>
                    <td style="${_td};text-align:center;font-weight:700">${tot}</td>
                    <td style="${_td};text-align:center">${ou}</td></tr>`;
            });
            h += '</tbody></table>' + detailClose;
            return h;
        })();

        // ═══ TAB 4: FINALIZAÇÕES ═══
        const shotsPanel = (() => {
            const valid = ms.filter(m => m.stats?.team_shots != null);
            if (!valid.length) return '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados de finalizacoes indisponiveis</div>';
            const vn = valid.length;
            let tShots = 0, tSoT = 0, oShots = 0, oSoT = 0, tSaves = 0, oSaves = 0;
            valid.forEach(m => {
                tShots += si(m.stats.team_shots) || 0;
                tSoT += si(m.stats.team_shots_on_target) || 0;
                oShots += si(m.stats.opp_shots) || 0;
                oSoT += si(m.stats.opp_shots_on_target) || 0;
                tSaves += si(m.stats.team_saves) || 0;
                oSaves += si(m.stats.opp_saves) || 0;
            });
            let h = `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
                ${kpi('Finaliz. Time/J', (tShots / vn).toFixed(1), 'var(--accent-green)')}
                ${kpi('No Alvo Time/J', (tSoT / vn).toFixed(1), 'var(--accent-green)')}
                ${kpi('Finaliz. Adv./J', (oShots / vn).toFixed(1), 'var(--accent-red)')}
                ${kpi('No Alvo Adv./J', (oSoT / vn).toFixed(1), 'var(--accent-red)')}
                ${kpi('Defesas Gol./J', (tSaves / vn).toFixed(1), 'var(--accent-blue)')}
                ${kpi('% Acerto Time', tShots > 0 ? ((tSoT / tShots) * 100).toFixed(0) + '%' : '-', 'var(--accent-yellow)')}
            </div>`;

            // ── EV+ Finalizações do TIME (Over/Under) ──
            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-green);margin:12px 0 4px;text-transform:uppercase">⚡ EV+ Finalizacoes do Time (Over/Under)</div>';
            h += '<div style="font-size:9px;color:var(--text-muted);margin-bottom:6px">Se a casa oferece odd MAIOR que a "Fair", historicamente e EV+</div>';
            const teamShotLines = [7.5, 8.5, 9.5, 10.5, 11.5, 12.5];
            const tslOvc = teamShotLines.map(() => 0);
            valid.forEach(m => {
                const ts = si(m.stats.team_shots) || 0;
                teamShotLines.forEach((l, i) => { if (ts > l) tslOvc[i]++; });
            });
            teamShotLines.forEach((l, i) => { h += evBar('O ' + l, tslOvc[i], vn, 'var(--accent-green)'); });

            // ── EV+ Finalizações em GOL do TIME ──
            h += '<div style="font-size:10px;font-weight:700;color:var(--accent-green);margin:14px 0 4px;text-transform:uppercase">⚡ EV+ Finalizacoes em Gol do Time (Over/Under)</div>';
            const teamSoTLines = [1.5, 2.5, 3.5, 4.5, 5.5];
            const tsotOvc = teamSoTLines.map(() => 0);
            valid.forEach(m => {
                const sot = si(m.stats.team_shots_on_target) || 0;
                teamSoTLines.forEach((l, i) => { if (sot > l) tsotOvc[i]++; });
            });
            teamSoTLines.forEach((l, i) => { h += evBar('O ' + l, tsotOvc[i], vn, 'var(--accent-blue)'); });

            // ── Over/Under Totais no Jogo ──
            h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin:14px 0 4px;text-transform:uppercase">Over/Under Finalizacoes Totais no Jogo</div>';
            const totalLines = [17.5, 19.5, 21.5, 23.5, 25.5];
            const ovc = totalLines.map(() => 0);
            valid.forEach(m => {
                const tot = (si(m.stats.team_shots) || 0) + (si(m.stats.opp_shots) || 0);
                totalLines.forEach((l, i) => { if (tot > l) ovc[i]++; });
            });
            totalLines.forEach((l, i) => { h += pctBar('O ' + l, ovc[i], vn, 'var(--accent-green)'); });

            h += detailOpen + `<table style="width:100%;border-collapse:collapse;font-size:11px">
            <thead><tr>
                <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                <th style="${_th};text-align:center">Fin. T</th><th style="${_th};text-align:center">Alvo T</th>
                <th style="${_th};text-align:center">Fin. A</th><th style="${_th};text-align:center">Alvo A</th>
                <th style="${_th};text-align:center">Total</th><th style="${_th};text-align:center">Def. T</th>
            </tr></thead><tbody>`;
            valid.forEach(m => {
                const ts = si(m.stats.team_shots) ?? '-';
                const tst = si(m.stats.team_shots_on_target) ?? '-';
                const os = si(m.stats.opp_shots) ?? '-';
                const ost = si(m.stats.opp_shots_on_target) ?? '-';
                const tot = (si(m.stats.team_shots) || 0) + (si(m.stats.opp_shots) || 0);
                const sv = si(m.stats.team_saves) ?? '-';
                h += `<tr><td style="${_td};color:var(--text-muted)">${m.date}</td><td style="${_td}">${m.opponent}</td>
                    <td style="${_td};text-align:center">${ts}</td><td style="${_td};text-align:center">${tst}</td>
                    <td style="${_td};text-align:center">${os}</td><td style="${_td};text-align:center">${ost}</td>
                    <td style="${_td};text-align:center;font-weight:700">${tot}</td>
                    <td style="${_td};text-align:center">${sv}</td></tr>`;
            });
            h += '</tbody></table>' + detailClose;
            return h;
        })();

        // ═══ TAB EV+ JOGADORES ═══
        const playersPanel = (() => {
            // Agregar dados de jogadores por todos os jogos
            const matchesWithPlayers = ms.filter(m => m.players && m.players.length > 0);
            if (!matchesWithPlayers.length) return '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados de finalizacoes de jogadores indisponiveis.<br><span style="font-size:9px">Estes dados sao buscados via API ao carregar o historico.</span></div>';

            const playerMap = {};
            matchesWithPlayers.forEach((m, mi) => {
                m.players.forEach(p => {
                    if (!p.name || !p.minutes || p.minutes < 1) return;
                    const key = p.id || p.name;
                    if (!playerMap[key]) {
                        playerMap[key] = {
                            id: p.id, name: p.name, position: p.position,
                            matches: 0, totalShots: 0, totalSOT: 0, totalGoals: 0,
                            totalAssists: 0, totalMinutes: 0,
                            shotsPerMatch: [], sotPerMatch: [],
                            matchDetails: [],
                        };
                    }
                    const pl = playerMap[key];
                    pl.matches++;
                    pl.totalShots += p.total_shots;
                    pl.totalSOT += p.shots_on_target;
                    pl.totalGoals += p.goals;
                    pl.totalAssists += p.assists;
                    pl.totalMinutes += p.minutes;
                    pl.shotsPerMatch.push(p.total_shots);
                    pl.sotPerMatch.push(p.shots_on_target);
                    pl.matchDetails.push({
                        date: m.date, opponent: m.opponent, minutes: p.minutes,
                        shots: p.total_shots, sot: p.shots_on_target,
                        goals: p.goals, substitute: p.substitute,
                    });
                });
            });

            // Filtrar e ordenar por média de finalizações
            const players = Object.values(playerMap)
                .filter(p => p.matches >= 2)
                .sort((a, b) => (b.totalShots / b.matches) - (a.totalShots / a.matches));

            if (!players.length) return '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Insuficientes dados de jogadores (minimo 2 partidas)</div>';

            let h = '';

            // ── 1. RANKING DE FINALIZAÇÕES ──
            h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">🏆 Ranking de Finalizacoes por Jogador</div>';
            h += `<div style="overflow-x:auto;margin-bottom:16px"><table style="width:100%;border-collapse:collapse;font-size:11px">
            <thead><tr>
                <th style="${_th}">Jogador</th><th style="${_th};text-align:center">Pos</th>
                <th style="${_th};text-align:center">Jogos</th><th style="${_th};text-align:center">Min</th>
                <th style="${_th};text-align:center">Fin. Total</th><th style="${_th};text-align:center;color:var(--accent-green)">Fin/J</th>
                <th style="${_th};text-align:center">No Alvo</th><th style="${_th};text-align:center;color:var(--accent-blue)">Alvo/J</th>
                <th style="${_th};text-align:center">Gols</th><th style="${_th};text-align:center">Assist.</th>
            </tr></thead><tbody>`;
            players.slice(0, 15).forEach((p, i) => {
                const avgS = (p.totalShots / p.matches).toFixed(1);
                const avgSOT = (p.totalSOT / p.matches).toFixed(1);
                const posColor = p.position === 'F' ? 'var(--accent-red)' : p.position === 'M' ? 'var(--accent-green)' : p.position === 'D' ? 'var(--accent-blue)' : 'var(--text-muted)';
                const posLabel = p.position === 'F' ? 'ATA' : p.position === 'M' ? 'MEI' : p.position === 'D' ? 'DEF' : p.position === 'G' ? 'GOL' : p.position;
                const rowBg = i < 3 ? 'rgba(0,255,136,0.03)' : 'transparent';
                h += `<tr style="background:${rowBg}">
                    <td style="${_td};font-weight:${i < 3 ? '700' : '400'}">${i < 3 ? '⭐ ' : ''}${p.name}</td>
                    <td style="${_td};text-align:center"><span style="color:${posColor};font-weight:700;font-size:9px">${posLabel}</span></td>
                    <td style="${_td};text-align:center">${p.matches}</td>
                    <td style="${_td};text-align:center;color:var(--text-muted)">${p.totalMinutes}</td>
                    <td style="${_td};text-align:center">${p.totalShots}</td>
                    <td style="${_td};text-align:center;font-weight:700;color:var(--accent-green)">${avgS}</td>
                    <td style="${_td};text-align:center">${p.totalSOT}</td>
                    <td style="${_td};text-align:center;font-weight:700;color:var(--accent-blue)">${avgSOT}</td>
                    <td style="${_td};text-align:center;font-weight:700">${p.totalGoals}</td>
                    <td style="${_td};text-align:center">${p.totalAssists}</td>
                </tr>`;
            });
            h += '</tbody></table></div>';

            // ── 2. EV+ FINALIZAÇÕES POR JOGADOR ──
            const topPlayers = players.filter(p => p.matches >= 2 && p.totalShots > 0).slice(0, 10);
            if (topPlayers.length) {
                h += '<div style="font-size:10px;font-weight:700;color:var(--accent-green);margin:8px 0 4px;text-transform:uppercase">⚡ EV+ Finalizacoes por Jogador (Over/Under)</div>';
                h += '<div style="font-size:9px;color:var(--text-muted);margin-bottom:8px">Probabilidade historica de cada jogador ter mais de X finalizacoes. "Fair" = odd justa. Se o mercado oferecer odd MAIOR, pode ser EV+.</div>';

                topPlayers.forEach(p => {
                    const avgS = (p.totalShots / p.matches).toFixed(1);
                    h += `<div style="background:rgba(255,255,255,0.02);border-radius:8px;padding:10px 12px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.04)">`;
                    h += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
                        <span style="font-weight:700;font-size:12px;color:var(--text-primary)">${p.name}</span>
                        <span style="font-size:9px;color:var(--text-muted)">${p.matches}j | ${avgS} fin/j | ${(p.totalSOT / p.matches).toFixed(1)} alvo/j</span>
                    </div>`;

                    // O/U Finalizações
                    h += '<div style="font-size:9px;font-weight:600;color:var(--text-muted);margin-bottom:3px">FINALIZACOES</div>';
                    [0.5, 1.5, 2.5, 3.5, 4.5].forEach(line => {
                        const over = p.shotsPerMatch.filter(s => s > line).length;
                        h += evBar('O ' + line, over, p.matches, 'var(--accent-green)');
                    });

                    // O/U Finalizações em Gol
                    h += '<div style="font-size:9px;font-weight:600;color:var(--text-muted);margin:6px 0 3px">FINALIZACOES EM GOL (No Alvo)</div>';
                    [0.5, 1.5, 2.5, 3.5].forEach(line => {
                        const over = p.sotPerMatch.filter(s => s > line).length;
                        h += evBar('O ' + line, over, p.matches, 'var(--accent-blue)');
                    });

                    h += '</div>';
                });
            }

            // ── 3. DETALHAMENTO JOGO A JOGO POR JOGADOR ──
            h += detailOpen.replace('VER JOGO A JOGO', 'VER HISTORICO COMPLETO POR JOGADOR');
            topPlayers.slice(0, 8).forEach(p => {
                h += `<div style="margin-bottom:10px">
                <div style="font-size:11px;font-weight:700;color:var(--text-primary);margin-bottom:4px">${p.name} <span style="color:var(--text-muted);font-weight:400">(${p.matches} jogos)</span></div>
                <table style="width:100%;border-collapse:collapse;font-size:10px">
                <thead><tr>
                    <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                    <th style="${_th};text-align:center">Min</th>
                    <th style="${_th};text-align:center">Fin.</th><th style="${_th};text-align:center">Alvo</th>
                    <th style="${_th};text-align:center">Gols</th><th style="${_th};text-align:center">Titular</th>
                </tr></thead><tbody>`;
                p.matchDetails.forEach(md => {
                    const shotsBg = md.shots >= 3 ? 'rgba(0,255,136,0.08)' : 'transparent';
                    const sotBg = md.sot >= 2 ? 'rgba(100,180,255,0.08)' : 'transparent';
                    const titLabel = md.substitute ? '<span style="color:var(--text-muted);font-size:9px">SUB</span>' : '<span style="color:var(--accent-green);font-size:9px">TIT</span>';
                    h += `<tr>
                        <td style="${_td};color:var(--text-muted)">${md.date}</td>
                        <td style="${_td}">${md.opponent}</td>
                        <td style="${_td};text-align:center;color:var(--text-muted)">${md.minutes}'</td>
                        <td style="${_td};text-align:center;font-weight:700;background:${shotsBg}">${md.shots}</td>
                        <td style="${_td};text-align:center;font-weight:700;background:${sotBg}">${md.sot}</td>
                        <td style="${_td};text-align:center;font-weight:700;color:${md.goals > 0 ? 'var(--accent-green)' : 'var(--text-muted)'}">${md.goals}</td>
                        <td style="${_td};text-align:center">${titLabel}</td>
                    </tr>`;
                });
                h += '</tbody></table></div>';
            });
            h += detailClose;

            return h;
        })();

        // ═══ TAB 5: POSSE, FALTAS, xG, PASSES ═══
        const otherPanel = (() => {
            let html = '';

            // Posse
            const possValid = ms.filter(m => m.stats?.team_possession != null);
            if (possValid.length) {
                const pvn = possValid.length;
                let tp = 0;
                possValid.forEach(m => { tp += parsePoss(m.stats.team_possession) || 0; });
                const avg = (tp / pvn).toFixed(1);
                html += `<div style="margin-bottom:16px">
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Posse de Bola</div>
                    <div style="display:flex;align-items:center;gap:12px">
                        <div style="font-size:28px;font-weight:800;color:var(--accent-green)">${avg}%</div>
                        <div style="flex:1">${pctBar('Media', Math.round(tp / pvn), 100, 'var(--accent-green)')}</div>
                    </div>
                </div>`;
            }

            // xG
            const xgValid = ms.filter(m => m.stats?.team_expected_goals != null);
            if (xgValid.length) {
                const xn = xgValid.length;
                let txg = 0, oxg = 0;
                xgValid.forEach(m => {
                    txg += parseFloat(m.stats.team_expected_goals) || 0;
                    oxg += parseFloat(m.stats.opp_expected_goals) || 0;
                });
                html += `<div style="margin-bottom:16px">
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Expected Goals (xG)</div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px">
                        ${kpi('xG Time/J', (txg / xn).toFixed(2), 'var(--accent-green)')}
                        ${kpi('xG Advers./J', (oxg / xn).toFixed(2), 'var(--accent-red)')}
                        ${kpi('xG Total/J', ((txg + oxg) / xn).toFixed(2), 'var(--text-primary)')}
                        ${kpi('xG Diff/J', ((txg - oxg) / xn > 0 ? '+' : '') + ((txg - oxg) / xn).toFixed(2), (txg - oxg) >= 0 ? 'var(--accent-green)' : 'var(--accent-red)')}
                    </div>
                </div>`;
            }

            // Faltas
            const foulsValid = ms.filter(m => m.stats?.team_fouls != null);
            if (foulsValid.length) {
                const fn_ = foulsValid.length;
                let tf = 0, of_ = 0;
                foulsValid.forEach(m => {
                    tf += si(m.stats.team_fouls) || 0;
                    of_ += si(m.stats.opp_fouls) || 0;
                });
                const fLines = [17.5, 19.5, 21.5, 23.5, 25.5];
                const fOvc = fLines.map(() => 0);
                foulsValid.forEach(m => {
                    const tot = (si(m.stats.team_fouls) || 0) + (si(m.stats.opp_fouls) || 0);
                    fLines.forEach((l, i) => { if (tot > l) fOvc[i]++; });
                });
                html += `<div style="margin-bottom:16px">
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Faltas</div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px">
                        ${kpi('Media Time/J', (tf / fn_).toFixed(1), 'var(--accent-yellow)')}
                        ${kpi('Media Advers./J', (of_ / fn_).toFixed(1), 'var(--accent-red)')}
                        ${kpi('Total/J', ((tf + of_) / fn_).toFixed(1), 'var(--text-primary)')}
                    </div>
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:4px;text-transform:uppercase">Over/Under Faltas Totais</div>
                    ${fLines.map((l, i) => pctBar('O ' + l, fOvc[i], fn_, 'var(--accent-yellow)')).join('')}
                </div>`;
            }

            // Impedimentos
            const offValid = ms.filter(m => m.stats?.team_offsides != null);
            if (offValid.length) {
                const on_ = offValid.length;
                let to_ = 0, oo_ = 0;
                offValid.forEach(m => {
                    to_ += si(m.stats.team_offsides) || 0;
                    oo_ += si(m.stats.opp_offsides) || 0;
                });
                html += `<div style="margin-bottom:16px">
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Impedimentos</div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px">
                        ${kpi('Media Time/J', (to_ / on_).toFixed(1), 'var(--text-primary)')}
                        ${kpi('Media Advers./J', (oo_ / on_).toFixed(1), 'var(--text-primary)')}
                    </div>
                </div>`;
            }

            // Passes
            const passValid = ms.filter(m => m.stats?.team_passes != null);
            if (passValid.length) {
                const pn = passValid.length;
                let tpass = 0, opass = 0;
                passValid.forEach(m => {
                    tpass += si(m.stats.team_passes) || 0;
                    opass += si(m.stats.opp_passes) || 0;
                });
                const pctV = ms.filter(m => m.stats?.team_passes_pct != null);
                let tpct = 0, opct = 0;
                if (pctV.length) {
                    pctV.forEach(m => {
                        tpct += parsePoss(m.stats.team_passes_pct) || 0;
                        opct += parsePoss(m.stats.opp_passes_pct) || 0;
                    });
                }
                html += `<div style="margin-bottom:16px">
                    <div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Passes</div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px">
                        ${kpi('Media Time/J', (tpass / pn).toFixed(0), 'var(--accent-green)')}
                        ${kpi('Media Advers./J', (opass / pn).toFixed(0), 'var(--accent-red)')}
                        ${pctV.length ? kpi('Precisao Time', (tpct / pctV.length).toFixed(0) + '%', 'var(--accent-green)') : ''}
                        ${pctV.length ? kpi('Precisao Adv.', (opct / pctV.length).toFixed(0) + '%', 'var(--accent-red)') : ''}
                    </div>
                </div>`;
            }

            if (!html) html = '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados gerais indisponiveis</div>';
            return html;
        })();

        // ═══ TAB 6: 1° TEMPO + CLEAN SHEET + ESPECIAIS ═══
        const specialsPanel = (() => {
            // ── HT (1° Tempo) ──
            const htValid = ms.filter(m => m.ht_total != null);
            let h = '';
            if (htValid.length) {
                const hn = htValid.length;
                let htWin = 0, htDraw = 0, htLoss = 0;
                const htLines = [0.5, 1.5, 2.5];
                const htOvc = htLines.map(() => 0);
                htValid.forEach(m => {
                    const myHT = m.is_home ? m.ht_home : m.ht_away;
                    const opHT = m.is_home ? m.ht_away : m.ht_home;
                    if (myHT > opHT) htWin++; else if (myHT === opHT) htDraw++; else htLoss++;
                    htLines.forEach((l, i) => { if (m.ht_total > l) htOvc[i]++; });
                });
                h += `<div style="font-size:10px;font-weight:700;color:var(--accent-cyan);margin-bottom:6px;text-transform:uppercase">⏱️ Resultado no 1° Tempo</div>
                <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
                    ${kpi('Vencendo HT', ((htWin/hn)*100).toFixed(0)+'%', 'var(--accent-green)')}
                    ${kpi('Empatando HT', ((htDraw/hn)*100).toFixed(0)+'%', 'var(--accent-yellow)')}
                    ${kpi('Perdendo HT', ((htLoss/hn)*100).toFixed(0)+'%', 'var(--accent-red)')}
                    ${kpi('Amostra', hn+'j', 'var(--text-muted)')}
                </div>`;
                h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:4px;text-transform:uppercase">Over/Under Gols 1° Tempo</div>';
                htLines.forEach((l, i) => { h += evBar('O '+l, htOvc[i], hn, 'var(--accent-cyan)'); });
                h += detailOpen + `<table style="width:100%;border-collapse:collapse;font-size:11px"><thead><tr>
                    <th style="${_th}">Data</th><th style="${_th}">Adversario</th>
                    <th style="${_th};text-align:center">HT Time</th><th style="${_th};text-align:center">HT Adv.</th>
                    <th style="${_th};text-align:center">HT Total</th><th style="${_th};text-align:center">FT</th>
                </tr></thead><tbody>`;
                htValid.forEach(m => {
                    const myHT = m.is_home ? m.ht_home : m.ht_away;
                    const opHT = m.is_home ? m.ht_away : m.ht_home;
                    const myFT = m.is_home ? m.score_home : m.score_away;
                    const opFT = m.is_home ? m.score_away : m.score_home;
                    h += `<tr><td style="${_td};color:var(--text-muted)">${m.date}</td><td style="${_td}">${m.opponent}</td>
                        <td style="${_td};text-align:center">${myHT}</td><td style="${_td};text-align:center">${opHT}</td>
                        <td style="${_td};text-align:center;font-weight:700">${m.ht_total}</td>
                        <td style="${_td};text-align:center;font-weight:700">${myFT}-${opFT}</td></tr>`;
                });
                h += '</tbody></table>' + detailClose;
            } else {
                h += '<div style="color:var(--text-muted);font-size:11px;margin-bottom:16px">Dados de 1° Tempo indisponiveis</div>';
            }

            // ── Clean Sheet & Win to Nil & Especiais ──
            const nn = ms.length;
            if (nn) {
                let cs = 0, fts = 0, wtn = 0, oddG = 0;
                ms.forEach(m => {
                    const my = m.is_home ? m.score_home : m.score_away;
                    const op = m.is_home ? m.score_away : m.score_home;
                    if (op === 0) cs++;
                    if (my === 0) fts++;
                    if (my > 0 && op === 0) wtn++;
                    if (m.total_goals % 2 === 1) oddG++;
                });
                h += `<div style="font-size:10px;font-weight:700;color:var(--accent-cyan);margin:16px 0 6px;text-transform:uppercase">🧤 Clean Sheet & Especiais</div>
                <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px">
                    ${kpi('Clean Sheet', ((cs/nn)*100).toFixed(0)+'%', 'var(--accent-green)')}
                    ${kpi('Falhou Marcar', ((fts/nn)*100).toFixed(0)+'%', 'var(--accent-red)')}
                    ${kpi('Vit s/ Sofrer', ((wtn/nn)*100).toFixed(0)+'%', 'var(--accent-green)')}
                    ${kpi('Gols Impar', ((oddG/nn)*100).toFixed(0)+'%', 'var(--accent-yellow)')}
                    ${kpi('Gols Par', (((nn-oddG)/nn)*100).toFixed(0)+'%', 'var(--accent-blue)')}
                </div>`;
                h += '<div style="font-size:10px;font-weight:700;color:var(--text-muted);margin-bottom:4px;text-transform:uppercase">EV+ Especiais</div>';
                h += evBar('CS Sim', cs, nn, 'var(--accent-green)');
                h += evBar('CS Nao', nn-cs, nn, 'var(--accent-red)');
                h += evBar('V s/Sofrer', wtn, nn, 'var(--accent-green)');
                h += evBar('Gols Impar', oddG, nn, 'var(--accent-yellow)');
                h += evBar('Gols Par', nn-oddG, nn, 'var(--accent-blue)');
            }
            if (!h) h = '<div style="color:var(--text-muted);font-size:11px;text-align:center;padding:16px">Dados especiais indisponiveis</div>';
            return h;
        })();

        // ═══ Montar tabs ═══
        const tabs = [
            { id: 'goals',    label: '⚽ Gols & BTTS',      content: goalsPanel },
            { id: 'specials', label: '⏱️ HT/CS/Especiais',  content: specialsPanel },
            { id: 'corners',  label: '🏁 Escanteios',       content: cornersPanel },
            { id: 'cards',    label: '🟨 Cartoes',          content: cardsPanel },
            { id: 'shots',    label: '🎯 Fin. Time',        content: shotsPanel },
            { id: 'players',  label: '⚡ EV+ Jogadores',    content: playersPanel },
            { id: 'other',    label: '📊 Posse/xG/Gerais',  content: otherPanel },
        ];

        const btnStyle = 'padding:6px 14px;border-radius:6px;font-size:10px;font-weight:700;cursor:pointer;border:1px solid rgba(255,255,255,0.08);transition:all .2s';

        let html = `<div style="margin-top:16px;padding:14px;background:rgba(255,255,255,0.015);border-radius:10px;border:1px solid var(--border)">`;
        html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap;gap:6px">
            <div style="font-size:12px;font-weight:800;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1px">📊 Analise por Mercado</div>
            <div style="font-size:9px;color:var(--text-muted)">${n} jogos com estatisticas de ${ms.length > 0 ? ms.length : 0} partidas</div>
        </div>`;

        html += `<div style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:12px">`;
        tabs.forEach((t, i) => {
            const bg = i === 0 ? 'var(--accent-green)' : 'rgba(255,255,255,0.05)';
            const fg = i === 0 ? '#000' : 'var(--text-secondary)';
            const bc = i === 0 ? 'var(--accent-green)' : 'rgba(255,255,255,0.08)';
            html += `<button id="${uid}_btn_${t.id}" data-mkt-btn="${uid}" style="${btnStyle};background:${bg};color:${fg};border-color:${bc}" onclick="switchMktTab('${uid}','${t.id}')">${t.label}</button>`;
        });
        html += '</div>';

        tabs.forEach((t, i) => {
            html += `<div id="${uid}_${t.id}" data-mkt-uid="${uid}" style="display:${i === 0 ? 'block' : 'none'}">${t.content}</div>`;
        });

        html += '</div>';
        return html;
    };

    // ── Renderizar secao de um time ──
    let _mktCounter = 0;
    const renderTeam = (data, name, color) => {
        const lg = data.league_matches || [];
        const all = data.all_matches || [];
        const mktUid = 'mkt_' + (++_mktCounter) + '_' + Date.now();
        let html = sectionTitle('', name, color);

        if (lg.length > 0) {
            html += subTitle('No Campeonato Atual (' + (lg[0]?.league_name || '') + ')');
            html += summaryBadges(calcSummary(lg));
            html += tableWrap(lg.map(matchRow).join(''));
        }
        if (all.length > 0) {
            html += subTitle('Todas as Competicoes (ultimos ' + all.length + ')');
            html += summaryBadges(calcSummary(all));
            html += tableWrapFull(all.map(matchRowFull).join(''));
        }
        if (!lg.length && !all.length) {
            html += '<div style="color:var(--text-muted);padding:12px;text-align:center">Sem dados historicos disponiveis</div>';
        }

        // Análise por Mercado — usa all_matches (mais dados) ou lg se all vazio
        const mktMatches = all.length > 0 ? all : lg;
        if (mktMatches.length > 0) {
            html += buildMarketAnalysis(mktMatches, mktUid);
        }

        return html;
    };

    // ── Renderizar H2H ──
    const renderH2H = (matches, hName, aName) => {
        if (!matches || !matches.length) return sectionTitle('⚔️', 'Confronto Direto', 'var(--accent-yellow)') + '<div style="color:var(--text-muted);padding:12px;text-align:center">Sem confrontos diretos encontrados</div>';

        // Estatisticas do H2H
        let hWins = 0, aWins = 0, draws = 0, totalG = 0, over25 = 0;
        matches.forEach(m => {
            totalG += m.total_goals;
            if (m.total_goals > 2.5) over25++;
            if (m.score_home > m.score_away) {
                // Verificar quem eh quem
                if (m.home_team === hName || m.home_id === (homeData?.team_id)) hWins++; else aWins++;
            } else if (m.score_away > m.score_home) {
                if (m.away_team === hName || m.away_id === (homeData?.team_id)) hWins++; else aWins++;
            } else {
                draws++;
            }
        });

        const avgG = (totalG / matches.length).toFixed(1);
        const o25Pct = ((over25 / matches.length) * 100).toFixed(0);

        let html = sectionTitle('⚔️', 'Confronto Direto — ' + hName + ' vs ' + aName, 'var(--accent-yellow)');
        html += `<div style="display:flex;flex-wrap:wrap;gap:5px;margin:6px 0 10px">
            ${badge(hWins + ' vit. ' + hName, 'rgba(0,255,136,0.12)', 'var(--accent-green)')}
            ${badge(draws + ' empates', 'rgba(255,200,0,0.12)', 'var(--accent-yellow)')}
            ${badge(aWins + ' vit. ' + aName, 'rgba(100,180,255,0.12)', 'var(--accent-blue)')}
            ${badge('Media ' + avgG + ' gols/j', 'rgba(255,255,255,0.05)', 'var(--text-secondary)')}
            ${badge('O2.5: ' + o25Pct + '%', 'rgba(255,255,255,0.05)', 'var(--text-secondary)')}
        </div>`;

        // Tabela H2H
        const h2hRows = matches.map(m => {
            const tg = m.total_goals;
            const ou = tg > 2.5 ? '<span style="color:var(--accent-green)">O2.5</span>' : '<span style="color:var(--accent-red)">U2.5</span>';
            const hc = m.score_home > m.score_away ? 'var(--accent-green)' : m.score_home < m.score_away ? 'var(--accent-red)' : 'var(--accent-yellow)';
            const ac = m.score_away > m.score_home ? 'var(--accent-green)' : m.score_away < m.score_home ? 'var(--accent-red)' : 'var(--accent-yellow)';
            return `<tr>
                <td style="${tdStyle};color:var(--text-muted);white-space:nowrap">${m.date}</td>
                <td style="${tdStyle};font-size:11px">${m.league_name || ''}</td>
                <td style="${tdStyle};text-align:right;font-weight:600"><span style="color:${hc}">${m.home_team}</span></td>
                <td style="${tdStyle};text-align:center;font-weight:800;font-family:'JetBrains Mono';font-size:14px">${m.score_home} - ${m.score_away}</td>
                <td style="${tdStyle};font-weight:600"><span style="color:${ac}">${m.away_team}</span></td>
                <td style="${tdStyle};text-align:center;font-size:10px">${ou}</td>
            </tr>`;
        }).join('');

        html += `<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;min-width:500px">
            <thead><tr>
                <th style="${thStyle}">Data</th>
                <th style="${thStyle}">Competicao</th>
                <th style="${thStyle};text-align:right">Mandante</th>
                <th style="${thStyle};text-align:center">Placar</th>
                <th style="${thStyle}">Visitante</th>
                <th style="${thStyle};text-align:center">O/U</th>
            </tr></thead><tbody>${h2hRows}</tbody></table></div>`;

        return html;
    };

    // ── Painel EV+ Summary (top oportunidades pre-computadas) ──
    const renderEvSummary = (homeData, awayData, homeName, awayName) => {
        const homeEv = homeData.ev_analysis || {};
        const awayEv = awayData.ev_analysis || {};
        const homeOpps = homeEv.top_opportunities || [];
        const awayOpps = awayEv.top_opportunities || [];
        const homePlayerRank = homeEv.player_rankings || [];
        const awayPlayerRank = awayEv.player_rankings || [];
        if (!homeOpps.length && !awayOpps.length && !homePlayerRank.length && !awayPlayerRank.length) return '';

        const _thr = 'padding:6px 8px;font-size:10px;text-align:left;border-bottom:1px solid var(--border);color:var(--text-muted);text-transform:uppercase;font-weight:700';
        const _tdr = 'padding:5px 8px;font-size:11px;border-bottom:1px solid rgba(255,255,255,0.03)';

        const fairOddClass = (fair) => {
            if (fair <= 1.30) return 'color:var(--accent-green);font-weight:700';
            if (fair <= 1.60) return 'color:var(--accent-yellow);font-weight:700';
            return 'color:var(--text-secondary)';
        };

        const renderOppsTable = (opps, teamName, color) => {
            if (!opps.length) return '';
            let h = `<div style="margin-bottom:14px">
                <div style="font-size:11px;font-weight:800;color:${color};margin-bottom:6px">${teamName}</div>
                <div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:11px">
                <thead><tr>
                    <th style="${_thr}">Mercado</th><th style="${_thr}">Linha</th>
                    <th style="${_thr};text-align:center">Prob. Hist.</th>
                    <th style="${_thr};text-align:center">Fair Odd</th>
                    <th style="${_thr};text-align:center">Amostra</th>
                    <th style="${_thr};text-align:center">Veredicto</th>
                </tr></thead><tbody>`;
            opps.forEach(o => {
                const badge = o.pct >= 70 ? '<span style="background:var(--accent-green);color:#000;padding:1px 6px;border-radius:3px;font-size:9px;font-weight:700">FORTE</span>'
                    : o.pct >= 55 ? '<span style="background:var(--accent-yellow);color:#000;padding:1px 6px;border-radius:3px;font-size:9px;font-weight:700">PROVAVEL</span>'
                    : '<span style="color:var(--text-muted);font-size:9px">NEUTRO</span>';
                h += `<tr>
                    <td style="${_tdr}">${o.market}</td>
                    <td style="${_tdr};font-weight:600">${o.line}</td>
                    <td style="${_tdr};text-align:center;font-weight:700;color:${o.pct >= 65 ? 'var(--accent-green)' : 'var(--text-primary)'}">${o.pct}%</td>
                    <td style="${_tdr};text-align:center;${fairOddClass(o.fair_odd)}">${o.fair_odd}</td>
                    <td style="${_tdr};text-align:center;color:var(--text-muted)">${o.sample}j</td>
                    <td style="${_tdr};text-align:center">${badge}</td>
                </tr>`;
            });
            h += '</tbody></table></div></div>';
            return h;
        };

        const renderPlayerRanking = (players, teamName, color) => {
            if (!players.length) return '';
            let h = `<div style="margin-bottom:10px">
                <div style="font-size:10px;font-weight:700;color:${color};margin-bottom:6px;text-transform:uppercase">Ranking Jogadores — ${teamName}</div>
                <div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:10px">
                <thead><tr>
                    <th style="${_thr}">Jogador</th><th style="${_thr};text-align:center">Pos</th>
                    <th style="${_thr};text-align:center">Jogos</th>
                    <th style="${_thr};text-align:center">Fin/J</th><th style="${_thr};text-align:center">Alvo/J</th>
                    <th style="${_thr};text-align:center">O0.5 Fin</th><th style="${_thr};text-align:center">O1.5 Fin</th>
                    <th style="${_thr};text-align:center">O0.5 Gol</th><th style="${_thr};text-align:center">O1.5 Gol</th>
                    <th style="${_thr};text-align:center">Gols</th>
                </tr></thead><tbody>`;
            players.slice(0, 10).forEach(p => {
                const s05 = p.shots_lines?.['o0.5'];
                const s15 = p.shots_lines?.['o1.5'];
                const g05 = p.sot_lines?.['o0.5'];
                const g15 = p.sot_lines?.['o1.5'];
                const cellEv = (d) => {
                    if (!d) return `<td style="${_tdr};text-align:center;color:var(--text-muted)">-</td>`;
                    const c = d.pct >= 70 ? 'var(--accent-green)' : d.pct >= 50 ? 'var(--accent-yellow)' : 'var(--text-muted)';
                    return `<td style="${_tdr};text-align:center"><span style="color:${c};font-weight:700">${d.pct}%</span><br><span style="font-size:8px;color:var(--text-muted)">@${d.fair_odd}</span></td>`;
                };
                const posLabel = p.position === 'F' ? 'ATA' : p.position === 'M' ? 'MEI' : p.position === 'D' ? 'DEF' : p.position === 'G' ? 'GOL' : p.position || '?';
                h += `<tr>
                    <td style="${_tdr};font-weight:600">${p.name}</td>
                    <td style="${_tdr};text-align:center;font-size:9px">${posLabel}</td>
                    <td style="${_tdr};text-align:center">${p.matches}</td>
                    <td style="${_tdr};text-align:center;font-weight:700;color:var(--accent-green)">${p.avg_shots}</td>
                    <td style="${_tdr};text-align:center;font-weight:700;color:var(--accent-blue)">${p.avg_sot}</td>
                    ${cellEv(s05)}${cellEv(s15)}${cellEv(g05)}${cellEv(g15)}
                    <td style="${_tdr};text-align:center;font-weight:700">${p.total_goals}</td>
                </tr>`;
            });
            h += '</tbody></table></div></div>';
            return h;
        };

        let html = `<div style="background:linear-gradient(135deg, rgba(0,255,136,0.04), rgba(100,180,255,0.04));border:1px solid rgba(0,255,136,0.15);border-radius:12px;padding:16px;margin-bottom:12px">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
                <span style="font-size:18px">⚡</span>
                <div>
                    <div style="font-size:13px;font-weight:800;color:var(--accent-green);text-transform:uppercase;letter-spacing:1px">Oportunidades EV+ Identificadas</div>
                    <div style="font-size:10px;color:var(--text-muted)">Analise baseada em historico recente. "Fair Odd" = odd justa. Se o bookmaker oferece odd MAIOR, historicamente ha valor (+EV).</div>
                </div>
                <div style="margin-left:auto;font-size:9px;color:var(--text-muted);background:rgba(0,255,136,0.08);padding:4px 10px;border-radius:6px">
                    📦 Dados salvos no Supabase
                </div>
            </div>`;

        html += renderOppsTable(homeOpps.slice(0, 15), homeName, 'var(--accent-green)');
        html += renderOppsTable(awayOpps.slice(0, 15), awayName, 'var(--accent-blue)');

        // Player rankings side by side
        if (homePlayerRank.length || awayPlayerRank.length) {
            html += '<div style="font-size:11px;font-weight:700;color:var(--text-secondary);margin:8px 0 6px;text-transform:uppercase">🎯 Finalizacoes por Jogador</div>';
            html += renderPlayerRanking(homePlayerRank, homeName, 'var(--accent-green)');
            html += renderPlayerRanking(awayPlayerRank, awayName, 'var(--accent-blue)');
        }

        html += '</div>';
        return html;
    };

    // ── Montar tudo verticalmente ──
    return `<div>
        ${renderEvSummary(homeData, awayData, homeName || 'Casa', awayName || 'Fora')}
        ${renderTeam(homeData, homeName || 'Casa', 'var(--accent-green)')}
        <div style="height:8px"></div>
        ${renderTeam(awayData, awayName || 'Fora', 'var(--accent-blue)')}
        <div style="height:8px"></div>
        ${renderH2H(h2hData, homeName || 'Casa', awayName || 'Fora')}
    </div>
    <div style="font-size:10px;color:var(--text-muted);margin-top:12px;text-align:center;padding-top:8px;border-top:1px solid var(--border)">
        ★ Favorito pelas odds &nbsp;|&nbsp; ☆ Underdog &nbsp;|&nbsp; C = Casa &nbsp;|&nbsp; F = Fora &nbsp;|&nbsp; XI = Escalacao disponivel &nbsp;|&nbsp; O2.5/U2.5 = Over/Under 2.5 gols &nbsp;|&nbsp; Esc = Escanteios &nbsp;|&nbsp; Cart = Cartoes &nbsp;|&nbsp; 📦 = Salvo no Supabase
    </div>`;
}

// START — só carrega status, NÃO roda pipeline
init();
</script>

</body>
</html>
